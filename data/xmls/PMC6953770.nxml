<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.2 20190208//EN" "JATS-archivearticle1-mathml3.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="iso-abbrev">PLoS Comput. Biol</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, CA USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">31923173</article-id><article-id pub-id-type="pmc">6953770</article-id><article-id pub-id-type="publisher-id">PCOMPBIOL-D-18-01211</article-id><article-id pub-id-type="doi">10.1371/journal.pcbi.1007491</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Systems Science</subject><subj-group><subject>Dynamical Systems</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical Sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Systems Science</subject><subj-group><subject>Dynamical Systems</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical Sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Algebra</subject><subj-group><subject>Linear Algebra</subject><subj-group><subject>Eigenvalues</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Cell Biology</subject><subj-group><subject>Cytometry</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Data Visualization</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Cell Biology</subject><subj-group><subject>Cellular Types</subject><subj-group><subject>Animal Cells</subject><subj-group><subject>Connective Tissue Cells</subject><subj-group><subject>Fibroblasts</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Anatomy</subject><subj-group><subject>Biological Tissue</subject><subj-group><subject>Connective Tissue</subject><subj-group><subject>Connective Tissue Cells</subject><subj-group><subject>Fibroblasts</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Medicine and Health Sciences</subject><subj-group><subject>Anatomy</subject><subj-group><subject>Biological Tissue</subject><subj-group><subject>Connective Tissue</subject><subj-group><subject>Connective Tissue Cells</subject><subj-group><subject>Fibroblasts</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Data Visualization</subject><subj-group><subject>Infographics</subject><subj-group><subject>Graphs</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical Sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Probability Theory</subject><subj-group><subject>Probability Density</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Developmental Biology</subject><subj-group><subject>Cell Differentiation</subject></subj-group></subj-group></subj-group></article-categories><title-group><article-title>Dynamic distribution decomposition for single-cell snapshot time series identifies subpopulations and trajectories during iPSC reprogramming</article-title><alt-title alt-title-type="running-head">Dynamic distribution decomposition</alt-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-1025-0041</contrib-id><name><surname>Taylor-King</surname><given-names>Jake P.</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Formal analysis</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Methodology</role><role content-type="http://credit.casrai.org/">Visualization</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref><xref ref-type="aff" rid="aff002"><sup>2</sup></xref><xref ref-type="corresp" rid="cor001">*</xref></contrib><contrib contrib-type="author"><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-5861-7885</contrib-id><name><surname>Riseth</surname><given-names>Asbj&#x000f8;rn N.</given-names></name><role content-type="http://credit.casrai.org/">Formal analysis</role><role content-type="http://credit.casrai.org/">Methodology</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><xref ref-type="aff" rid="aff003"><sup>3</sup></xref></contrib><contrib contrib-type="author"><name><surname>Macnair</surname><given-names>Will</given-names></name><role content-type="http://credit.casrai.org/">Validation</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref><xref ref-type="aff" rid="aff004"><sup>4</sup></xref></contrib><contrib contrib-type="author"><name><surname>Claassen</surname><given-names>Manfred</given-names></name><role content-type="http://credit.casrai.org/">Funding acquisition</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Project administration</role><role content-type="http://credit.casrai.org/">Resources</role><role content-type="http://credit.casrai.org/">Supervision</role><role content-type="http://credit.casrai.org/">Visualization</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref></contrib></contrib-group><aff id="aff001">
<label>1</label>
<addr-line>Institute of Molecular Systems Biology, Department of Biology, ETHZ, Zurich, Switzerland</addr-line>
</aff><aff id="aff002">
<label>2</label>
<addr-line>Juvenescence AI, Viking House, Nelson Street, Douglas, Isle of Man, United Kingdom</addr-line>
</aff><aff id="aff003">
<label>3</label>
<addr-line>Mathematical Institute, University of Oxford, Oxford, United Kingdom</addr-line>
</aff><aff id="aff004">
<label>4</label>
<addr-line>Institute of Molecular Life Sciences, University of Zurich, Zurich, Switzerland</addr-line>
</aff><contrib-group><contrib contrib-type="editor"><name><surname>Nie</surname><given-names>Qing</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">
<addr-line>University of California Irvine, UNITED STATES</addr-line>
</aff><author-notes><fn fn-type="COI-statement" id="coi001"><p>The authors have declared that no competing interests exist.</p></fn><corresp id="cor001">* E-mail: <email>jake@juvenescence.ltd</email></corresp></author-notes><pub-date pub-type="collection"><month>1</month><year>2020</year></pub-date><pub-date pub-type="epub"><day>10</day><month>1</month><year>2020</year></pub-date><volume>16</volume><issue>1</issue><elocation-id>e1007491</elocation-id><history><date date-type="received"><day>12</day><month>7</month><year>2018</year></date><date date-type="accepted"><day>14</day><month>10</month><year>2019</year></date></history><permissions><copyright-statement>&#x000a9; 2020 Taylor-King et al</copyright-statement><copyright-year>2020</copyright-year><copyright-holder>Taylor-King et al</copyright-holder><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="pcbi.1007491.pdf"/><abstract><p>Recent high-dimensional single-cell technologies such as mass cytometry are enabling time series experiments to monitor the temporal evolution of cell state distributions and to identify dynamically important cell states, such as fate decision states in differentiation. However, these technologies are destructive, and require analysis approaches that temporally map between cell state distributions across time points. Current approaches to approximate the single-cell time series as a dynamical system suffer from too restrictive assumptions about the type of kinetics, or link together pairs of sequential measurements in a discontinuous fashion. We propose Dynamic Distribution Decomposition (DDD), an operator approximation approach to infer a continuous distribution map between time points. On the basis of single-cell snapshot time series data, DDD approximates the continuous time Perron-Frobenius operator by means of a finite set of basis functions. This procedure can be interpreted as a continuous time Markov chain over a continuum of states. By only assuming a memoryless Markov (autonomous) process, the types of dynamics represented are more general than those represented by other common models, e.g., chemical reaction networks, stochastic differential equations. Furthermore, we can <italic>a posteriori</italic> check whether the autonomy assumptions are valid by calculation of prediction error&#x02014;which we show gives a measure of autonomy within the studied system. The continuity and autonomy assumptions ensure that the same dynamical system maps between all time points, not arbitrarily changing at each time point. We demonstrate the ability of DDD to reconstruct dynamically important cell states and their transitions both on synthetic data, as well as on mass cytometry time series of iPSC reprogramming of a fibroblast system. We use DDD to find previously identified subpopulations of cells and to visualise differentiation trajectories. Dynamic Distribution Decomposition allows interpretation of high-dimensional snapshot time series data as a low-dimensional Markov process, thereby enabling an interpretable dynamics analysis for a variety of biological processes by means of identifying their dynamically important cell states.</p></abstract><abstract abstract-type="summary"><title>Author summary</title><p>High-dimensional single-cell snapshot measurements are now increasingly utilized to study dynamic processes. Such measurements enable us to evaluate cell population distributions and their evolution over time. However, it is not trivial to map these distribution across time and to identify dynamically important cell states, i.e. bottleneck regions of state space exhibiting a high degree of change. We present Dynamic Distribution Decomposition (DDD) achieving this task by encoding single-cell measurements as linear combination of basis function distributions and evolving these as a linear system. We demonstrate reconstruction of dynamically important states for synthetic data of a bifurcated diffusion process and mass cytometry data for iPSC reprogramming.</p></abstract><funding-group><funding-statement>J.P.T-K was supported by the medical research and development HDL-X grant from SystemsX.ch [URL: SystemsX.ch]. A.N.R. was partially supported by the EPSRC Centre For Doctoral Training in Industrially Focused Mathematical Modelling (EP/L015803/1) [URL: <ext-link ext-link-type="uri" xlink:href="http://gow.epsrc.ac.uk/NGBOViewGrant.aspx?GrantRef=EP/L015803/1">http://gow.epsrc.ac.uk/NGBOViewGrant.aspx?GrantRef=EP/L015803/1</ext-link>]. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts><fig-count count="7"/><table-count count="0"/><page-count count="21"/></counts><custom-meta-group><custom-meta id="data-availability"><meta-name>Data Availability</meta-name><meta-value>Reusing data from previous study (Zunder et. al.). This data is available publicly here: <ext-link ext-link-type="uri" xlink:href="https://community.cytobank.org/cytobank/projects/688">https://community.cytobank.org/cytobank/projects/688</ext-link>.</meta-value></custom-meta></custom-meta-group></article-meta><notes><title>Data Availability</title><p>Reusing data from previous study (Zunder et. al.). This data is available publicly here: <ext-link ext-link-type="uri" xlink:href="https://community.cytobank.org/cytobank/projects/688">https://community.cytobank.org/cytobank/projects/688</ext-link>.</p></notes></front><body><sec sec-type="intro" id="sec001"><title>Introduction</title><p>Data-driven reconstruction of dynamic processes constitutes a central aim of systems biology. High-dimensional single-cell molecularly resolved time series data is becoming a key data source for this task [<xref rid="pcbi.1007491.ref001" ref-type="bibr">1</xref>, <xref rid="pcbi.1007491.ref002" ref-type="bibr">2</xref>]. However, these technologies are destructive, and consequently result in <italic>snapshot time series</italic> data originating from batches of cells collected at time points of interest. A longstanding and still challenging problem is to reconstruct dynamic biological processes from this data, to the end of identifying dynamically important states, i.e. regions of state space that cells preferentially pass through, these include transitionary states (bottlenecks) when differentiation decisions are made, and terminal states. With <italic>snapshot time series</italic>, it is challenging to identify these states as we cannot track the state of an individual cell from one time point to a new state at a later time point, one has to temporally map between distributions over the state space.</p><p>Chemical reaction networks (CRNs) are a popular class of parametric models assuming that the temporal state evolution is well described by chemical kinetics. Ordinary differential equations (ODEs) are used to describe smooth deterministic dynamics, and stochastic differential equations (SDEs) for dynamics in the low copy number/concentration regimes affected by stochastic fluctuations. Chemical reaction network models require explicit definition of the model structure, i.e. set of reactions or interactions among the system components. This task is manageable for small, well defined systems, such as small signalling systems [<xref rid="pcbi.1007491.ref003" ref-type="bibr">3</xref>]. However, by means of high-dimensional measurements, we typically observe larger systems comprising at least dozens of components with largely <italic>a priori</italic> undefined interactions. This situation results in a combinatorial explosion of model variants that cannot be exhaustively evaluated [<xref rid="pcbi.1007491.ref004" ref-type="bibr">4</xref>, <xref rid="pcbi.1007491.ref005" ref-type="bibr">5</xref>]. Alternative approaches are agnostic with regards to parametric form and model structure and use a probabilistically-motivated rule to map between distributions, e.g., one optimal transport method maps neighbours at one time point to the nearest neighbour at the next time point [<xref rid="pcbi.1007491.ref006" ref-type="bibr">6</xref>]. However, such generic approaches are rather extreme in their agnosticism and abandon reasonable assumptions on the dynamics of cellular systems, e.g., that cells can be modelled as an <italic>autonomous</italic> dynamical systems in continuous time, such as a Markov chain, where the cell&#x02019;s current state infers its likely future state independent of the current time within the experiment. Such autonomy assumptions are also commonly used in many mechanistic CRN, SDE and ODE biochemical models [<xref rid="pcbi.1007491.ref007" ref-type="bibr">7</xref>, <xref rid="pcbi.1007491.ref008" ref-type="bibr">8</xref>].</p><p>Operator approximation methods constitute an alternative class of models that are agnostic to model structure and yet allow for encoding of general system properties such as autonomy, conservation of mass, and boundary conditions. These methods approximate both the Perron&#x02013;Frobenius operator [<xref rid="pcbi.1007491.ref009" ref-type="bibr">9</xref>] and the Koopman operator [<xref rid="pcbi.1007491.ref010" ref-type="bibr">10</xref>]. These operators describe the evolution of distributions and other functions of a dynamical system&#x02019;s state. The early theory on these operators was developed to describe systems in classical, statistical, and quantum mechanics [<xref rid="pcbi.1007491.ref011" ref-type="bibr">11</xref>&#x02013;<xref rid="pcbi.1007491.ref015" ref-type="bibr">15</xref>], and in probability theory [<xref rid="pcbi.1007491.ref016" ref-type="bibr">16</xref>, <xref rid="pcbi.1007491.ref017" ref-type="bibr">17</xref>]. The operators fully describe a nonlinear dynamical system as a linear system in higher, possibly infinite, dimensions. Hence, techniques from linear analysis can be utilised to gain insight from the systems; in particular, calculation of eigenvalues and eigenfunctions allow for timescale separation. Eigenfunctions of linear operators show the fundamental building blocks of possible behaviours available to a dynamical system, e.g., exponential growth/decay, oscillations, a steady state. Data-driven approximations to the operators have been investigated in past years, originating in the computational fluid dynamics community [<xref rid="pcbi.1007491.ref018" ref-type="bibr">18</xref>&#x02013;<xref rid="pcbi.1007491.ref022" ref-type="bibr">22</xref>]. Their focus is to approximate finite-dimensional projections of the Koopman operator with a family of algorithms known as Dynamic Mode Decomposition (DMD). The algorithm has further been applied to other areas such as neuroscience, infectious disease epidemiology, and control theory [<xref rid="pcbi.1007491.ref023" ref-type="bibr">23</xref>&#x02013;<xref rid="pcbi.1007491.ref025" ref-type="bibr">25</xref>] and parameter estimation [<xref rid="pcbi.1007491.ref026" ref-type="bibr">26</xref>, <xref rid="pcbi.1007491.ref027" ref-type="bibr">27</xref>]. When carrying out approximations of these operators, eigenvalues can be ordered in terms of magnitude to extract slow behaviour (approximated well) to fast behaviour (representative of noise) [<xref rid="pcbi.1007491.ref027" ref-type="bibr">27</xref>]. Dynamic Mode Decomposition assumes that the data is recorded at equally spaced time points, whilst our work extends the technique to support data recorded at arbitrary time points.</p><p>We adapt Dynamic Mode Decomposition to identify dynamically important states from single-cell snapshot time series. Our method is based on representing the distribution at each time point via basis functions and calculating an approximation to the Perron&#x02013;Frobenius operator by minimising an error term&#x02014;akin to least squares when fitting ODEs. The error terms then indicate how well the data fits into the model assumptions <italic>a posteriori</italic>: primarily that the data is generated by an autonomous dynamical system. Because the Perron&#x02013;Frobenius operator describes the evolution of distributions, we name our approach Dynamic Distribution Decomposition (DDD) in keeping with the DMD naming convention. DDD leads to the calculation of a Markov transition rate matrix but over a continuum of states&#x02014;as opposed to discrete states. As previously mentioned, one can then use standard methods of analysis for linear operators based on eigen-decompositions. As Markov processes can be represented as directed weighted graphs, our graph can be evaluated in two dimensions and then the high-dimensional operator and its corresponding eigenfunctions have a natural low dimensional representation. Our approach also allows for visualisation of inferred state trajectories as a branching structure when cell fates are stochastic, and approximation of fitting error when matching model prediction to sample data. By using a Markov rate approach over distributions, we overcome the difficulties listed above. In particular: our approach generalises the previously listed mechanistic models (CRNs, SDEs, ODEs) and works similarly to optimal transport methods&#x02014;however, allowing for fitting error and not achieving having perfect fits by interpolating between time points. We demonstrate DDD on a synthetic stochastic dynamical system representing cells making a cell differentiation decision as well as for a mass cytometry time series taken from an iPSC reprogramming of a fibroblast cell line taken from Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>] to re-identify subpopulations of cells as first elucidated in the original manuscript.</p></sec><sec sec-type="results" id="sec002"><title>Results</title><sec id="sec003"><title>Inference of state distribution dynamics by approximation of the Perron&#x02013;Frobenius operator</title><p>We developed a method herein referred to as Dynamic Distribution Decomposition to analyse snapshot time series, consisting of the following stages (illustrated in <xref ref-type="fig" rid="pcbi.1007491.g001">Fig 1</xref>): (<italic>a</italic>.) data at each recorded time point <italic>t</italic><sub>1</sub>, &#x02026;, <italic>t</italic><sub><italic>R</italic></sub> are fitted to a set of basis functions and (<italic>b</italic>.) encoded into coefficient vectors <bold><italic>c</italic></bold><sub>1</sub>, &#x02026;, <bold><italic>c</italic></bold><sub><italic>R</italic></sub>; (<italic>c</italic>.) a fitting procedure is carried out to infer the most likely continuous linear map between the coefficients, generating fitting errors <italic>&#x003b5;</italic><sub>1</sub>, &#x02026;, <italic>&#x003b5;</italic><sub><italic>R</italic></sub>; (<italic>d</italic>.) eigenfunctions are then analysed; and (<italic>e</italic>.) in high dimensions graph based visualisations can be used for eigenfunctions, for full details see <xref ref-type="sec" rid="sec012">Methods</xref> section. In the case where probability density functions are used as basis functions, the linear map denoted <italic>P</italic> can be interpreted as a transition rate matrix; the structure of this matrix is often dense but its dominating structure can be elucidated via Lasso regularisation, see <xref ref-type="fig" rid="pcbi.1007491.g001">Fig 1(f)</xref>. We applied our method to two systems: first, simulated particles in a potential well; and second, experimental data of iPSC reprogramming of a fibroblast system.</p><fig id="pcbi.1007491.g001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g001</object-id><label>Fig 1</label><caption><title>Illustration of Dynamic Distribution Decomposition workflow.</title><p>(a.) Gaussian mixture models as basis functions: single-cell profiles from each time point are fitted to a basis of Gaussian mixture model, two distributions shown in red and blue; (b.) identification of the coefficients <bold><italic>c</italic></bold>(<italic>t</italic>) at each time point, <italic>t</italic> = <italic>t</italic><sub>1</sub>, &#x02026;, <italic>t</italic><sub><italic>R</italic></sub>; (c.) the Perron&#x02013;Frobenius matrix <italic>P</italic> enables us us to infer the likely state for all time points and generate errors <italic>&#x003b5;</italic><sub>1</sub>, &#x02026;, <italic>&#x003b5;</italic><sub><italic>R</italic></sub>; (d.) examination of the eigenfunctions in low dimensions; or in high dimensions (e.) using graphical visualisations; and (f.) a Lasso regularisation can reveal sparse structure.</p></caption><graphic xlink:href="pcbi.1007491.g001"/></fig></sec><sec id="sec004"><title>Particles in potential well with fluctuations</title><p>The first numerical example is for illustrative purposes whereby we know the stochastic process generating the sample points. We consider simulated particles in a bistable potential well undergoing fluctuations. After initialisation around point (1, 1)<sup>&#x022ba;</sup>/2, particles stochastically switch between one of two paths: <italic>y</italic> = 2<italic>x</italic> or <italic>y</italic> = <italic>x</italic>/2 to finally settle in one of the two final state (2, 4)<sup>&#x022ba;</sup> or (4, 2)<sup>&#x022ba;</sup>. We model this process by the two-dimensional SDE <inline-formula id="pcbi.1007491.e001"><alternatives><graphic xlink:href="pcbi.1007491.e001.jpg" id="pcbi.1007491.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">X</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mo>:</mml:mo><mml:mi>t</mml:mi><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
<disp-formula id="pcbi.1007491.e002"><alternatives><graphic xlink:href="pcbi.1007491.e002.jpg" id="pcbi.1007491.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>d</mml:mtext><mml:msub><mml:mi mathvariant="bold-italic">X</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:mo>&#x02207;</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">X</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>d</mml:mtext><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msqrt><mml:mspace width="0.166667em"/><mml:mtext>d</mml:mtext><mml:msub><mml:mi mathvariant="bold-italic">W</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(1)</label></disp-formula>
where <bold><italic>W</italic></bold><sub><italic>t</italic></sub> is a two-dimensional Wiener process. The potential well is of the form
<disp-formula id="pcbi.1007491.e003"><alternatives><graphic xlink:href="pcbi.1007491.e003.jpg" id="pcbi.1007491.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>V</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mo>&#x02225;</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>]</mml:mo><mml:mo>-</mml:mo></mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>10</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mo>&#x02225;</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mo>&#x02225;</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo>,</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mo>-</mml:mo><mml:mo>&#x02225;</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:msup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mo>-</mml:mo><mml:mo>&#x02225;</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:msup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msup><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(2)</label></disp-formula></p><p>As an initial condition at <italic>t</italic> = <italic>t</italic><sub>1</sub>, the sample is placed with a multivariate normal distribution with mean <bold><italic>&#x003bc;</italic></bold> = (1, 1)<sup>&#x022ba;</sup>/2 and covariance matrix &#x003a3; = <italic>I</italic><sub>2</sub>/2 where <italic>I</italic><sub>2</sub> is the identity matrix. The diffusion constant is chosen to be <italic>D</italic> = 1/4. Along the lines <italic>x</italic> = 0 and <italic>y</italic> = 0, the system has reflecting boundaries imposed. For simulations, the Euler&#x02013;Maruyama (EM) numerical scheme is used with time step <italic>&#x003b4;t</italic> = 2<sup>&#x02212;9</sup>; for this system the EM scheme is identical to the Milstein scheme and is therefore of order 1. Three sample trajectories are visualised, see <xref ref-type="fig" rid="pcbi.1007491.g002">Fig 2(a)</xref>; and the potential well is plotted, see <xref ref-type="fig" rid="pcbi.1007491.g002">Fig 2(b)</xref>.</p><fig id="pcbi.1007491.g002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g002</object-id><label>Fig 2</label><caption><title>Illustration of stochastic dynamical system described by Eqs <xref ref-type="disp-formula" rid="pcbi.1007491.e002">(1)</xref> and <xref ref-type="disp-formula" rid="pcbi.1007491.e003">(2)</xref> and fitting error of Dynamic Distribution Decomposition process.</title><p>(a.) Three simulated trajectories are shown from the stochastic dynamical system described by Eqs <xref ref-type="disp-formula" rid="pcbi.1007491.e002">(1)</xref> and <xref ref-type="disp-formula" rid="pcbi.1007491.e003">(2)</xref>. (b.) The potential well as described in <xref ref-type="disp-formula" rid="pcbi.1007491.e003">Eq (2)</xref> is shown. (c.) Log-log error plot showing recorded time points against log<sub>10</sub> of the percentage error (of the DDD fit); the original data set (black solid line) has a mean error of 0.9%; the perturbed data set (dashed red line) has a mean error of 3.1%; the perturbed data set with the erroneous data point removed (dotted red line) has an error of 0.8%; and the data set with systematic error (dashed blue line) has a mean error of 0.5%.</p></caption><graphic xlink:href="pcbi.1007491.g002"/></fig><p>The system is observed at time points <italic>t</italic> = 0, 1, 2, 3, 5, 8, 13, 21, 34, 55 and for each time point 2000 trajectories are initiated at <italic>t</italic> = 0 and simulated until the observation time (replicating the destructive sampling process). Using Gaussian mixture models, we use 3 components for each time point totalling <italic>N</italic> = 30 basis functions. For an illustration showing the entries of the coefficient vectors <inline-formula id="pcbi.1007491.e004"><alternatives><graphic xlink:href="pcbi.1007491.e004.jpg" id="pcbi.1007491.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula>, see the <xref ref-type="supplementary-material" rid="pcbi.1007491.s002">S2 Appendix</xref>.</p><sec id="sec005"><title>Extrema of eigenfunctions identify steady state and bistable paths</title><p>The eigenfunctions of the approximated Perron&#x02013;Frobenius operator allow us to identify the steady state and bistable paths in the above system. In low dimensions we visualise eigenfunctions of <italic>P</italic> as a continuous function, see <xref ref-type="fig" rid="pcbi.1007491.g003">Fig 3(a), 3(b) and 3(c)</xref>; or a graph, see <xref ref-type="fig" rid="pcbi.1007491.g003">Fig 3(d), 3(e) and 3(f)</xref> and <xref ref-type="sec" rid="sec012">Methods</xref> section. Eigenfunctions corresponding to eigenvalues with large absolute value are approximated with larger error than in cases with small eigenvalues, a point also noted in Ref. [<xref rid="pcbi.1007491.ref027" ref-type="bibr">27</xref>]; notice in <xref ref-type="fig" rid="pcbi.1007491.g003">Fig 3</xref> that the eigenfunctions become less (anti-)symmetric along <italic>y</italic> = <italic>x</italic> as the size of |&#x003bb;| increases. Also, eigenvalues and eigenfunctions are basis function dependent, so changes in basis functions change the eigen-decomposition. However, regardless of changes to the basis functions, the key dynamic states (as visible in the eigenfunctions) remain the same provided the changes to the basis functions are not drastic. Since we use 30 basis functions, hypothetically we can find 30 eigenfunctions. However, we just plot the first three eigenfunctions; these are real with no imaginary component. From these figures, it is clear that three basins around (2, 4)<sup>&#x022ba;</sup> and (4, 2)<sup>&#x022ba;</sup> and at the initial condition (1, 1)<sup>&#x022ba;</sup>/2 are dynamically important. Therefore, examination of the first few eigenfunctions allows for detection of dynamically important states.</p><fig id="pcbi.1007491.g003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g003</object-id><label>Fig 3</label><caption><title>Dynamic distribution decomposition applied to data generated by stochastic dynamical system described by Eqs <xref ref-type="disp-formula" rid="pcbi.1007491.e002">(1)</xref> and <xref ref-type="disp-formula" rid="pcbi.1007491.e003">(2)</xref>.</title><p>Plots (a)&#x02013;(c) show a plot of the two dimensional eigenfunction, and plots (d)&#x02013;(f) shows a corresponding graph representation of the eigenfunctions, for full details see <xref ref-type="sec" rid="sec012">Methods</xref> section.</p></caption><graphic xlink:href="pcbi.1007491.g003"/></fig></sec><sec id="sec006"><title>Dynamic distribution decomposition is robust to noisy observations</title><p>We evaluated the robustness of our inference procedure to measurement noise. Specifically, three further modified data sets are also considered: (<italic>i</italic>.) considering a single time point perturbed by additive random noise; (<italic>ii</italic>.) removing this perturbed time point and fitting the model; and (<italic>iii</italic>.) randomly perturbing all time points by additive random noise. For all perturbations, sample points are modified by an additive error term drawn from a zero-mean multivariate Gaussian with covariance matrix &#x003a3; = <italic>I</italic><sub>2</sub>/4.</p><p>We plot the time points transformed by log<sub>10</sub>(<italic>x</italic> + 1) against the log-percentage error, i.e., 2 + log<sub>10</sub>(<italic>&#x003b5;</italic><sub><italic>r</italic></sub>) for <italic>r</italic> = 1, &#x02026;, <italic>R</italic>, see <xref ref-type="fig" rid="pcbi.1007491.g002">Fig 2(c)</xref>. We find that all data sets have consistently low error, but with a small increase in error at the beginning of the realisation; this is due to the boundary conditions which were not incorporated into the choice in basis functions, which one would typically do when solving PDEs via a Galerkin approximation. The data set perturbed at time <italic>t</italic> = 8 (dashed red line) leads to increased error immediately before and after this time point (circled in black); after removing this erroneous data (fitting without <italic>t</italic> = 8) one obtains reduced errors comparable to the original data set (dotted red line). When adding systematic error to all time points (dashed blue line), one observes similar (slightly smaller) errors to the original data set; the reason for this is that the Gaussian basis functions now have a covariance matrix with larger entries (whilst the means remain similar) leading to smaller <italic>L</italic><sup>2</sup> errors, see <xref ref-type="disp-formula" rid="pcbi.1007491.e045">Eq (19)</xref>. The eigenfunction plots are also similar to those generated by the original data set but more spread out (not plotted). In summary: adding noise to a single time point allows for detection of non-autonomous behaviour; adding noise to all time points makes the process appear more random (and hence autonomous); and therefore DDD is robust with regards to noisy observations.</p></sec><sec id="sec007"><title>Lasso regularisation reveals sparse topology</title><p>We utilize Lasso regularization to identify key transition states, see <xref ref-type="sec" rid="sec012">Methods</xref> section. Specifically, <italic>P</italic> as a transition rate matrix with the nodes located at the mean of the components of the Gaussian mixture model. The resulting network is cluttered and is hard to identify meaningful states or transition, see <xref ref-type="fig" rid="pcbi.1007491.g004">Fig 4(a)</xref>. Lasso regularisation encourages sparsity and reveals the simple underlying structure, see <xref ref-type="fig" rid="pcbi.1007491.g004">Fig 4(b)</xref>. The skeletal structure shows that around the initial condition the particle becomes strongly committed to one branch over the other&#x02014;an accurate reflection of the dynamical system.</p><fig id="pcbi.1007491.g004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g004</object-id><label>Fig 4</label><caption><title>Dynamic distribution decomposition applied to data generated by stochastic dynamical system described by Eqs <xref ref-type="disp-formula" rid="pcbi.1007491.e002">(1)</xref> and <xref ref-type="disp-formula" rid="pcbi.1007491.e003">(2)</xref>.</title><p>The plots show graph representations of <italic>P</italic> (interpreted as a Markov transition rate matrix), colours of edges denote magnitude of rate change from one node to another, and node colours denote rate at which node decays. Colours scaled to unit interval. (a.) Matrix <italic>P</italic> plotted without Lasso regularisation; and (b.) matrix <italic>P</italic> plotted with Lasso regularisation, <italic>&#x003b2;</italic> = 1/[100 &#x000d7; mean(<italic>M</italic>)], see <xref ref-type="sec" rid="sec012">Methods</xref> section.</p></caption><graphic xlink:href="pcbi.1007491.g004"/></fig></sec></sec><sec id="sec008"><title>Mass cytometry data: iPSC fibroblast reprogramming</title><p>We studied the process of iPSC reprogramming using Dynamic Distribution Decomposition. We considered data from a study established by Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>]. Specifically, the reprogramming of a fibroblast cell line differentiating into an induced pluripotent stem cell state was studied using mass cytometry. This <italic>in vitro</italic> experimental system is often perceived to be representative of an autonomous system [<xref rid="pcbi.1007491.ref008" ref-type="bibr">8</xref>]. However, we can use DDD to suggest when this may or may not be true.</p><p>Cells are labelled using mass-tag cell barcoding, stained with antibodies before being measured via CyTOF. We focus our study to the cell line with the largest amount of cell events, i.e. on a Nanog-Neo secondary mouse embroyic fibroblasts (MEF) that expresses neomycin resistance gene from the endogenous Nanog locus. Reprogramming was monitored by Dox induction for 16 days followed by subsequent addition of LIF; the experiment was carried out over 30 days. Experiments were initialised together and cells harvested every 2 days until 24 days with a final measurement taken at the final time point; 18 protein markers were used as proxies to measure pluripotency, differentiation, cell cycle status, and cellular signalling.</p><p>We now briefly state our method for choosing basis functions. In the synthetic data example, we used prior information that there were 3 clusters, so used a 3 component Gaussian mixture model for each time (therefore <italic>N</italic> = 30 for 10 time points). For non-synthetic data we do not necessarily have this information, therefore we developed an approach to choose an expressive set of basis functions without letting their number grow too large and thereby ensure efficient solving of the minimisation problem later presented in <xref ref-type="disp-formula" rid="pcbi.1007491.e050">Eq (23)</xref>. We fit multiple Gaussian mixture models to each time point, varying the number of components until the AIC curve flattened out [<xref rid="pcbi.1007491.ref029" ref-type="bibr">29</xref>]; in our case this happens at approximately 8 basis functions per time point. To avoid overfitting, we use regularisation to specify minimum diagonal entries of the covariance matrix and encourage separation of basis functions. As our data has been scaled via the commonly used transformation function <italic>f</italic>(<italic>x</italic>) = arcsinh(<italic>x</italic>/5) [<xref rid="pcbi.1007491.ref030" ref-type="bibr">30</xref>, <xref rid="pcbi.1007491.ref031" ref-type="bibr">31</xref>] and then standardised by <italic>z</italic>-scoring, we choose a regularisation value of 1/2; smaller values can be used should one wish to capture sharp peaks, but at the cost of additional basis functions. Finally, for each time point we cluster the data into these Gaussian mixture models and remove poorly populated components. Here, after clustering, we remove any basis functions which represent less than <italic>&#x003b1;</italic> &#x000d7; 100% of the data. Therefore, it should be noted that obtaining a good fit to the matrix <italic>P</italic> is a payoff between: (<italic>i</italic>.) number of basis functions per time point (i.e., what is the maximum number of clusters per time point?); (<italic>ii</italic>.) the regularisation value (i.e., how sharp peaks can one fit?); and (<italic>iii</italic>.) the drop rate <italic>&#x003b1;</italic> (i.e., what fraction of data points does each basis function have to represent?).</p><p>We now decrease <italic>&#x003b1;</italic> and evaluate whether we have sufficient basis functions. We plot the percentage fitting error at each time point and the mean percentage error as a function of <italic>&#x003b1;</italic>, see <xref ref-type="fig" rid="pcbi.1007491.g005">Fig 5(a) and 5(b)</xref>. These figures show that as <italic>&#x003b1;</italic> decreases, the error only minimally decreases for large increases in the total number of basis functions <italic>N</italic>. We can also view the eigenvalues plotted in the complex plane for various values of <italic>&#x003b1;</italic>, see <xref ref-type="fig" rid="pcbi.1007491.g005">Fig 5(c)</xref>. We rescaled time to the unit interval, therefore one will not be able observe eigenfunctions with a corresponding non-zero eigenvalue &#x0211c;(&#x003bb;) &#x0003e; &#x02212; 1, i.e., we cannot observe timescales slower than the observation window. We notice for <italic>&#x003b1;</italic> = 0.005 that &#x0211c;(&#x003bb;<sub>1</sub>) = &#x02212;1.06 so we are confident decreasing <italic>&#x003b1;</italic> will not offer much benefit. Additionally in the cases where <italic>&#x003b1;</italic> = 0.01 and <italic>&#x003b1;</italic> = 0.005, the extrema of the first few eigenfunctions correspond to the same basis functions (not plotted). For an illustration showing the entries of the coefficient vectors <inline-formula id="pcbi.1007491.e005"><alternatives><graphic xlink:href="pcbi.1007491.e005.jpg" id="pcbi.1007491.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> for the instance when <italic>&#x003b1;</italic> = 0.005, see the <xref ref-type="supplementary-material" rid="pcbi.1007491.s002">S2 Appendix</xref>.</p><fig id="pcbi.1007491.g005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g005</object-id><label>Fig 5</label><caption><title>Dynamic distribution decomposition applied to Nanog-Neo cell line data taken from Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>].</title><p>(a.) Fitting error plot showing log<sub>10</sub> transformed percentage error plotted against time for different values of <italic>&#x003b1;</italic> (described in main text); (b.) log-log plot of mean fitting error plotted against &#x02212;log<sub>10</sub>(<italic>&#x003b1;</italic>), mean error decreases as alpha decreases; (c.) complex plot of eigenvalues &#x003bb; of Perron&#x02013;Frobenius matrix <italic>P</italic> for different values of <italic>&#x003b1;</italic>; (d.) Fitting error plot showing log<sub>10</sub> transformed percentage error plotted against time for <italic>&#x003b1;</italic> = 0.05 (mean error 14.1%), two further Perron&#x02013;Frobenius matrices are fitted using only the: first 8 time points (mean error 8.4%); and last 6 time points (mean error 14.0%).</p></caption><graphic xlink:href="pcbi.1007491.g005"/></fig><sec id="sec009"><title>Loss of dynamic autonomy after stimulus removal</title><p>When a stochastic dynamical system is autonomous, the current state of the system determines the likely future states; here we show that after and including <italic>t</italic> = 16 days the system becomes less autonomous, once the Dox induction had ended. We plot the error again at each time point for <italic>&#x003b1;</italic> = 0.005 (mean error 14.1%), see <xref ref-type="fig" rid="pcbi.1007491.g005">Fig 5(d)</xref>. We notice that time points after and including <italic>t</italic> = 16 days contain the vast majority of fitting error. To rule out the possibility that the dynamical system instantaneously changed at <italic>t</italic> = 16 days, we fit two Perron&#x02013;Frobenius matrices, one using the first 8 time points (mean error 8.4%) and a second using the last 6 time points with all fits using the same basis functions (mean error 14.0%). We find that there is still much more error contained in the final 6 time points compared to the first 8.</p><p>The autonomous dynamical system assumption means that using the data presented, the future states of the system depend on the current state. While this is likely true within a cell culture system, we only observe a tiny fraction of the state space of the dynamical system as we do not measure the transcriptome and the vast majority of the proteome. Therefore, it seems reasonable to assume that from <italic>t</italic> = 16 days, we are not observing enough of the dynamical system to obtain a linear map between distributions. This insight suggests further single-cell experiments at these later time points using technologies allowing greater &#x02018;omic&#x02019; profiling, e.g., single-cell RNA-Seq.</p></sec><sec id="sec010"><title>Inferred dynamically important states agree with previously described cell subpopulations</title><p>We evaluated the extreme of the eigenfunctions of the approximated Perron&#x02013;Frobenius operator to re-identify cell subpopulations found in Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>]. We first plot the first 6 eigenfunctions, see <xref ref-type="fig" rid="pcbi.1007491.g006">Fig 6</xref>. Nodes that are close together to each other in 18 dimensions (using Euclidean distance) as plotted as close to each other in 2 dimensions. Protein expression of the basis functions are also plotted using the same coordinates as the graph, see extra figure in <xref ref-type="supplementary-material" rid="pcbi.1007491.s002">S2 Appendix</xref>.</p><fig id="pcbi.1007491.g006" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g006</object-id><label>Fig 6</label><caption><title>Dynamic distribution decomposition applied to Nanog-Neo cell line data taken from Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>].</title><p>Plots (a)&#x02013;(f) show a graph representation of the eigenfunctions, for full details see <xref ref-type="sec" rid="sec012">Methods</xref> section. Groups as defined in the text are circled and coloured in: red (group A, MEF-like); blue (group B, mesendoderm); and green (group C, ESC-like).</p></caption><graphic xlink:href="pcbi.1007491.g006"/></fig><p>When examining the extrema of the eigenfunctions, basis functions seem to cluster in 3 groups: group A centred around basis function 32; group B with members 56, 61, and 65; and group C with one member, basis function 66. Our algorithm recovers the same populations as stated in Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>]: cells with low Ki-67 expression do not successfully reprogram and remain MEF-like (group A); cells with high Ki-67 expression then subdivide into two populations, an embryonic stem cell-like (ESC-like) population with Nanog<sup>+</sup>, Sox2<sup>+</sup>, and CD54<sup>+</sup>(group C) and a mesendoderm like population with Nanog<sup>&#x02212;</sup>, Sox2<sup>&#x02212;</sup>, Lin-28<sup>+</sup>, CD24<sup>+</sup>expression (group B). As our basis functions were added sequentially per time point, the MEF-like population appeared first.</p><p>DDD suggests a few new insights previously not elucidated in Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>]. We find according to the fitted Perron&#x02013;Frobenius operator, MEF-like cells form the steady state (when &#x003bb; = 0). Therefore, the model predicts all cells would revert to fibroblasts if enough time passes&#x02014;although one has to be careful over interpreting predictions due to the higher error after <italic>t</italic> = 16 days.</p></sec><sec id="sec011"><title>Lasso regularisation reveals sparse topology of iPSC dynamics</title><p>Reminiscent of the SDE example, the graph as induced by the transition rate matrix <italic>P</italic> is cluttered due to an abundance of low weighted edges, see <xref ref-type="fig" rid="pcbi.1007491.g007">Fig 7(a)</xref>; we apply the Lasso modification to reveal a two branching points, see <xref ref-type="fig" rid="pcbi.1007491.g007">Fig 7(b)</xref> and <xref ref-type="sec" rid="sec012">Methods</xref> section. Finally, to focus on the 3 groups previously identified, we prune edges leading to unannotated nodes to obtain an easily interpretable branching structure, see <xref ref-type="fig" rid="pcbi.1007491.g007">Fig 7(c)</xref>. This figure suggests that at basis function 53 (close to basis function 1, i.e., the initial state), a cell moves to towards branching basis function 16 (CD73<sup>&#x02212;</sup>, CD140a<sup>+</sup>, CD54<sup>+</sup>, Oct-4<sup>+</sup>), and then has a decision to move towards basis function 32 (group A, MEF-like) or to reach a second branching point at basis function 29 (CD73<sup>+</sup>, CD140a<sup>+</sup>, CD54<sup>&#x02212;</sup>, Oct-4<sup>+</sup>, KLF4<sup>+</sup>). At basis function 29, the cell will then choose between basis functions 56, 61 and 65 (group B, mesendoderm population), or towards basis function 66 (group C, ESC-like); there is also a weakly weighted edge back to basis function 32 (group A, MEF-like). The state described by basis function 29 was previously described in Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>], but we are able to include an additional transitionary state by means of basis function 16. We can conclude that the cell decision towards becoming remaining MEF-like is made early during the course of the experiment: basis function 16 was placed with the data recorded at 6days; basis function 29 was placed with the data recorded at 12days. As a negative control, the method has also been applied a dataset from Ref. [<xref rid="pcbi.1007491.ref032" ref-type="bibr">32</xref>] in <xref ref-type="supplementary-material" rid="pcbi.1007491.s004">S4 Appendix</xref>.</p><fig id="pcbi.1007491.g007" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1007491.g007</object-id><label>Fig 7</label><caption><title>Dynamic distribution decomposition applied to Nanog-Neo cell line data taken from Zunder <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref028" ref-type="bibr">28</xref>].</title><p>The plots show graph representations of <italic>P</italic> (interpreted as a Markov transition rate matrix), colours of edges denote magnitude of rate change from one node to another, and node colours denote rate at which node decays. Colours scaled to unit interval. (a.) matrix <italic>P</italic> plotted without Lasso regularisation; and (b.) matrix <italic>P</italic> plotted with Lasso regularisation, <italic>&#x003b2;</italic> = 1/[800 &#x000d7; mean(<italic>M</italic>)], see <xref ref-type="sec" rid="sec012">Methods</xref> section. In (c.) the graph structure from (b.) has unannotated end nodes removed and is rearranged into a simple branching structure. Groups as defined in the text are circled and coloured in: red (group A, MEF-like); blue (group B, mesendoderm); and green (group C, ESC-like).</p></caption><graphic xlink:href="pcbi.1007491.g007"/></fig></sec></sec></sec><sec sec-type="materials|methods" id="sec012"><title>Methods</title><p>We now give the mathematical set-up to our problem, additional technical details are given in the <xref ref-type="supplementary-material" rid="pcbi.1007491.s001">S1 Appendix</xref>, see also [<xref rid="pcbi.1007491.ref033" ref-type="bibr">33</xref>, <xref rid="pcbi.1007491.ref034" ref-type="bibr">34</xref>]. The method follows the following steps: (<italic>i</italic>.) the statement is posed that the temporal evolution of cell states follows a linear partial differential equation; (<italic>ii</italic>.) the distribution of the sample points at each time point can be encoded into a sequence of basis functions; (<italic>iii</italic>.) the weights of these basis functions can change dynamically interpolating between sample points; and (<italic>iv</italic>.) we fit the form of the matrix approximation of differential operator around these changing basis functions; and (<italic>v</italic>.) study the eigenfunctions. The workflow of the method is also as an illustration in <xref ref-type="fig" rid="pcbi.1007491.g001">Fig 1</xref>.</p><sec id="sec013"><title>Mathematical set-up</title><p>Assume we have a sequence of <italic>R</italic> experimental readings at time points <italic>t</italic><sub>1</sub> &#x0003c; &#x02026; &#x0003c; <italic>t</italic><sub><italic>R</italic></sub>; without loss of generality we choose <italic>t</italic><sub>1</sub> = 0. At each time point, <italic>n</italic><sub><italic>r</italic></sub> cells are harvested with states <inline-formula id="pcbi.1007491.e006"><alternatives><graphic xlink:href="pcbi.1007491.e006.jpg" id="pcbi.1007491.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mrow><mml:msub><mml:mi mathvariant="bold-italic">X</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> for <italic>r</italic> = 1, &#x02026;, <italic>R</italic>. The state of each cell is located in a (measurable) space, <inline-formula id="pcbi.1007491.e007"><alternatives><graphic xlink:href="pcbi.1007491.e007.jpg" id="pcbi.1007491.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. We note that this space may not be the full dimension of the data set, but after a dimensionality reduction technique has been applied, e.g., PCA, diffusion maps etc. For example, in the case of RNA-Seq data, the state of a cell would consist of thousands of genes which would be too high to apply kernels to. We wish to find a probability distribution <italic>&#x003f1;</italic> = <italic>&#x003f1;</italic>(<italic>t</italic>, <bold><italic>x</italic></bold>) such that when <italic>t</italic> = <italic>t</italic><sub><italic>r</italic></sub>, the probability of observing cells in states <bold><italic>X</italic></bold><sub><italic>r</italic></sub> would be highly probable for <italic>r</italic> = 1, &#x02026;, <italic>R</italic>.</p><p>Immediately necessary to ensure conservation of mass, we require
<disp-formula id="pcbi.1007491.e008"><alternatives><graphic xlink:href="pcbi.1007491.e008.jpg" id="pcbi.1007491.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mspace width="4.pt"/><mml:mtext>and</mml:mtext><mml:mspace width="4.pt"/><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(3)</label></disp-formula>
for all <italic>t</italic> &#x02208; (<italic>t</italic><sub>1</sub>, <italic>t</italic><sub><italic>R</italic></sub>), i.e., <italic>&#x003f1;</italic> is a probability density function (PDF). We now make the crucial assumption that our method relies on: each cell follows a (well behaved) autonomous dynamical system&#x02014;implicit in this assumption is that cells do not interact, alternatively cell interactions can be accounted for via stochastic noise terms. Under these assumptions, we can interpret <italic>&#x003f1;</italic>(<italic>t</italic>, <bold><italic>x</italic></bold>)&#x00394;<bold><italic>x</italic></bold> as the probability a randomly selected cell has state in the interval [<bold><italic>x</italic></bold>, <bold><italic>x</italic></bold> + &#x00394; <bold><italic>x</italic></bold>) at time <italic>t</italic>. We write down the (continuous-time) Perron&#x02013;Frobenius equation for the dynamics of the density profile as
<disp-formula id="pcbi.1007491.e009"><alternatives><graphic xlink:href="pcbi.1007491.e009.jpg" id="pcbi.1007491.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mfrac><mml:mi>&#x02202;</mml:mi><mml:mrow><mml:mi>&#x02202;</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(4)</label></disp-formula>
for initial condition <italic>&#x003f1;</italic>(<italic>t</italic> = 0, <bold><italic>x</italic></bold>) = <italic>&#x003f1;</italic><sub>0</sub>(<bold><italic>x</italic></bold>). The <inline-formula id="pcbi.1007491.e010"><alternatives><graphic xlink:href="pcbi.1007491.e010.jpg" id="pcbi.1007491.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> term is the continuous-time Perron&#x02013;Frobenius operator [<xref rid="pcbi.1007491.ref021" ref-type="bibr">21</xref>, <xref rid="pcbi.1007491.ref022" ref-type="bibr">22</xref>]. The Perron&#x02013;Frobenius operator associated with a dynamical system maps a density on the state space to another density on the state space. To build intuition for <inline-formula id="pcbi.1007491.e011"><alternatives><graphic xlink:href="pcbi.1007491.e011.jpg" id="pcbi.1007491.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula>, consider a discrete-time Markov chain over a countable number of discrete states <bold><italic>x</italic></bold><sub><italic>r</italic></sub> with recursive relation
<disp-formula id="pcbi.1007491.e012"><alternatives><graphic xlink:href="pcbi.1007491.e012.jpg" id="pcbi.1007491.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mi>s</mml:mi></mml:munder><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo><mml:mspace width="2.em"/><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(5)</label></disp-formula>
where <italic>k</italic><sub>&#x00394;<italic>t</italic></sub>(<bold><italic>x</italic></bold><sub><italic>r</italic></sub>|<bold><italic>x</italic></bold><sub><italic>s</italic></sub>) is a kernel that specifies the probability that state <bold><italic>x</italic></bold><sub><italic>s</italic></sub> is mapped to state <bold><italic>x</italic></bold><sub><italic>r</italic></sub> and therefore &#x02211;<sub><italic>r</italic></sub>
<italic>k</italic><sub>&#x00394;<italic>t</italic></sub>(<bold><italic>x</italic></bold><sub><italic>r</italic></sub>|<bold><italic>x</italic></bold><sub><italic>s</italic></sub>) = 1. Moving from a discrete space to our continuous state space <inline-formula id="pcbi.1007491.e013"><alternatives><graphic xlink:href="pcbi.1007491.e013.jpg" id="pcbi.1007491.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mi mathvariant="script">M</mml:mi></mml:math></alternatives></inline-formula> (by defining and taking limits appropriately), the summation in <xref ref-type="disp-formula" rid="pcbi.1007491.e012">Eq (5)</xref> becomes the integral
<disp-formula id="pcbi.1007491.e014"><alternatives><graphic xlink:href="pcbi.1007491.e014.jpg" id="pcbi.1007491.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mspace width="0.166667em"/><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo><mml:mspace width="2.em"/><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(6)</label></disp-formula></p><p>Returning to <xref ref-type="disp-formula" rid="pcbi.1007491.e009">Eq (4)</xref>, one can exponentiate the operator <inline-formula id="pcbi.1007491.e015"><alternatives><graphic xlink:href="pcbi.1007491.e015.jpg" id="pcbi.1007491.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> and we can thus relate the transition density function <italic>k</italic><sub>&#x00394;<italic>t</italic></sub> in <xref ref-type="disp-formula" rid="pcbi.1007491.e014">Eq (6)</xref> to the operator <inline-formula id="pcbi.1007491.e016"><alternatives><graphic xlink:href="pcbi.1007491.e016.jpg" id="pcbi.1007491.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> via the relation
<disp-formula id="pcbi.1007491.e017"><alternatives><graphic xlink:href="pcbi.1007491.e017.jpg" id="pcbi.1007491.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:msup><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(7)</label></disp-formula></p><p>Therefore, the operator <inline-formula id="pcbi.1007491.e018"><alternatives><graphic xlink:href="pcbi.1007491.e018.jpg" id="pcbi.1007491.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> maps the distribution of states at one time point to a new distribution &#x00394;<italic>t</italic> &#x0003e; 0 units of time later. The operator <inline-formula id="pcbi.1007491.e019"><alternatives><graphic xlink:href="pcbi.1007491.e019.jpg" id="pcbi.1007491.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> is known by many names depending on the underlying dynamical system for the state evolution <inline-formula id="pcbi.1007491.e020"><alternatives><graphic xlink:href="pcbi.1007491.e020.jpg" id="pcbi.1007491.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> for <italic>t</italic> &#x02208; (<italic>t</italic><sub>1</sub>, <italic>t</italic><sub><italic>R</italic></sub>). For example, within SDEs <xref ref-type="disp-formula" rid="pcbi.1007491.e009">Eq (4)</xref> is a second order parabolic PDE known as the Fokker&#x02013;Planck equation [<xref rid="pcbi.1007491.ref035" ref-type="bibr">35</xref>]; and for chemical reaction networks <xref ref-type="disp-formula" rid="pcbi.1007491.e009">Eq (4)</xref> is a system of coupled ODEs known as the chemical master equation [<xref rid="pcbi.1007491.ref036" ref-type="bibr">36</xref>].</p></sec><sec id="sec014"><title>Finite dimensional approximation</title><p>We would like to find a finite dimensional approximation of of <inline-formula id="pcbi.1007491.e021"><alternatives><graphic xlink:href="pcbi.1007491.e021.jpg" id="pcbi.1007491.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula>; we can do this with non-negative basis functions <bold><italic>&#x003c8;</italic></bold>(<bold><italic>x</italic></bold>) = [<italic>&#x003c8;</italic><sub>1</sub>(<bold><italic>x</italic></bold>), &#x02026;, <italic>&#x003c8;</italic><sub><italic>N</italic></sub>(<bold><italic>x</italic></bold>)]<sup>&#x022ba;</sup>. We take the ansatz that for all <italic>t</italic> &#x02208; (<italic>t</italic><sub>1</sub>, <italic>t</italic><sub><italic>R</italic></sub>), we can expand <italic>&#x003f1;</italic> as the linear combination
<disp-formula id="pcbi.1007491.e022"><alternatives><graphic xlink:href="pcbi.1007491.e022.jpg" id="pcbi.1007491.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(8)</label></disp-formula>
where <bold><italic>c</italic></bold>(<italic>t</italic>) = [<italic>c</italic><sub>1</sub>(<italic>t</italic>), &#x02026;, <italic>c</italic><sub><italic>N</italic></sub>(<italic>t</italic>)]<sup>&#x022ba;</sup> and we use a tilde (&#x0223c;) over <italic>&#x003f1;</italic> to denote this approximation. <xref ref-type="disp-formula" rid="pcbi.1007491.e022">Eq (8)</xref> is sometimes known as a Galerkin approximation and is one of the key steps in deriving finite element method numerical schemes to solve partial differential equations. To ensure the probability density integrates to one, we require <bold><italic>c</italic></bold> &#x02208; &#x0039b; where
<disp-formula id="pcbi.1007491.e023"><alternatives><graphic xlink:href="pcbi.1007491.e023.jpg" id="pcbi.1007491.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>&#x0039b;</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mi>N</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:msup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>&#x003c9;</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.166667em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.166667em"/><mml:msup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo><mml:mspace width="1.em"/><mml:mtext>for</mml:mtext><mml:mspace width="1.em"/><mml:mi mathvariant="bold-italic">&#x003c9;</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mspace width="1.em"/><mml:mtext>and</mml:mtext><mml:mspace width="1.em"/><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(9)</label></disp-formula></p><p>If the basis functions are themselves probability density functions, then &#x0039b; is the probability simplex. In <xref ref-type="fig" rid="pcbi.1007491.g001">Fig 1(a)</xref>, we show how a distribution can be represented as a sum of normal distributions, that is, the density is given by a Gaussian mixture model.</p><p>We can derive a linear system of ODEs for the coefficients <bold><italic>c</italic></bold>(<italic>t</italic>). We do this by noting in weak form [<xref rid="pcbi.1007491.ref037" ref-type="bibr">37</xref>, <xref rid="pcbi.1007491.ref038" ref-type="bibr">38</xref>] <xref ref-type="disp-formula" rid="pcbi.1007491.e009">Eq (4)</xref> is
<disp-formula id="pcbi.1007491.e024"><alternatives><graphic xlink:href="pcbi.1007491.e024.jpg" id="pcbi.1007491.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x027e8;</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x002d9;</mml:mo></mml:mover><mml:mo>&#x027e9;</mml:mo></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>&#x027e8;</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x027e9;</mml:mo></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mspace width="1.em"/><mml:mtext>for</mml:mtext><mml:mspace width="1.em"/><mml:msub><mml:mrow><mml:mo>&#x027e8;</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x027e9;</mml:mo></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mi>g</mml:mi><mml:mi>&#x003f1;</mml:mi><mml:mspace width="0.166667em"/><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(10)</label></disp-formula></p><p>Choosing <italic>g</italic> = <italic>&#x003c8;</italic><sub><italic>i</italic></sub> and expanding <italic>&#x003f1;</italic> as in <xref ref-type="disp-formula" rid="pcbi.1007491.e022">Eq (8)</xref>, then
<disp-formula id="pcbi.1007491.e025"><alternatives><graphic xlink:href="pcbi.1007491.e025.jpg" id="pcbi.1007491.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x002d9;</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>Q</mml:mi><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(11)</label></disp-formula>
where <italic>M</italic><sub><italic>ij</italic></sub> = &#x02329;<italic>&#x003c8;</italic><sub><italic>i</italic></sub>, <italic>&#x003c8;</italic><sub><italic>j</italic></sub>&#x0232a; and <inline-formula id="pcbi.1007491.e026"><alternatives><graphic xlink:href="pcbi.1007491.e026.jpg" id="pcbi.1007491.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mrow><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>&#x02329;</mml:mo><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&#x0232a;</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. Assuming <italic>M</italic> is invertible, define
<disp-formula id="pcbi.1007491.e027"><alternatives><graphic xlink:href="pcbi.1007491.e027.jpg" id="pcbi.1007491.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>P</mml:mi><mml:mo>&#x02254;</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>Q</mml:mi><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(12)</label></disp-formula>
which is the projection of <inline-formula id="pcbi.1007491.e028"><alternatives><graphic xlink:href="pcbi.1007491.e028.jpg" id="pcbi.1007491.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> onto the basis functions {<italic>&#x003c8;</italic><sub>1</sub>, &#x02026;, <italic>&#x003c8;</italic><sub><italic>N</italic></sub>}. That is, for <italic>g</italic>(<bold><italic>x</italic></bold>) = <bold><italic>c</italic></bold><sup>&#x022ba;</sup><italic>&#x003c8;</italic>(<bold><italic>x</italic></bold>), we have the equality <inline-formula id="pcbi.1007491.e029"><alternatives><graphic xlink:href="pcbi.1007491.e029.jpg" id="pcbi.1007491.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. In order to preserve probability density and positivity, we require <inline-formula id="pcbi.1007491.e030"><alternatives><graphic xlink:href="pcbi.1007491.e030.jpg" id="pcbi.1007491.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:mrow><mml:mi>P</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> for
<disp-formula id="pcbi.1007491.e031"><alternatives><graphic xlink:href="pcbi.1007491.e031.jpg" id="pcbi.1007491.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>&#x000d7;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mspace width="0.166667em"/><mml:mspace width="4.pt"/><mml:mtext>and</mml:mtext><mml:mspace width="4.pt"/><mml:mspace width="0.166667em"/><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mspace width="4.pt"/><mml:mtext>for</mml:mtext><mml:mspace width="4.pt"/><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mspace width="4.pt"/><mml:mtext>and</mml:mtext><mml:mspace width="4.pt"/><mml:mi>i</mml:mi><mml:mo>&#x02260;</mml:mo><mml:mi>j</mml:mi><mml:mo>}</mml:mo><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(13)</label></disp-formula></p><p>The explanation behind <xref ref-type="disp-formula" rid="pcbi.1007491.e031">Eq (13)</xref> is contained in the <xref ref-type="supplementary-material" rid="pcbi.1007491.s001">S1 Appendix</xref>.</p><p>We can solve the dynamics for <xref ref-type="disp-formula" rid="pcbi.1007491.e009">Eq (4)</xref> using the approximation in <xref ref-type="disp-formula" rid="pcbi.1007491.e022">Eq (8)</xref> by using the matrix exponential operation, specifically
<disp-formula id="pcbi.1007491.e032"><alternatives><graphic xlink:href="pcbi.1007491.e032.jpg" id="pcbi.1007491.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(14)</label></disp-formula>
where <inline-formula id="pcbi.1007491.e071"><alternatives><graphic xlink:href="pcbi.1007491.e071.jpg" id="pcbi.1007491.e071g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M71"><mml:mrow><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> are the coefficients at corresponding to the chosen initial condition <inline-formula id="pcbi.1007491.e033"><alternatives><graphic xlink:href="pcbi.1007491.e033.jpg" id="pcbi.1007491.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>*</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. To prevent numerical instability for large times, we rescale the experimental time course (<italic>t</italic><sub>1</sub>, <italic>t</italic><sub><italic>R</italic></sub>) to the unit interval.</p></sec><sec id="sec015"><title>Calculation of Galerkin approximation coefficients for PDFs</title><p>There are many option for selecting basis functions, later discussed in the Conclusion. One option is to use probability density functions, so
<disp-formula id="pcbi.1007491.e034"><alternatives><graphic xlink:href="pcbi.1007491.e034.jpg" id="pcbi.1007491.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(15)</label></disp-formula>
for <italic>j</italic> = 1, &#x02026;, <italic>N</italic>. We can find the values of <bold><italic>c</italic></bold><sub><italic>r</italic></sub> at the observed time points by noting that the value of the coefficient at time <italic>t</italic> = <italic>t</italic><sub><italic>r</italic></sub> must be proportional to the probability that basis function <italic>j</italic> created the data at that time point, so
<disp-formula id="pcbi.1007491.e035"><alternatives><graphic xlink:href="pcbi.1007491.e035.jpg" id="pcbi.1007491.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x0221d;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:munderover><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(16)</label></disp-formula></p><p>One can then normalise <inline-formula id="pcbi.1007491.e036"><alternatives><graphic xlink:href="pcbi.1007491.e036.jpg" id="pcbi.1007491.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> for <italic>j</italic> = 1, &#x02026;, <italic>N</italic> to find the coeffient vector <bold><italic>c</italic></bold><sub><italic>r</italic></sub>.</p><p>It is worth remarking here that entries in the coefficient vectors <inline-formula id="pcbi.1007491.e037"><alternatives><graphic xlink:href="pcbi.1007491.e037.jpg" id="pcbi.1007491.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> may change should the data be perturbed. Additionally, depending on the choice in basis functions, the basis functions <inline-formula id="pcbi.1007491.e038"><alternatives><graphic xlink:href="pcbi.1007491.e038.jpg" id="pcbi.1007491.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula>
<italic>may</italic> depend on the data, e.g., when the placement of the Gaussians basis functions is done via the expectation maximisation algorithm for Gaussian mixture models. In the event that one uses global basis functions, e.g., orthogonal polynomials, the basis are chosen independent of the data, and therefore perturbations to the data would only affect <inline-formula id="pcbi.1007491.e039"><alternatives><graphic xlink:href="pcbi.1007491.e039.jpg" id="pcbi.1007491.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> but not the form of the basis functions themselves.</p></sec><sec id="sec016"><title>Selection of <italic>P</italic> matrix</title><p>We now need to address the issue of how to determine <italic>P</italic> from data. We now motivate a choice in error to minimise, generally analogous to least squares fitting error for ODEs.</p><p>We are interested in how an initial state goes on to predict later recorded states. We do not use the first calculated coefficient, <bold><italic>c</italic></bold><sub>1</sub>, as the initial condition, but allow for mis-specification of the initial condition by specifying that it is a free parameter to the model. The initial condition is given as density <inline-formula id="pcbi.1007491.e040"><alternatives><graphic xlink:href="pcbi.1007491.e040.jpg" id="pcbi.1007491.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mrow><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> with Galerkin approximation
<disp-formula id="pcbi.1007491.e041"><alternatives><graphic xlink:href="pcbi.1007491.e041.jpg" id="pcbi.1007491.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>*</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(17)</label></disp-formula></p><p>Consider a linear operator <inline-formula id="pcbi.1007491.e042"><alternatives><graphic xlink:href="pcbi.1007491.e042.jpg" id="pcbi.1007491.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> with matrix representation <italic>P</italic> on the space spanned by <bold><italic>&#x003c8;</italic></bold>. The <italic>L</italic><sup>2</sup> norm gives a measure of how well <inline-formula id="pcbi.1007491.e043"><alternatives><graphic xlink:href="pcbi.1007491.e043.jpg" id="pcbi.1007491.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mi mathvariant="script">P</mml:mi></mml:math></alternatives></inline-formula> represents the evolution of the densities. The squared relative prediction error at time <italic>t</italic> = <italic>t</italic><sub><italic>r</italic></sub> for <italic>r</italic> = 1, &#x02026;, <italic>R</italic> is
<disp-formula id="pcbi.1007491.e044"><alternatives><graphic xlink:href="pcbi.1007491.e044.jpg" id="pcbi.1007491.e044g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M44"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>&#x003f5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>&#x02254;</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x000b7;</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000b7;</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo><mml:mi>&#x003f1;</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000b7;</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:mi>&#x003f1;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mi>&#x003f1;</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo><mml:mo>]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mtext>d</mml:mtext><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow></mml:mfrac><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(18)</label></disp-formula></p><p>Notice in <xref ref-type="disp-formula" rid="pcbi.1007491.e044">Eq (18)</xref> that the error is a function of both the Perron&#x02013;Frobenius operator and the initial condition. We then define the mean squared relative prediction error as
<disp-formula id="pcbi.1007491.e045"><alternatives><graphic xlink:href="pcbi.1007491.e045.jpg" id="pcbi.1007491.e045g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M45"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>&#x003f5;</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>R</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:munderover><mml:msubsup><mml:mi>&#x003f5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(19)</label></disp-formula></p><p>It would be ideal now to find
<disp-formula id="pcbi.1007491.e046"><alternatives><graphic xlink:href="pcbi.1007491.e046.jpg" id="pcbi.1007491.e046g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M46"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x02254;</mml:mo><mml:munder><mml:mo form="prefix">arg min</mml:mo><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.166667em"/><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msup></mml:mrow></mml:munder><mml:msup><mml:mi>&#x003f5;</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">arg min</mml:mo><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.166667em"/><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msup></mml:mrow></mml:munder><mml:mfrac><mml:mn>1</mml:mn><mml:mi>R</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:munderover><mml:msubsup><mml:mi>&#x003f5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(20)</label></disp-formula></p><p>Of course, we do not know what this error is without using our finite dimensional Galerkin approximation; therefore we approximate
<disp-formula id="pcbi.1007491.e047"><alternatives><graphic xlink:href="pcbi.1007491.e047.jpg" id="pcbi.1007491.e047g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M47"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>&#x003f5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mover><mml:mo>&#x02248;</mml:mo><mml:mrow><mml:mtext>Eqs.</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>(</mml:mtext><mml:mn>8</mml:mn><mml:mtext>,</mml:mtext><mml:mspace width="4.pt"/><mml:mn>17</mml:mn><mml:mtext>)</mml:mtext><mml:mspace width="4.pt"/></mml:mrow></mml:mover><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(21)</label></disp-formula>
and we calculate the time <italic>t</italic> = <italic>t</italic><sub><italic>r</italic></sub> error as
<disp-formula id="pcbi.1007491.e048"><alternatives><graphic xlink:href="pcbi.1007491.e048.jpg" id="pcbi.1007491.e048g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M48"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02254;</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x000b7;</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:msubsup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:msubsup><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>M</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(22)</label></disp-formula>
where we introduced the norm weighted by the mass matrix <inline-formula id="pcbi.1007491.e049"><alternatives><graphic xlink:href="pcbi.1007491.e049.jpg" id="pcbi.1007491.e049g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M49"><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02225;</mml:mo><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>&#x02254;</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>M</mml:mi><mml:mi mathvariant="bold-italic">c</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>. Our objective function is modified by using this finite dimensional approximation to
<disp-formula id="pcbi.1007491.e050"><alternatives><graphic xlink:href="pcbi.1007491.e050.jpg" id="pcbi.1007491.e050g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M50"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x02254;</mml:mo><mml:munder><mml:mo form="prefix">arg min</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.166667em"/><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mo>&#x0039b;</mml:mo></mml:mrow></mml:munder><mml:msup><mml:mi>&#x003b5;</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">arg min</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.166667em"/><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mo>&#x0039b;</mml:mo></mml:mrow></mml:munder><mml:mfrac><mml:mn>1</mml:mn><mml:mi>R</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:munderover><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(23)</label></disp-formula></p><p><bold>Algorithm 1</bold> Algorithm to Determine Perron-Frobenius Matrix</p><p specific-use="line"><bold>Require</bold>: Data <inline-formula id="pcbi.1007491.e051"><alternatives><graphic xlink:href="pcbi.1007491.e051.jpg" id="pcbi.1007491.e051g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M51"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">X</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and observation times <inline-formula id="pcbi.1007491.e068"><alternatives><graphic xlink:href="pcbi.1007491.e068.jpg" id="pcbi.1007491.e068g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M68"><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>R</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.</p><p specific-use="line"><bold>Require</bold>: Choose basis functions <inline-formula id="pcbi.1007491.e069"><alternatives><graphic xlink:href="pcbi.1007491.e069.jpg" id="pcbi.1007491.e069g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M69"><mml:mi mathvariant="bold-italic">&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>&#x022ba;</mml:mo></mml:msup></mml:math></alternatives></inline-formula>.</p><p specific-use="line">1: Solve
<disp-formula id="pcbi.1007491.e052"><alternatives><graphic xlink:href="pcbi.1007491.e052.jpg" id="pcbi.1007491.e052g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M52"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x02254;</mml:mo><mml:munder><mml:mo form="prefix">arg min</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mo>&#x0039b;</mml:mo></mml:mrow></mml:munder><mml:mfrac><mml:mn>1</mml:mn><mml:mi>R</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:munderover><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p><p specific-use="line">2: <bold>return</bold>
<inline-formula id="pcbi.1007491.e070"><alternatives><graphic xlink:href="pcbi.1007491.e070.jpg" id="pcbi.1007491.e070g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M70"><mml:mi>P</mml:mi></mml:math></alternatives></inline-formula></p><p>Unmentioned at this point is that: for a large quantity of basis functions the size over which this optimisation problem occurs is challenging. That is: one has <italic>N</italic><sup>2</sup> free elements in the matrix <italic>P</italic>, with zero column sums one has <italic>N</italic>(<italic>N</italic> &#x02212; 1) degrees of freedom; but one also has the initial condition to choose adding <italic>N</italic> parameters, or <italic>N</italic> &#x02212; 1 degrees of freedom (with unit column sum)&#x02014;in total (<italic>N</italic> &#x02212; 1)(<italic>N</italic> + 1) degrees of freedom. Therefore, the problem is unapproachable without gradient calculations to speed up the optimization algorithm. Using the exponential matrix derivative (see <xref ref-type="supplementary-material" rid="pcbi.1007491.s001">S1 Appendix</xref>), one can calculate the <italic>t</italic> = <italic>t</italic><sub><italic>r</italic></sub> relative error with respect to <italic>P</italic> as
<disp-formula id="pcbi.1007491.e053"><alternatives><graphic xlink:href="pcbi.1007491.e053.jpg" id="pcbi.1007491.e053g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M53"><mml:mfrac><mml:mrow><mml:mi>&#x02202;</mml:mi><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mi>&#x02202;</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>M</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>&#x0221e;</mml:mi></mml:munderover><mml:mfrac><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>!</mml:mo></mml:mrow></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>*</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mi>j</mml:mi></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup></mml:mrow></mml:math></alternatives><label>(24)</label></disp-formula>
<disp-formula id="pcbi.1007491.e054"><alternatives><graphic xlink:href="pcbi.1007491.e054.jpg" id="pcbi.1007491.e054g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M54"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>M</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>&#x0221e;</mml:mi></mml:munderover><mml:mfrac><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>!</mml:mo></mml:mrow></mml:mfrac><mml:msub><mml:mi>S</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(25)</label></disp-formula>
and the derivative with respect to <bold><italic>c</italic></bold><sub>*</sub> as
<disp-formula id="pcbi.1007491.e055"><alternatives><graphic xlink:href="pcbi.1007491.e055.jpg" id="pcbi.1007491.e055g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M55"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>&#x02202;</mml:mi><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mi>&#x02202;</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>M</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:mo>]</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(26)</label></disp-formula></p><p>The terms
<disp-formula id="pcbi.1007491.e056"><alternatives><graphic xlink:href="pcbi.1007491.e056.jpg" id="pcbi.1007491.e056g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M56"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>*</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mi>j</mml:mi></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mspace width="0.166667em"/></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(27)</label></disp-formula>
can be calculated using the recursion relation
<disp-formula id="pcbi.1007491.e057"><alternatives><graphic xlink:href="pcbi.1007491.e057.jpg" id="pcbi.1007491.e057g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M57"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mi>P</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mo>-</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mi>P</mml:mi><mml:mo>&#x022ba;</mml:mo></mml:msup><mml:mspace width="1.em"/><mml:mtext>where</mml:mtext><mml:mspace width="1.em"/><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn mathvariant="bold">0</mml:mn><mml:mspace width="1.em"/><mml:mtext>and</mml:mtext><mml:mspace width="1.em"/><mml:msub><mml:mi>S</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mrow><mml:mo>*</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(28)</label></disp-formula></p><sec id="sec017"><title>Lasso regularisation</title><p>For display purposes, we can promote sparsity in <italic>P</italic> by using a Lasso regularisation. We choose the regularisation parameter such that there is at least a single edge connected to the extrema of the first few eigenfunctions. We modify the error term in <xref ref-type="disp-formula" rid="pcbi.1007491.e050">Eq (23)</xref> to
<disp-formula id="pcbi.1007491.e058"><alternatives><graphic xlink:href="pcbi.1007491.e058.jpg" id="pcbi.1007491.e058g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M58"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mrow><mml:mo>&#x02020;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>R</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:munderover><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mi>&#x003b2;</mml:mi><mml:mo>&#x02225;</mml:mo><mml:mtext>vec</mml:mtext></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>&#x025cb;</mml:mo><mml:mi>P</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>R</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>R</mml:mi></mml:munderover><mml:msubsup><mml:mi>&#x003b5;</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>*</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>&#x003b2;</mml:mi><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(29)</label></disp-formula>
where &#x025cb; denotes the Hadamard product (or entrywise product) and vec(&#x022c5;) denotes the vectorisation of a matrix. In the case where the basis functions are probability density functions, we can calculate the derivative of this expression as
<disp-formula id="pcbi.1007491.e059"><alternatives><graphic xlink:href="pcbi.1007491.e059.jpg" id="pcbi.1007491.e059g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M59"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mfrac><mml:mi>&#x02202;</mml:mi><mml:mrow><mml:mi>&#x02202;</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mfrac><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mo>&#x02225;</mml:mo><mml:mtext>vec</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>&#x025cb;</mml:mo><mml:mi>P</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="right"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="right"><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd columnalign="right"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="right"><mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd/><mml:mtd columnalign="right"><mml:mo>&#x022ee;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mo>&#x022ee;</mml:mo></mml:mtd><mml:mtd/><mml:mtd columnalign="right"><mml:mo>&#x022f1;</mml:mo></mml:mtd><mml:mtd/></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="right"><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd/><mml:mtd columnalign="right"><mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(30)</label></disp-formula></p><p>By using the mass matrix <italic>M</italic> as a weighting in front of the Perron&#x02013;Frobenius matrix <italic>P</italic>, we are promoting edges between basis functions located apart from each other.</p></sec></sec><sec id="sec018"><title>Graph visualisations</title><sec id="sec019"><title><italic>P</italic> matrix visualisations</title><p>One can interpret the matrix <italic>P</italic> as a Markov transition rate matrix, in which case the entry <italic>P</italic><sub><italic>i</italic>,<italic>j</italic></sub> shows the rate at which state <italic>j</italic> transitions into state <italic>i</italic>. Therefore, a cell in cluster <italic>i</italic> will switch to cluster <italic>j</italic> in time interval [<italic>t</italic>, <italic>t</italic> + &#x00394;<italic>t</italic>) for &#x00394;<italic>t</italic> &#x0003e; 0 with probability <inline-formula id="pcbi.1007491.e060"><alternatives><graphic xlink:href="pcbi.1007491.e060.jpg" id="pcbi.1007491.e060g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M60"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&#x00394;</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. To reiterate, cells exist in states between the basis functions so instead of being at a single state, they are in a state which is a weighted combination of the basis functions. However, this interpretation allows us to plot a directed network with weighted adjacency matrix <italic>P</italic><sub><italic>i</italic>,<italic>j</italic></sub>. Nodes can then be placed using one of a multitude of algorithms, in our case we use force-directed node placement with weights inversely proportional to the mass matrix <italic>M</italic>. Visualisations of the mass matrices associated to the problems in this manuscript are contained in the <xref ref-type="supplementary-material" rid="pcbi.1007491.s002">S2 Appendix</xref>. We also plot the size of node <italic>i</italic> proportional to <italic>P</italic><sub><italic>i</italic>,<italic>i</italic></sub> (as this is the rate at which state <italic>i</italic> remains in state <italic>i</italic>).</p></sec><sec id="sec020"><title>Eigenfunction visualisation</title><p>To investigate key dynamical behaviours of a linear operator, a common theme is the study of the corresponding eigenproblem. By solving the eigenproblem, one can decompose the solution of the operator into components (known as eigenfunctions or eigenvectors) that will dynamically change with respect to the eigenvalue. By studying the eigenproblem, one can break down the solution into key behaviours and find important transitionary states.</p><p>For an eigenfunction satisfying
<disp-formula id="pcbi.1007491.e061"><alternatives><graphic xlink:href="pcbi.1007491.e061.jpg" id="pcbi.1007491.e061g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M61"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x003bb;</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(31)</label></disp-formula>
using the finite dimensional Galerkin approximation in <xref ref-type="disp-formula" rid="pcbi.1007491.e022">Eq (8)</xref>, there is the corresponding eigenvector
<disp-formula id="pcbi.1007491.e062"><alternatives><graphic xlink:href="pcbi.1007491.e062.jpg" id="pcbi.1007491.e062g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M62"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x003bb;</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(32)</label></disp-formula></p><p>In low dimensions, one can simply plot the original function <italic>&#x003f1;</italic><sub>&#x003bb;</sub> as the linear combination of basis functions
<disp-formula id="pcbi.1007491.e063"><alternatives><graphic xlink:href="pcbi.1007491.e063.jpg" id="pcbi.1007491.e063g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M63"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mrow><mml:mo>&#x003bb;</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mo>&#x003bb;</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(33)</label></disp-formula></p><p>To ensure consistent scales when plotting, we demand
<disp-formula id="pcbi.1007491.e064"><alternatives><graphic xlink:href="pcbi.1007491.e064.jpg" id="pcbi.1007491.e064g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M64"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:msub><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>&#x027e8;</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>&#x027e9;</mml:mo></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.166667em"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(34)</label></disp-formula>
or when considering the finite dimensional Galerkin approximation
<disp-formula id="pcbi.1007491.e065"><alternatives><graphic xlink:href="pcbi.1007491.e065.jpg" id="pcbi.1007491.e065g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M65"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003f1;</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:msub><mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:msub><mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mrow><mml:mo>&#x003bb;</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:msub><mml:mrow><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x000b7;</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>&#x02225;</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>&#x02225;</mml:mo></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>&#x027e8;</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>&#x027e9;</mml:mo></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mrow><mml:mo>&#x003bb;</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:mi>M</mml:mi><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>&#x027e8;</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>&#x027e9;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(35)</label></disp-formula></p><p>In high dimensions, our ability to visualise functions is limited. However, we have represented the function as a linear combination of basis functions; one option for visualisation purposes is to present the coefficients in the eigenvector. To visualise if the eigenvector values have similar or dissimilar values, we can consider representing the eigenfunction as a graph. We specify the adjacency matrix for an undirected weighted graph as the outer product
<disp-formula id="pcbi.1007491.e066"><alternatives><graphic xlink:href="pcbi.1007491.e066.jpg" id="pcbi.1007491.e066g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M66"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02297;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup><mml:msub><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>&#x003bb;</mml:mo></mml:msub><mml:msubsup><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mrow><mml:mo>&#x003bb;</mml:mo></mml:mrow><mml:mo>&#x022ba;</mml:mo></mml:msubsup><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup><mml:mspace width="0.166667em"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(36)</label></disp-formula></p><p>For Perron&#x02013;Frobenius eigenfunctions with eigenvalue &#x003bb; &#x02260; 0, the function will obtain both a positive and negative values (indicating where probability mass is flowing from and to). Therefore, by examining <italic>G</italic><sub>&#x003bb;</sub>, a positive value in entry (<italic>i</italic>, <italic>j</italic>) in <italic>G</italic><sub>&#x003bb;</sub> indicates basis functions <italic>i</italic> and <italic>j</italic> both have the same sign (positive or negative) and a negative value indicates they have opposite signs. By plotting edges as straight lines with thickness proportional to the values in <italic>G</italic><sub>&#x003bb;</sub>, we can visualise pairs of nodes (positioned in high dimensional space) and show an approximate gradients in between these nodes. When entries of <italic>G</italic><sub>&#x003bb;</sub> are small, then only very thin lines will be plotted between nodes, indicating the lack of connection between these areas in state space.</p><p>By using the weighting of <inline-formula id="pcbi.1007491.e067"><alternatives><graphic xlink:href="pcbi.1007491.e067.jpg" id="pcbi.1007491.e067g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M67"><mml:msup><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:msup></mml:math></alternatives></inline-formula> in front of the eigenvector <bold><italic>v</italic></bold><sub>&#x003bb;</sub> we ensure that the sizes of the eigenvectors are bounded. Occasionally it is the case that we get complex eigenvalues, in which case they appear as complex conjugates and one can plot the real and imaginary parts separately.</p></sec></sec><sec id="sec021"><title>Conclusion</title><p>We presented Dynamic Distribution Decomposition for identification of dynamically important states of biological processes. This method operates on snapshot time series data and infers dynamically important states by mapping between distributions. By fitting a very general autonomous dynamical system over basis functions encoding the observed raw dataset, one is able to obtain fitting error estimates indicating said level of autonomy within the dataset. We applied our approach to synthetic data generated for a simple test system, and then further to a mass cytometry time series data set for iPSC reprogramming. Our approach performed well for both systems showing key dynamical states. For the experimental system of iPSC reprogramming of fibroblasts, we could also identify key time points (with large fitting error) where the current experimental (or computational) set-up is insufficient to elucidate the reprogramming process. This suggests one of several reasons, either 1.) limitations of the model: non-autonomy (e.g., delayed models more appropriate, cell interactions important), poor selection of basis functions; or 2.) limitations of the data: selection of uninformative measured genes/proteins, or measurement error. Due to our careful approach in selecting basis functions, we believe further experimental investigation is warranted.</p><p>DDD can be computed efficiently, e.g., via the recursion relation given by <xref ref-type="disp-formula" rid="pcbi.1007491.e057">Eq (28)</xref>, but we have not optimised the implementation. In the case where there is more than 100 basis functions, our minimisation procedure using the inbuilt MATLAB multivariate minimisation algorithm can be unreasonably slow; therefore, we will investigate more efficient implementations.</p><p>DDD depends on a few design decisions, such as the choice of basis functions. In this manuscript, we used basis functions as components of a Gaussian mixture model and gave parameters that needed tuning to alter the fit. Our method for choosing basis functions does not have an optimal configuration with regards to minimising error. This is because by sending the regularisation value to infinity one obtains perfect fits, and sending the regularisation value to zero can lead to ill fitting solution (basis functions with same mean etc). However, one can use the <italic>&#x003b1;</italic> parameter as a rule of thumb to ensure enough basis functions are included. For other applications other choices in basis functions are conceivable, for example, radial basis functions [<xref rid="pcbi.1007491.ref039" ref-type="bibr">39</xref>]; piecewise linear basis functions [<xref rid="pcbi.1007491.ref040" ref-type="bibr">40</xref>]; and global basis functions [<xref rid="pcbi.1007491.ref021" ref-type="bibr">21</xref>, <xref rid="pcbi.1007491.ref027" ref-type="bibr">27</xref>] to name a few. When the basis functions have finite support, the mass matrix <italic>M</italic> will be sparse, in which case the Lasso step will not be necessary. It is worth noting that calculation of the mass matrix analytically is only possible in a few cases and Monte&#x02013;Carlo integration may be necessary&#x02014;which would add an additional source of error to the methodology. Practically, it would also make sense to use basis functions built around the data type, for example negative binomial distributions are often used to model UMI counts from single-cell RNA-Seq data. When one uses a single basis function centred around each data point, one refers to this as kernel density estimation, of which there are optimal methods to choose the basis function [<xref rid="pcbi.1007491.ref041" ref-type="bibr">41</xref>]; when using a small number of basis functions for a large number of sample points, there are likely optimal ways of choosing them which we will investigate in future work.</p><p>DDD could be applied to investigate pseudotime ordered single-cell data of single time point experiments, see [<xref rid="pcbi.1007491.ref042" ref-type="bibr">42</xref>, <xref rid="pcbi.1007491.ref043" ref-type="bibr">43</xref>] and <xref ref-type="supplementary-material" rid="pcbi.1007491.s003">S3 Appendix</xref>. Here, one uses single-cell data measured at only a single time point to carry out trajectory inference and subpopulation identification to infer biological processes, e.g., the cell cycle; reviews of such methods can be found in Ref. [<xref rid="pcbi.1007491.ref044" ref-type="bibr">44</xref>, <xref rid="pcbi.1007491.ref045" ref-type="bibr">45</xref>]. It may be possible to improve our fits by combining approaches: while cells are monitored with regards to experimental time, individual cell time coordinates might deviate due to asychronity of process initiation; this could be incorporated to get smoother Perron&#x02013;Frobenius operators between time points, see Ref. [<xref rid="pcbi.1007491.ref046" ref-type="bibr">46</xref>]. This would then be a biologically motivated method to account for delays in the system.</p><p>DDD is applicable to evaluate the outcome of reconstruction approaches yielding potential functions. An example of such an approach is reported by Hashimoto et. al. [<xref rid="pcbi.1007491.ref047" ref-type="bibr">47</xref>], where hypothesised potential function is reconstructed under the following assumptions: <italic>i.)</italic> the data was generated by SDEs in the potential well; and <italic>ii.)</italic> the gradient of the potential is a single layer of a sigmoid neural network. Our reported eigen-decompositions is applicable to identify dynamically important states for the inferred potential function.</p><p>The work presents Dynamic Distribution Decomposition, linking advances in operator theory to applied practice in high-dimensional data analysis. While we focus on application of DDD to mass cytometry measurements, it is conceivable to expand to applications to single-cell RNA sequencing time series as well as biological processes other than an iPSC reprogramming. We expect DDD and method variations will be instrumental in providing intuitive understanding of such biological processes.</p></sec></sec><sec sec-type="supplementary-material" id="sec022"><title>Supporting information</title><supplementary-material content-type="local-data" id="pcbi.1007491.s001"><label>S1 Appendix</label><caption><title>Additional mathematical details.</title><p>A document detailing the additional mathematical details regarding: the inner products between multivariate normal distributions; requirements on the Perron&#x02013;Frobenius matrix approximation; a full derivation of the gradient calculation; and additional evidence regarding detection of non-autonomy.</p><p>(PDF)</p></caption><media xlink:href="pcbi.1007491.s001.pdf"><caption><p>Click here for additional data file.</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="pcbi.1007491.s002"><label>S2 Appendix</label><caption><title>Additional figures.</title><p>A document containing two additional figures: protein expression of Nanog-Neo cell line data taken from Zunder <italic>et. al</italic>.; and plots containing visualisations of the coefficient vectors <bold><italic>c</italic></bold><sub><italic>r</italic></sub> and mass matrix <italic>M</italic> for both the the stochastic dynamical system and Nanog-Neo cell line data.</p><p>(PDF)</p></caption><media xlink:href="pcbi.1007491.s002.pdf"><caption><p>Click here for additional data file.</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="pcbi.1007491.s003"><label>S3 Appendix</label><caption><title>Comparison with other established methods.</title><p>A document detailing a brief comparison between our method and 3 other published methods: W<sc>ishbone</sc> [<xref rid="pcbi.1007491.ref042" ref-type="bibr">42</xref>], M<sc>onocle</sc>2 [<xref rid="pcbi.1007491.ref043" ref-type="bibr">43</xref>], and W<sc>addington</sc>-OT [<xref rid="pcbi.1007491.ref006" ref-type="bibr">6</xref>].</p><p>(PDF)</p></caption><media xlink:href="pcbi.1007491.s003.pdf"><caption><p>Click here for additional data file.</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="pcbi.1007491.s004"><label>S4 Appendix</label><caption><title>Reconstruction of EGFR signalling from mass cytometry time series data.</title><p>A document detailing DDD applied to an additional control dataset with known underlying cellular behaviour, see Lun <italic>et. al</italic>. [<xref rid="pcbi.1007491.ref032" ref-type="bibr">32</xref>].</p><p>(PDF)</p></caption><media xlink:href="pcbi.1007491.s004.pdf"><caption><p>Click here for additional data file.</p></caption></media></supplementary-material></sec></body><back><ack><p>We gratefully acknowledge the support of Anna Klimovskaia, Ioana Sandu, Dario Cerletti, and Eli Zunder.</p></ack><ref-list><title>References</title><ref id="pcbi.1007491.ref001"><label>1</label><mixed-citation publication-type="journal">
<name><surname>Ziegenhain</surname><given-names>C</given-names></name>, <name><surname>Vieth</surname><given-names>B</given-names></name>, <name><surname>Parekh</surname><given-names>S</given-names></name>, <name><surname>Reinius</surname><given-names>B</given-names></name>, <name><surname>Guillaumet-Adkins</surname><given-names>A</given-names></name>, <name><surname>Smets</surname><given-names>M</given-names></name>, <etal>et al</etal>
<article-title>Comparative analysis of single-cell RNA sequencing methods</article-title>. <source>Molecular cell</source>. <year>2017</year>;<volume>65</volume>(<issue>4</issue>):<fpage>631</fpage>&#x02013;<lpage>643</lpage>. <pub-id pub-id-type="doi">10.1016/j.molcel.2017.01.023</pub-id>
<pub-id pub-id-type="pmid">28212749</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref002"><label>2</label><mixed-citation publication-type="journal">
<name><surname>Spitzer</surname><given-names>MH</given-names></name>, <name><surname>Nolan</surname><given-names>GP</given-names></name>. <article-title>Mass cytometry: single cells, many features</article-title>. <source>Cell</source>. <year>2016</year>;<volume>165</volume>(<issue>4</issue>):<fpage>780</fpage>&#x02013;<lpage>791</lpage>. <pub-id pub-id-type="doi">10.1016/j.cell.2016.04.019</pub-id>
<pub-id pub-id-type="pmid">27153492</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref003"><label>3</label><mixed-citation publication-type="journal">
<name><surname>Zechner</surname><given-names>C</given-names></name>, <name><surname>Ruess</surname><given-names>J</given-names></name>, <name><surname>Krenn</surname><given-names>P</given-names></name>, <name><surname>Pelet</surname><given-names>S</given-names></name>, <name><surname>Peter</surname><given-names>M</given-names></name>, <name><surname>Lygeros</surname><given-names>J</given-names></name>, <etal>et al</etal>
<article-title>Moment-based inference predicts bimodality in transient gene expression</article-title>. <source>Proceedings of the National Academy of Sciences</source>. <year>2012</year>;<volume>109</volume>(<issue>21</issue>):<fpage>8340</fpage>&#x02013;<lpage>8345</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.1200161109</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref004"><label>4</label><mixed-citation publication-type="journal">
<name><surname>Klimovskaia</surname><given-names>A</given-names></name>, <name><surname>Ganscha</surname><given-names>S</given-names></name>, <name><surname>Claassen</surname><given-names>M</given-names></name>. <article-title>Sparse regression based structure learning of stochastic reaction networks from single cell snapshot time series</article-title>. <source>PLoS computational biology</source>. <year>2016</year>;<volume>12</volume>(<issue>12</issue>):<fpage>e1005234</fpage>
<pub-id pub-id-type="doi">10.1371/journal.pcbi.1005234</pub-id>
<pub-id pub-id-type="pmid">27923064</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref005"><label>5</label><mixed-citation publication-type="other">Pantazis Y, Tsamardinos I. A Unified Approach for Sparse Dynamical System Inference from Temporal Measurements. arXiv preprint arXiv:171000718. 2017;.</mixed-citation></ref><ref id="pcbi.1007491.ref006"><label>6</label><mixed-citation publication-type="journal">
<name><surname>Schiebinger</surname><given-names>G</given-names></name>, <name><surname>Shu</surname><given-names>J</given-names></name>, <name><surname>Tabaka</surname><given-names>M</given-names></name>, <name><surname>Cleary</surname><given-names>B</given-names></name>, <name><surname>Subramanian</surname><given-names>V</given-names></name>, <name><surname>Solomon</surname><given-names>A</given-names></name>, <etal>et al</etal>
<article-title>Reconstruction of developmental landscapes by optimal-transport analysis of single-cell gene expression sheds light on cellular reprogramming</article-title>. <source>bioRxiv</source>. <year>2017</year>;.</mixed-citation></ref><ref id="pcbi.1007491.ref007"><label>7</label><mixed-citation publication-type="journal">
<name><surname>Gillespie</surname><given-names>DT</given-names></name>. <article-title>Stochastic simulation of chemical kinetics</article-title>. <source>Annu Rev Phys Chem</source>. <year>2007</year>;<volume>58</volume>:<fpage>35</fpage>&#x02013;<lpage>55</lpage>. <pub-id pub-id-type="doi">10.1146/annurev.physchem.58.032806.104637</pub-id>
<pub-id pub-id-type="pmid">17037977</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref008"><label>8</label><mixed-citation publication-type="journal">
<name><surname>Aldridge</surname><given-names>BB</given-names></name>, <name><surname>Burke</surname><given-names>JM</given-names></name>, <name><surname>Lauffenburger</surname><given-names>DA</given-names></name>, <name><surname>Sorger</surname><given-names>PK</given-names></name>. <article-title>Physicochemical modelling of cell signalling pathways</article-title>. <source>Nature cell biology</source>. <year>2006</year>;<volume>8</volume>(<issue>11</issue>):<fpage>1195</fpage>
<pub-id pub-id-type="doi">10.1038/ncb1497</pub-id>
<pub-id pub-id-type="pmid">17060902</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref009"><label>9</label><mixed-citation publication-type="book">
<name><surname>Ulam</surname><given-names>S</given-names></name>. <chapter-title>A collection of Mathematical Problems</chapter-title>
<volume>vol. 8</volume> of <source>Interscience tracts in pure and applied mathematics</source>. <publisher-name>Interscience Publishers Inc.</publisher-name>; <year>1960</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref010"><label>10</label><mixed-citation publication-type="book">
<name><surname>Lasota</surname><given-names>A</given-names></name>, <name><surname>Mackey</surname><given-names>MC</given-names></name>. <source>Probabilistic properties of deterministic systems</source>. <publisher-name>Cambridge University Press</publisher-name>; <year>1985</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref011"><label>11</label><mixed-citation publication-type="journal">
<name><surname>Fokker</surname><given-names>AD</given-names></name>. <article-title>Die mittlere Energie rotierender elektrischer Dipole im Strahlungsfeld</article-title>. <source>Annalen der Physik</source>. <year>1914</year>;<volume>348</volume>(<issue>5</issue>):<fpage>810</fpage>&#x02013;<lpage>820</lpage>. <pub-id pub-id-type="doi">10.1002/andp.19143480507</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref012"><label>12</label><mixed-citation publication-type="other">Planck M. &#x000dc;ber einen Satz der statistischen Dynamik und seine Erweiterung in der Quantentheorie. Reimer; 1917.</mixed-citation></ref><ref id="pcbi.1007491.ref013"><label>13</label><mixed-citation publication-type="journal">
<name><surname>Koopman</surname><given-names>BO</given-names></name>. <article-title>Hamiltonian systems and transformation in Hilbert space</article-title>. <source>Proceedings of the National Academy of Sciences</source>. <year>1931</year>;<volume>17</volume>(<issue>5</issue>):<fpage>315</fpage>&#x02013;<lpage>318</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.17.5.315</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref014"><label>14</label><mixed-citation publication-type="book">
<name><surname>von Neumann</surname><given-names>J</given-names></name>. <chapter-title>Zur Operatorenmethode in der klassischen Mechanik</chapter-title>
<source>Annals of Mathematics</source>. <year>1932</year>; p. <fpage>587</fpage>&#x02013;<lpage>642</lpage>.</mixed-citation></ref><ref id="pcbi.1007491.ref015"><label>15</label><mixed-citation publication-type="book">
<name><surname>Neumann</surname><given-names>JV</given-names></name>. <chapter-title>Zusatze Zur Arbeit, Zur Operatorenmethode</chapter-title>&#x02026; <source>Annals of Mathematics</source>. <year>1932</year>; p. <fpage>789</fpage>&#x02013;<lpage>791</lpage>.</mixed-citation></ref><ref id="pcbi.1007491.ref016"><label>16</label><mixed-citation publication-type="journal">
<name><surname>Bachelier</surname><given-names>L</given-names></name>. <article-title>Th&#x000e9;orie des probabilit&#x000e9;s continues</article-title>. <source>Journal de Math&#x000e9;matiques Pures et Appliqu&#x000e9;es</source>. <year>1906</year>;<volume>2</volume>:<fpage>259</fpage>&#x02013;<lpage>328</lpage>.</mixed-citation></ref><ref id="pcbi.1007491.ref017"><label>17</label><mixed-citation publication-type="journal">
<name><surname>Kolmogoroff</surname><given-names>A</given-names></name>. <article-title>&#x000dc;ber die analytischen Methoden in der Wahrscheinlichkeitsrechnung</article-title>. <source>Mathematische Annalen</source>. <year>1931</year>;<volume>104</volume>(<issue>1</issue>):<fpage>415</fpage>&#x02013;<lpage>458</lpage>. <pub-id pub-id-type="doi">10.1007/BF01457949</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref018"><label>18</label><mixed-citation publication-type="journal">
<name><surname>Schmid</surname><given-names>PJ</given-names></name>. <article-title>Dynamic mode decomposition of numerical and experimental data</article-title>. <source>Journal of fluid mechanics</source>. <year>2010</year>;<volume>656</volume>:<fpage>5</fpage>&#x02013;<lpage>28</lpage>. <pub-id pub-id-type="doi">10.1017/S0022112010001217</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref019"><label>19</label><mixed-citation publication-type="journal">
<name><surname>Tu</surname><given-names>JH</given-names></name>, <name><surname>Rowley</surname><given-names>CW</given-names></name>, <name><surname>Luchtenburg</surname><given-names>DM</given-names></name>, <name><surname>Brunton</surname><given-names>SL</given-names></name>, <name><surname>Kutz</surname><given-names>JN</given-names></name>. <article-title>On Dynamic Mode Decomposition: Theory and applications</article-title>. <source>Journal of Computational Dynamics</source>. <year>2014</year>;<volume>1</volume>(<issue>2</issue>):<fpage>391</fpage>&#x02013;<lpage>421</lpage>. <pub-id pub-id-type="doi">10.3934/jcd.2014.1.391</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref020"><label>20</label><mixed-citation publication-type="journal">
<name><surname>Williams</surname><given-names>MO</given-names></name>, <name><surname>Kevrekidis</surname><given-names>IG</given-names></name>, <name><surname>Rowley</surname><given-names>CW</given-names></name>. <article-title>A data&#x02013;driven approximation of the Koopman operator: Extending dynamic mode decomposition</article-title>. <source>Journal of Nonlinear Science</source>. <year>2015</year>;<volume>25</volume>(<issue>6</issue>):<fpage>1307</fpage>&#x02013;<lpage>1346</lpage>. <pub-id pub-id-type="doi">10.1007/s00332-015-9258-5</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref021"><label>21</label><mixed-citation publication-type="journal">
<name><surname>Klus</surname><given-names>S</given-names></name>, <name><surname>Koltai</surname><given-names>P</given-names></name>, <name><surname>Sch&#x000fc;tte</surname><given-names>C</given-names></name>. <article-title>On the numerical approximation of the Perron-Frobenius and Koopman operator</article-title>. <source>Journal of Computational Dynamics</source>. <year>2016</year>;<volume>3</volume>(<issue>1</issue>):<fpage>51</fpage>&#x02013;<lpage>79</lpage>.</mixed-citation></ref><ref id="pcbi.1007491.ref022"><label>22</label><mixed-citation publication-type="other">Klus S, N&#x000fc;ske F, Koltai P, Wu H, Kevrekidis I, Sch&#x000fc;tte C, et al. Data-driven model reduction and transfer operator approximation. arXiv preprint arXiv:170310112. 2017;.</mixed-citation></ref><ref id="pcbi.1007491.ref023"><label>23</label><mixed-citation publication-type="journal">
<name><surname>Proctor</surname><given-names>JL</given-names></name>, <name><surname>Eckhoff</surname><given-names>PA</given-names></name>. <article-title>Discovering dynamic patterns from infectious disease data using dynamic mode decomposition</article-title>. <source>International health</source>. <year>2015</year>;<volume>7</volume>(<issue>2</issue>):<fpage>139</fpage>&#x02013;<lpage>145</lpage>. <pub-id pub-id-type="doi">10.1093/inthealth/ihv009</pub-id>
<pub-id pub-id-type="pmid">25733564</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref024"><label>24</label><mixed-citation publication-type="journal">
<name><surname>Proctor</surname><given-names>JL</given-names></name>, <name><surname>Brunton</surname><given-names>SL</given-names></name>, <name><surname>Kutz</surname><given-names>JN</given-names></name>. <article-title>Dynamic mode decomposition with control</article-title>. <source>SIAM Journal on Applied Dynamical Systems</source>. <year>2016</year>;<volume>15</volume>(<issue>1</issue>):<fpage>142</fpage>&#x02013;<lpage>161</lpage>. <pub-id pub-id-type="doi">10.1137/15M1013857</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref025"><label>25</label><mixed-citation publication-type="journal">
<name><surname>Brunton</surname><given-names>BW</given-names></name>, <name><surname>Johnson</surname><given-names>LA</given-names></name>, <name><surname>Ojemann</surname><given-names>JG</given-names></name>, <name><surname>Kutz</surname><given-names>JN</given-names></name>. <article-title>Extracting spatial&#x02013;temporal coherent patterns in large-scale neural recordings using dynamic mode decomposition</article-title>. <source>Journal of neuroscience methods</source>. <year>2016</year>;<volume>258</volume>:<fpage>1</fpage>&#x02013;<lpage>15</lpage>. <pub-id pub-id-type="doi">10.1016/j.jneumeth.2015.10.010</pub-id>
<pub-id pub-id-type="pmid">26529367</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref026"><label>26</label><mixed-citation publication-type="other">Mauroy A, Goncalves J. Koopman-based lifting techniques for nonlinear systems identification. arXiv e-prints. 2017;.</mixed-citation></ref><ref id="pcbi.1007491.ref027"><label>27</label><mixed-citation publication-type="other">Riseth AN, Taylor-King JP. Operator Fitting for Parameter Estimation of Stochastic Differential Equations. arXiv e-prints. 2017;.</mixed-citation></ref><ref id="pcbi.1007491.ref028"><label>28</label><mixed-citation publication-type="journal">
<name><surname>Zunder</surname><given-names>ER</given-names></name>, <name><surname>Lujan</surname><given-names>E</given-names></name>, <name><surname>Goltsev</surname><given-names>Y</given-names></name>, <name><surname>Wernig</surname><given-names>M</given-names></name>, <name><surname>Nolan</surname><given-names>GP</given-names></name>. <article-title>A continuous molecular roadmap to iPSC reprogramming through progression analysis of single-cell mass cytometry</article-title>. <source>Cell Stem Cell</source>. <year>2015</year>;<volume>16</volume>(<issue>3</issue>):<fpage>323</fpage>&#x02013;<lpage>337</lpage>. <pub-id pub-id-type="doi">10.1016/j.stem.2015.01.015</pub-id>
<pub-id pub-id-type="pmid">25748935</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref029"><label>29</label><mixed-citation publication-type="journal">
<name><surname>Akaike</surname><given-names>H</given-names></name>. <article-title>A new look at the statistical model identification</article-title>. <source>IEEE transactions on automatic control</source>. <year>1974</year>;<volume>19</volume>(<issue>6</issue>):<fpage>716</fpage>&#x02013;<lpage>723</lpage>. <pub-id pub-id-type="doi">10.1109/TAC.1974.1100705</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref030"><label>30</label><mixed-citation publication-type="journal">
<name><surname>Amir</surname><given-names>EaD</given-names></name>, <name><surname>Davis</surname><given-names>KL</given-names></name>, <name><surname>Tadmor</surname><given-names>MD</given-names></name>, <name><surname>Simonds</surname><given-names>EF</given-names></name>, <name><surname>Levine</surname><given-names>JH</given-names></name>, <name><surname>Bendall</surname><given-names>SC</given-names></name>, <etal>et al</etal>
<article-title>viSNE enables visualization of high dimensional single-cell data and reveals phenotypic heterogeneity of leukemia</article-title>. <source>Nature biotechnology</source>. <year>2013</year>;<volume>31</volume>(<issue>6</issue>):<fpage>545</fpage>
<pub-id pub-id-type="doi">10.1038/nbt.2594</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref031"><label>31</label><mixed-citation publication-type="journal">
<name><surname>Nowicka</surname><given-names>M</given-names></name>, <name><surname>Krieg</surname><given-names>C</given-names></name>, <name><surname>Weber</surname><given-names>LM</given-names></name>, <name><surname>Hartmann</surname><given-names>FJ</given-names></name>, <name><surname>Guglietta</surname><given-names>S</given-names></name>, <name><surname>Becher</surname><given-names>B</given-names></name>, <etal>et al</etal>
<article-title>CyTOF workflow: differential discovery in high-throughput high-dimensional cytometry datasets</article-title>. <source>F1000Research</source>. <year>2017</year>;<volume>6</volume>
<pub-id pub-id-type="doi">10.12688/f1000research.11622.1</pub-id>
<pub-id pub-id-type="pmid">28663787</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref032"><label>32</label><mixed-citation publication-type="journal">
<name><surname>Lun</surname><given-names>XK</given-names></name>, <name><surname>Zanotelli</surname><given-names>VR</given-names></name>, <name><surname>Wade</surname><given-names>JD</given-names></name>, <name><surname>Schapiro</surname><given-names>D</given-names></name>, <name><surname>Tognetti</surname><given-names>M</given-names></name>, <name><surname>Dobberstein</surname><given-names>N</given-names></name>, <etal>et al</etal>
<article-title>Influence of node abundance on signaling network state and dynamics analyzed by mass cytometry</article-title>. <source>Nature biotechnology</source>. <year>2017</year>;<volume>35</volume>(<issue>2</issue>):<fpage>164</fpage>
<pub-id pub-id-type="doi">10.1038/nbt.3770</pub-id>
<pub-id pub-id-type="pmid">28092656</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref033"><label>33</label><mixed-citation publication-type="journal">
<name><surname>Bromiley</surname><given-names>P</given-names></name>. <article-title>Products and convolutions of Gaussian probability density functions</article-title>. <source>Tina-Vision Memo</source>. <year>2003</year>;<volume>3</volume>(<issue>4</issue>):<fpage>1</fpage>.</mixed-citation></ref><ref id="pcbi.1007491.ref034"><label>34</label><mixed-citation publication-type="book">
<name><surname>Higham</surname><given-names>NJ</given-names></name>. <source>Functions of matrices: theory and computation</source>. <volume>vol. 104</volume>
<publisher-name>Siam</publisher-name>; <year>2008</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref035"><label>35</label><mixed-citation publication-type="book">
<name><surname>&#x000d8;ksendal</surname><given-names>B</given-names></name>. <source>Stochastic Differential Equations: An introduction with applications</source>. <edition>5th ed</edition>
<publisher-name>Springer</publisher-name>
<publisher-loc>Verlag</publisher-loc>; <year>2000</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref036"><label>36</label><mixed-citation publication-type="other">Erban R, Chapman J, Maini P. A practical guide to stochastic simulations of reaction-diffusion processes. arXiv preprint arXiv:07041908. 2007;.</mixed-citation></ref><ref id="pcbi.1007491.ref037"><label>37</label><mixed-citation publication-type="book">
<name><surname>Ziemer</surname><given-names>WP</given-names></name>. <source>Weakly differentiable functions: Sobolev spaces and functions of bounded variation</source>. <volume>vol. 120</volume>
<publisher-name>Springer Science &#x00026; Business Media</publisher-name>; <year>2012</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref038"><label>38</label><mixed-citation publication-type="book">
<name><surname>Gilbarg</surname><given-names>D</given-names></name>, <name><surname>Trudinger</surname><given-names>NS</given-names></name>. <source>Elliptic partial differential equations of second order</source>. <publisher-name>Springer</publisher-name>; <year>2015</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref039"><label>39</label><mixed-citation publication-type="book">
<name><surname>Fornberg</surname><given-names>B</given-names></name>, <name><surname>Flyer</surname><given-names>N</given-names></name>. <source>A primer on radial basis functions with applications to the geosciences</source>. <publisher-name>SIAM</publisher-name>; <year>2015</year>.</mixed-citation></ref><ref id="pcbi.1007491.ref040"><label>40</label><mixed-citation publication-type="journal">
<name><surname>Alberty</surname><given-names>J</given-names></name>, <name><surname>Carstensen</surname><given-names>C</given-names></name>, <name><surname>Funken</surname><given-names>SA</given-names></name>. <article-title>Remarks around 50 lines of Matlab: short finite element implementation</article-title>. <source>Numerical Algorithms</source>. <year>1999</year>;<volume>20</volume>(<issue>2-3</issue>):<fpage>117</fpage>&#x02013;<lpage>137</lpage>. <pub-id pub-id-type="doi">10.1023/A:1019155918070</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref041"><label>41</label><mixed-citation publication-type="journal">
<name><surname>Botev</surname><given-names>ZI</given-names></name>, <name><surname>Grotowski</surname><given-names>JF</given-names></name>, <name><surname>Kroese</surname><given-names>DP</given-names></name>, <etal>et al</etal>
<article-title>Kernel density estimation via diffusion</article-title>. <source>The annals of Statistics</source>. <year>2010</year>;<volume>38</volume>(<issue>5</issue>):<fpage>2916</fpage>&#x02013;<lpage>2957</lpage>. <pub-id pub-id-type="doi">10.1214/10-AOS799</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref042"><label>42</label><mixed-citation publication-type="journal">
<name><surname>Setty</surname><given-names>M</given-names></name>, <name><surname>Tadmor</surname><given-names>MD</given-names></name>, <name><surname>Reich-Zeliger</surname><given-names>S</given-names></name>, <name><surname>Angel</surname><given-names>O</given-names></name>, <name><surname>Salame</surname><given-names>TM</given-names></name>, <name><surname>Kathail</surname><given-names>P</given-names></name>, <etal>et al</etal>
<article-title>Wishbone identifies bifurcating developmental trajectories from single-cell data</article-title>. <source>Nature biotechnology</source>. <year>2016</year>;<volume>34</volume>(<issue>6</issue>):<fpage>637</fpage>
<pub-id pub-id-type="doi">10.1038/nbt.3569</pub-id>
<pub-id pub-id-type="pmid">27136076</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref043"><label>43</label><mixed-citation publication-type="journal">
<name><surname>Ching</surname><given-names>T</given-names></name>, <name><surname>Himmelstein</surname><given-names>DS</given-names></name>, <name><surname>Beaulieu-Jones</surname><given-names>BK</given-names></name>, <name><surname>Kalinin</surname><given-names>AA</given-names></name>, <name><surname>Do</surname><given-names>BT</given-names></name>, <name><surname>Way</surname><given-names>GP</given-names></name>, <etal>et al</etal>
<article-title>Opportunities and obstacles for deep learning in biology and medicine</article-title>. <source>Journal of The Royal Society Interface</source>. <year>2018</year>;<volume>15</volume>(<issue>141</issue>):<fpage>20170387</fpage>
<pub-id pub-id-type="doi">10.1098/rsif.2017.0387</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref044"><label>44</label><mixed-citation publication-type="journal">
<name><surname>Saelens</surname><given-names>W</given-names></name>, <name><surname>Cannoodt</surname><given-names>R</given-names></name>, <name><surname>Todorov</surname><given-names>H</given-names></name>, <name><surname>Saeys</surname><given-names>Y</given-names></name>. <article-title>A comparison of single-cell trajectory inference methods: towards more accurate and robust tools</article-title>. <source>bioRxiv</source>. <year>2018</year>;.</mixed-citation></ref><ref id="pcbi.1007491.ref045"><label>45</label><mixed-citation publication-type="journal">
<name><surname>Cannoodt</surname><given-names>R</given-names></name>, <name><surname>Saelens</surname><given-names>W</given-names></name>, <name><surname>Saeys</surname><given-names>Y</given-names></name>. <article-title>Computational methods for trajectory inference from single-cell transcriptomics</article-title>. <source>European journal of immunology</source>. <year>2016</year>;<volume>46</volume>(<issue>11</issue>):<fpage>2496</fpage>&#x02013;<lpage>2506</lpage>. <pub-id pub-id-type="doi">10.1002/eji.201646347</pub-id>
<pub-id pub-id-type="pmid">27682842</pub-id></mixed-citation></ref><ref id="pcbi.1007491.ref046"><label>46</label><mixed-citation publication-type="journal">
<name><surname>Fischer</surname><given-names>DS</given-names></name>, <name><surname>Fiedler</surname><given-names>AK</given-names></name>, <name><surname>Kernfeld</surname><given-names>E</given-names></name>, <name><surname>Genga</surname><given-names>RMJ</given-names></name>, <name><surname>Hasenauer</surname><given-names>J</given-names></name>, <name><surname>Maehr</surname><given-names>R</given-names></name>, <etal>et al</etal>
<article-title>Beyond pseudotime: Following T-cell maturation in single-cell RNAseq time series</article-title>. <source>bioRxiv</source>. <year>2017</year>;.</mixed-citation></ref><ref id="pcbi.1007491.ref047"><label>47</label><mixed-citation publication-type="other">Hashimoto T, Gifford D, Jaakkola T. Learning population-level diffusions with generative recurrent networks. In: International Conference on Machine Learning; 2016. p. 2417&#x02013;2426.</mixed-citation></ref></ref-list></back></article>