<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.2 20190208//EN" "JATS-archivearticle1-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Lang Resour Eval</journal-id><journal-id journal-id-type="iso-abbrev">Lang Resour Eval</journal-id><journal-title-group><journal-title>Language Resources and Evaluation</journal-title></journal-title-group><issn pub-type="ppub">1574-020X</issn><issn pub-type="epub">1574-0218</issn><publisher><publisher-name>Springer Netherlands</publisher-name><publisher-loc>Dordrecht</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">31983909</article-id><article-id pub-id-type="pmc">6954025</article-id><article-id pub-id-type="publisher-id">9379</article-id><article-id pub-id-type="doi">10.1007/s10579-017-9379-6</article-id><article-categories><subj-group subj-group-type="heading"><subject>Original Paper</subject></subj-group></article-categories><title-group><article-title>Hindi CCGbank: A CCG treebank from the Hindi dependency treebank</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes"><name><surname>Ambati</surname><given-names>Bharat Ram</given-names></name><address><email>bharat.ambati@ed.ac.uk</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><contrib contrib-type="author"><name><surname>Deoskar</surname><given-names>Tejaswini</given-names></name><address><email>t.deoskar@uva.nl</email></address><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author"><name><surname>Steedman</surname><given-names>Mark</given-names></name><address><email>steedman@inf.ed.ac.uk</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1936 7988</institution-id><institution-id institution-id-type="GRID">grid.4305.2</institution-id><institution>ILCC, School of Informatics, </institution><institution>University of Edinburgh, </institution></institution-wrap>Edinburgh, UK </aff><aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000000084992262</institution-id><institution-id institution-id-type="GRID">grid.7177.6</institution-id><institution>Institute for Logic, Language and Computation, </institution><institution>University of Amsterdam, </institution></institution-wrap>Amsterdam, The Netherlands </aff></contrib-group><pub-date pub-type="epub"><day>25</day><month>1</month><year>2017</year></pub-date><pub-date pub-type="pmc-release"><day>25</day><month>1</month><year>2017</year></pub-date><pub-date pub-type="ppub"><year>2018</year></pub-date><volume>52</volume><issue>1</issue><fpage>67</fpage><lpage>100</lpage><permissions><copyright-statement>&#x000a9; The Author(s) 2017</copyright-statement><license license-type="OpenAccess"><license-p>
<bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made.</license-p></license></permissions><abstract id="Abs1"><p id="Par1">In this paper, we present an approach for automatically creating a combinatory categorial grammar (CCG) treebank from a dependency treebank for the subject&#x02013;object&#x02013;verb language Hindi. Rather than a direct conversion from dependency trees to CCG trees, we propose a two stage approach: a language independent generic algorithm first extracts a CCG lexicon from the dependency treebank. An exhaustive CCG parser then creates a treebank of CCG derivations. We also discuss special cases of this generic algorithm to handle linguistic phenomena specific to Hindi. In doing so we extract different constructions with long-range dependencies like coordinate constructions and non-projective dependencies resulting from constructions like relative clauses, noun elaboration and verbal modifiers.</p></abstract><kwd-group xml:lang="en"><title>Keywords</title><kwd>Combinatory categorial grammar</kwd><kwd>CCG</kwd><kwd>Treebank</kwd><kwd>Hindi</kwd><kwd>Non-projective dependencies</kwd></kwd-group><funding-group><award-group><funding-source><institution>ERC Advanced Fellowship 249520 GRAMPLUS</institution></funding-source></award-group></funding-group><funding-group><award-group><funding-source><institution>EU IST Cognitive Systems IP Xperience</institution></funding-source></award-group></funding-group><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#x000a9; Springer Science+Business Media B.V., part of Springer Nature 2018</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1"><title>Introduction</title><p id="Par2">Combinatory categorial grammar (CCG) (Steedman <xref ref-type="bibr" rid="CR55">2000</xref>) is an efficiently parseable, yet linguistically expressive grammar formalism. In addition to predicate-argument structure, CCG elegantly captures the unbounded dependencies found in grammatical constructions like relativization, coordination etc. Availability of the English CCGbank (Hockenmaier and Steedman <xref ref-type="bibr" rid="CR26">2007</xref>) has enabled the creation of several robust and accurate wide-coverage CCG parsers for English, both graph-based and transition-based, that are being used extensively for broad-coverage parsing, and especially for tasks requiring deep linguistic analysis such as semantic parsing and question-answering (Hockenmaier and Steedman <xref ref-type="bibr" rid="CR25">2002</xref>; Clark and Curran <xref ref-type="bibr" rid="CR21">2007</xref>; Auli and Lopez <xref ref-type="bibr" rid="CR6">2011</xref>; Lewis and Steedman <xref ref-type="bibr" rid="CR37">2014</xref>; Zhang and Clark <xref ref-type="bibr" rid="CR62">2011</xref>; Xu et&#x000a0;al. <xref ref-type="bibr" rid="CR60">2014</xref>; Ambati et&#x000a0;al. <xref ref-type="bibr" rid="CR5">2015</xref>). Creation of CCGbanks in other languages, especially languages typologically far from English is beneficial both for the development of CCG analyses for linguistic phenomenon in these languages, and also for the development of deep NLP tools for these languages.</p><p id="Par3">Different grammar formalisms like phrase structure grammar, combinatory categorial grammar, and dependency grammar have different advantages. But developing treebanks manually in each formalism is a very expensive and time consuming task. Automatic conversion of treebanks from one formalism to another significantly reduces the manual annotation effort. We develop an algorithm for automatically creating CCGbanks from dependency treebanks. We apply this approach to automatically creating a Hindi CCGbank from an existing manually created Hindi dependency treebank (Bhatt et&#x000a0;al. <xref ref-type="bibr" rid="CR15">2009</xref>). The approach is applicable for creating CCGbanks for other languages with existing dependency treebanks, and is especially relevant for other Indian languages.</p><p id="Par4">As compared to English, many Indian languages, including Hindi, while basically verb final, have a freer word-order and are morphologically richer. All of these characteristics pose challenges to statistical parsers. In the Hindi dependency treebank there are around 20% of dependency trees with at least one non-projective arc which are problematic for vanilla shift-reduce parsing algorithms like arc-eager and arc-standard (Nivre et&#x000a0;al. <xref ref-type="bibr" rid="CR50">2007b</xref>). In this work, we show that CCG can capture these phenomena elegantly, essentially by making such dependencies projective&#x02014;that is, covered by the grammar. Our approach can be adapted to extract CCGbanks for other typologically similar languages with existing dependency treebanks, such as other Indic languages. The rest of the paper is organized as follows. Section&#x000a0;<xref rid="Sec2" ref-type="sec">2</xref> gives a short introduction to the CCG formalism. Section&#x000a0;<xref rid="Sec3" ref-type="sec">3</xref> describes related work regarding the automatic creation of CCGbanks for English and other languages. A brief summary of the Hindi dependency treebank is provided in Sect.&#x000a0;<xref rid="Sec4" ref-type="sec">4</xref>. In Sects.&#x000a0;<xref rid="Sec8" ref-type="sec">5</xref> and&#x000a0;<xref rid="Sec10" ref-type="sec">6</xref>, we first show how we extract a CCG lexicon from the Hindi dependency treebank and then use it to create a Hindi CCGbank. Details of different long-range dependencies arising from coordination and other non-projective constructions are presented in Sects.&#x000a0;<xref rid="Sec12" ref-type="sec">7</xref> and&#x000a0;<xref rid="Sec13" ref-type="sec">8</xref>. Finally, an analysis of CCG categories and combinators present in the Hindi CCGbank is provided in Sect.&#x000a0;<xref rid="Sec20" ref-type="sec">9</xref>. We conclude with possible future directions in Sect.&#x000a0;<xref rid="Sec21" ref-type="sec">10</xref>.</p></sec><sec id="Sec2"><title>Combinatory categorial grammar</title><p id="Par5">Combinatory categorial grammar (CCG) is a strongly lexicalized grammar formalism, in the sense that all language-specific information including linear order is defined at the level of the lexicon. It is &#x0201c;nearly context-free&#x0201d; in expressive power, in the sense of being among a group of formalisms for natural language grammars that are at the lowest level of the language hierarchy above context-free grammar (CFG) that is known (Joshi et&#x000a0;al. <xref ref-type="bibr" rid="CR30">1991</xref>; Kuhlmann et&#x000a0;al. <xref ref-type="bibr" rid="CR33">2015</xref>). It has a completely type-transparent interface between syntactic derivation and compositional assembly of the underlying semantic representation, including predicate-argument structure, quantification and information structure. Because of this semantic transparency, CCG is widely used in practical applications involving semantic interpretation and inference, (Bos et&#x000a0;al. <xref ref-type="bibr" rid="CR17">2004</xref>; Lewis and Steedman <xref ref-type="bibr" rid="CR38">2013a</xref>, <xref ref-type="bibr" rid="CR36">b</xref>) especially for semantic parsing with special focus on question answering (Kwiatkowski et&#x000a0;al. <xref ref-type="bibr" rid="CR35">2013</xref>; Reddy et&#x000a0;al. <xref ref-type="bibr" rid="CR52">2014</xref>).</p><p id="Par6">In the categorial lexicon, words are associated with syntactic categories, such as <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S\setminus NP$$\end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:mi>S</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq1.gif"/></alternatives></inline-formula> or <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(S\setminus NP)/ NP$$\end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq2.gif"/></alternatives></inline-formula> for English intransitive and transitive verbs. Categories of the form <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$X\setminus Y$$\end{document}</tex-math><mml:math id="M6"><mml:mrow><mml:mi>X</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>Y</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq3.gif"/></alternatives></inline-formula> or <italic>X</italic>&#x000a0;/&#x000a0;<italic>Y</italic> are functors, which take an argument <italic>Y</italic> to their left or right (depending on the direction of the slash) and yield a result <italic>X</italic>. Every syntactic category is paired with a semantic interpretation (usually expressed as a <inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\lambda $$\end{document}</tex-math><mml:math id="M8"><mml:mi mathvariant="italic">&#x003bb;</mml:mi></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq4.gif"/></alternatives></inline-formula>-term).</p><p id="Par7">Like all variants of categorial grammar, CCG uses function application to combine constituents, but it also uses a set of linear order-dependent syntactic combinatory rules corresponding semantically to composition (<bold>B</bold>) and type-raising (<bold>T</bold>). Type raising is a non-recursive lexical operation related to (morphological or &#x0201c;structural&#x0201d;&#x02019;) case. However, for fixed word-order languages without morphological case, Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>) advocate the use of unary type-changing? rules for reasons of efficiency, including type-raising rules and additional rules to deal with complex adjunct categories (e.g <inline-formula id="IEq5"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(NP\setminus NP)\Longrightarrow S[ng]\setminus NP$$\end{document}</tex-math><mml:math id="M10"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">&#x027f9;</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq5.gif"/></alternatives></inline-formula> for ing-VPs that act as noun phrase modifiers). Examples of CCG combinators are: <table-wrap id="Taba"><table frame="hsides" rules="groups"><tbody><tr><td align="left">Forward Application (&#x0003e;)</td><td align="left">X/Y</td><td align="left">Y</td><td align="left">
<inline-formula id="IEq6"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M12"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq6.gif"/></alternatives></inline-formula>
</td><td align="left">X</td></tr><tr><td align="left">Backward Application (&#x0003c;)</td><td align="left">Y</td><td align="left">
<inline-formula id="IEq7"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {X}\setminus \hbox {Y}$$\end{document}</tex-math><mml:math id="M14"><mml:mrow><mml:mtext>X</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Y</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq7.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq8"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M16"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq8.gif"/></alternatives></inline-formula>
</td><td align="left">X</td></tr><tr><td align="left">Forward Composition (&#x0003e;B)</td><td align="left">X/Y</td><td align="left">Y/Z</td><td align="left">
<inline-formula id="IEq9"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M18"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq9.gif"/></alternatives></inline-formula>
</td><td align="left">X/Z</td></tr><tr><td align="left">Backward Composition (&#x0003c;B)</td><td align="left">
<inline-formula id="IEq10"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {Y}\setminus \hbox {Z}$$\end{document}</tex-math><mml:math id="M20"><mml:mrow><mml:mtext>Y</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Z</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq10.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq11"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {X}\setminus \hbox {Y}$$\end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:mtext>X</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Y</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq11.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq12"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M24"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq12.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq13"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {X}\setminus \hbox {Z}$$\end{document}</tex-math><mml:math id="M26"><mml:mrow><mml:mtext>X</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Z</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq13.gif"/></alternatives></inline-formula>
</td></tr><tr><td align="left">Forward Crossed Composition (<inline-formula id="IEq14"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${&#x0003e;}B_{X}$$\end{document}</tex-math><mml:math id="M28"><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq14.gif"/></alternatives></inline-formula>)</td><td align="left">X/Y</td><td align="left">
<inline-formula id="IEq15"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {Y}\setminus \hbox {Z}$$\end{document}</tex-math><mml:math id="M30"><mml:mrow><mml:mtext>Y</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Z</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq15.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq16"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M32"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq16.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq17"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {X}\setminus \hbox {Z}$$\end{document}</tex-math><mml:math id="M34"><mml:mrow><mml:mtext>X</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Z</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq17.gif"/></alternatives></inline-formula>
</td></tr><tr><td align="left">Backward Crossed Composition (<inline-formula id="IEq18"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${&#x0003c;}B_{X}$$\end{document}</tex-math><mml:math id="M36"><mml:mrow><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq18.gif"/></alternatives></inline-formula>)</td><td align="left">Y/Z</td><td align="left">
<inline-formula id="IEq19"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {X}\setminus \hbox {Y}$$\end{document}</tex-math><mml:math id="M38"><mml:mrow><mml:mtext>X</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>Y</mml:mtext></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq19.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq20"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M40"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq20.gif"/></alternatives></inline-formula>
</td><td align="left">X/Z</td></tr><tr><td align="left">Forward Type-raising (&#x0003e;T)</td><td align="left">X</td><td align="left"/><td align="left">
<inline-formula id="IEq21"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M42"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq21.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq22"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {T}/(\hbox {T}\setminus \hbox {X})$$\end{document}</tex-math><mml:math id="M44"><mml:mrow><mml:mtext>T</mml:mtext><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>T</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mtext>X</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq22.gif"/></alternatives></inline-formula>
</td></tr><tr><td align="left">Backward Type-raising (&#x0003c;T)</td><td align="left">X</td><td align="left"/><td align="left">
<inline-formula id="IEq23"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Longrightarrow $$\end{document}</tex-math><mml:math id="M46"><mml:mo stretchy="false">&#x027f9;</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq23.gif"/></alternatives></inline-formula>
</td><td align="left">
<inline-formula id="IEq24"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hbox {T}\setminus (\hbox {T/X})$$\end{document}</tex-math><mml:math id="M48"><mml:mrow><mml:mtext>T</mml:mtext><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>T/X</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq24.gif"/></alternatives></inline-formula>
</td></tr></tbody></table></table-wrap>
</p></sec><sec id="Sec3"><title>Related work</title><p id="Par8">Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>) developed the first English CCGbank automatically from the Penn Wall Street Journal Phrase Structure Treebank (Marcus et&#x000a0;al. <xref ref-type="bibr" rid="CR42">1993</xref>). For each phrase structure tree, they first determine the constituent type of each node using heuristics adapted from Magerman (<xref ref-type="bibr" rid="CR39">1994</xref>) and Collins (<xref ref-type="bibr" rid="CR22">1999</xref>), which take the label of a node and its parent into account. Then the tree is binarized inserting dummy nodes as required into the tree such that all children to the left of the head branch off in a right-branching tree, and then all children to the right of the head branch off in a left-branching tree. Then CCG categories are assigned based on whether the node is root of the sentence, complement or adjunct of the head. Finally, headword dependencies which approximate the underlying predicate-argument structure are obtained.</p><p id="Par9">The English CCGbank (Hockenmaier and Steedman <xref ref-type="bibr" rid="CR26">2007</xref>) is primarily created from the Penn Phrase Structure Treebank, which doesn&#x02019;t directly capture interesting linguistic phenomena like predicate-argument structures. Resources like PropBank (Palmer et&#x000a0;al. <xref ref-type="bibr" rid="CR51">2005</xref>) capture predicate-argument structure of the verb. Using PropBank, Honnibal and Curran (<xref ref-type="bibr" rid="CR27">2007</xref>) improved the complement and adjunct distinction in the CCGbank. Using information from different resources like PropBank and NomBank (Meyers et&#x000a0;al. <xref ref-type="bibr" rid="CR44">2004</xref>), Honnibal et&#x000a0;al. (<xref ref-type="bibr" rid="CR28">2010</xref>) created an updated version of CCGbank which includes predicate-argument structures for both verbs and nouns, baseNP brackets, verb-particle constructions, and nominal modifiers. They also trained a state-of-the-art CCG parser on this new treebank and compared with the original treebank. Since the updated treebank contains fine-grained details the performance of the parser was slightly lower than the one trained on the original version.</p><p id="Par10">Following Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>), there have been some efforts at automatically extracting treebanks of CCG derivations for other languages. Hockenmaier (<xref ref-type="bibr" rid="CR24">2006</xref>) developed a CCGbank for German from the Tiger treebank (Brants et&#x000a0;al. <xref ref-type="bibr" rid="CR18">2002</xref>). The Tiger treebank is based on a framework which has features from both phrase structure grammar and dependency grammar and results in graphs rather than trees. First, these graphs are pre-processed and converted to planar trees. Then a translation step is applied which binarizes the planar tree and extracts the CCG derivation. Tse and Curran (<xref ref-type="bibr" rid="CR56">2010</xref>) use an algorithm similar to Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>) to extract a Chinese CCGbank from the Penn Chinese Treebank (Xue et&#x000a0;al. <xref ref-type="bibr" rid="CR61">2005</xref>).</p><p id="Par11">There has also been work on extracting CCG lexicons (Cakici <xref ref-type="bibr" rid="CR20">2005</xref>) and CCGbanks (Bos et&#x000a0;al. <xref ref-type="bibr" rid="CR16">2009</xref>; Uematsu et&#x000a0;al. <xref ref-type="bibr" rid="CR57">2013</xref>, <xref ref-type="bibr" rid="CR58">2015</xref>) from dependency treebanks. Bos et&#x000a0;al. (<xref ref-type="bibr" rid="CR16">2009</xref>) created an Italian CCGbank from the Turin University Treebank (TUT),<xref ref-type="fn" rid="Fn1">1</xref> an Italian dependency treebank. They first converted dependency trees into phrase structure trees and then applying an algorithm similar to Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>) extracted the CCG derivations. Using different dependency resources available for Japanese like the Kyoto corpus (Kawahara et&#x000a0;al. <xref ref-type="bibr" rid="CR31">2002</xref>) and the NAIST text corpus (Iida et&#x000a0;al. <xref ref-type="bibr" rid="CR29">2007</xref>), Uematsu et&#x000a0;al. (<xref ref-type="bibr" rid="CR57">2013</xref>) developed a CCGbank for Japanese. They first integrated the dependency resources into phrase structure trees and then converted them into CCG derivations.</p><p id="Par13">
Cakici (<xref ref-type="bibr" rid="CR20">2005</xref>) extracted a CCG lexicon for Turkish. She first made a list of complement and adjunct dependency labels. Traversing the dependency tree, she assigned CCG categories to each node based on complement or adjunct information. Following Cakici (<xref ref-type="bibr" rid="CR20">2005</xref>), we first extract a Hindi CCG lexicon from the dependency treebank. Then we use a CKY parser based on the CCG formalism to automatically obtain a treebank of CCG derivations from this lexicon, a novel methodology that may be applicable to obtaining CCG treebanks in other languages as well. Our algorithm for extracting the lexicon is similar to Cakici (<xref ref-type="bibr" rid="CR20">2005</xref>), but with pre-processing steps specific to Hindi. However, where Cakici (<xref ref-type="bibr" rid="CR20">2005</xref>) extracted only a CCG lexicon, we extended it by developing a novel methodology for creating CCG derivations from this lexicon. Kumari and Rao (<xref ref-type="bibr" rid="CR34">2015</xref>) have successfully applied our method to create a CCGbank for Telugu, an Indian language, differing from Hindi in belonging to the Dravidian language family, and being agglutinative, suggesting that our algorithm is generic enough to be applied to other languages with little effort.</p><p id="Par14">In this paper, we first explain the process of creating a Hindi CCGbank from the dependency treebank using the approach described in Ambati et&#x000a0;al. (<xref ref-type="bibr" rid="CR3">2013</xref>). Then we consider long-range dependencies in coordination constructions and other so called non-projective constructions and show how they can be handled within the extended form of syntactic projection afforded by CCG.</p></sec><sec id="Sec4"><title>Hindi dependency treebank</title><p id="Par15">In this section, we first give a brief introduction to the Hindi language. Then we provide details about the Paninian grammatical model used for Hindi dependency annotation. Following this, we describe the Hindi dependency treebank.</p><sec id="Sec5"><title>Hindi language</title><p id="Par16">Hindi is one of the official languages of the Republic of India, and the 4th largest language in the world, with over 260 million speakers.<xref ref-type="fn" rid="Fn2">2</xref> Hindi, while basically verb final, is a freer word-order language. This can be seen in (1), where (1a) shows the constituents in the default SOV (Subject, Object, Verb) order, and the remaining examples show some of the word-order variants of (1a).<xref ref-type="fn" rid="Fn3">3</xref>
</p><graphic position="anchor" xlink:href="10579_2017_9379_Figa_HTML" id="MO1"/><p id="Par19">Hindi also has a rich case marking system, although case marking is not obligatory. For example, in (1), while the subject and indirect object are explicitly marked for the ergative<xref ref-type="fn" rid="Fn4">4</xref> (ERG) and dative (DAT) cases, the direct object is unmarked for the accusative.</p></sec><sec id="Sec6"><title>Paninian grammatical model</title><p id="Par21">Indian Languages (ILs) including Hindi are morphologically rich and have a relatively flexible word-order. For such languages, the syntactic notions of subject and object are not able to explain the varied linguistic phenomena. In fact, there is a debate in the literature whether the notions &#x02018;subject&#x02019; and &#x02018;object&#x02019; can at all be defined for ILs (Mohanan <xref ref-type="bibr" rid="CR45">1982</xref>). Behavioural properties are the only criteria based on which one can confidently identify grammatical functions in Hindi (Mohanan <xref ref-type="bibr" rid="CR46">1994</xref>); it can be difficult to exploit such properties computationally. Marking semantic properties such as thematic role as dependency relation is also problematic. Thematic roles are abstract notions and will require higher semantic features which are difficult to formulate and to extract as well. The Paninian grammatical model (Kiparsky and Staal <xref ref-type="bibr" rid="CR32">1969</xref>; Shastri <xref ref-type="bibr" rid="CR54">1973</xref>) provides a level which while being syntactically grounded also helps in capturing semantics. In this section we briefly discuss the Paninian grammatical model for ILs and lay down some basic concepts inherent to this framework.</p><p id="Par22">The Paninian framework considers information as central to the study of language. When a writer/speaker uses language to convey some information to the reader/ hearer, he/she codes the information in the language string. Similarly, when a reader/ hearer receives a language string, he/she extracts the information coded in it. The Paninian grammatical model is primarily concerned with: (a) how the information is coded and (b) how it can be extracted.</p><p id="Par23">Two levels of representation can be readily understood in language: One, the actual language string (or sentence), two, what the speaker has in his mind. The latter can also be called as the meaning. Paninian framework has two other important levels: karaka level and vibhakti level<fig id="Fig1"><label>Fig. 1</label><caption><p>Levels of representation/analysis in the Paninian model</p></caption><graphic xlink:href="10579_2017_9379_Fig1_HTML" id="MO2"/></fig>
</p><p id="Par24">The surface level is the uttered or written sentence. The vibhakti level is the level at which there are local word groups together with case endings, preposition or postposition markers. The vibhakti level abstracts away from many minor (including orthographic and idiosyncratic) differences among languages. Above the vibhakti level is the &#x02018;karaka&#x02019; level. It includes karaka relations, which are syntactico-semantic relations between a predicate and its arguments, and a few additional relations such as purpose. The topmost level relates to what the speaker has in his mind. This may be considered to be the ultimate meaning level that the speaker wants to convey. One can imagine several levels between the karaka and the ultimate level, each containing more semantic information. Thus, the karaka level is one in a series of levels, but one which has relationship to semantics on the one hand and syntax on the other. The levels of representation in the Paninian model are presented in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1</xref>.</p><p id="Par25">At the karaka level, we have karaka relations and verb-verb relations, etc. Karaka relations are syntactico-semantic relations between the verbs and other related constituents (typically nouns) in a sentence. They capture a certain level of semantics which is somewhat similar to thematic relations but different from it (Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR13">1995</xref>). This is the level of semantics that is important syntactically and is reflected in the surface form of the sentence(s). Begum et&#x000a0;al. (<xref ref-type="bibr" rid="CR8">2008b</xref>) have subsequently proposed and developed an annotation scheme for a dependency treebank based on the Paninian framework. They have extended the original formulation to account for previously unhandled syntactic phenomenon.</p><p id="Par26">The Paninian approach treats a sentence as a set of modifier-modified relations. A sentence is supposed to have a primary modifiee which is generally the main verb of the sentence. The elements modifying the verb participate in the action specified by the verb. The participant relations with the verb are called karaka. The notion of karaka will incorporate the &#x02018;local&#x02019; semantics of the verb in a sentence, while also taking cue from the surface level morpho-syntactic information (Vaidya et&#x000a0;al. <xref ref-type="bibr" rid="CR59">2009</xref>). There are six basic karakas, namely;<list list-type="bullet"><list-item><p id="Par27">k1: karta (This is similar to subject or agent): the most independent participant in the action</p></list-item><list-item><p id="Par28">k2: karma (roughly the theme or object): the one most desired by the karta</p></list-item><list-item><p id="Par29">k3: karana (instrument): which is most essential for the action to take place</p></list-item><list-item><p id="Par30">k4: sampradaan (beneficiary): recipient or beneficiary of the action</p></list-item><list-item><p id="Par31">k5: apaadaan (source): movement away or separation from a source</p></list-item><list-item><p id="Par32">k7: adhikarana (location): location of the action in time and space</p></list-item></list>From the above description, it is easy to see that this analysis is a dependency based analysis (Kiparsky and Staal <xref ref-type="bibr" rid="CR32">1969</xref>; Shastri <xref ref-type="bibr" rid="CR54">1973</xref>), with the verb as the root of the tree along with its argument structure as its children. The labels on the edges between a child-parent pair show the relationship between them. In addition to the above six labels many others have been proposed as part of the overall framework (Begum et&#x000a0;al. <xref ref-type="bibr" rid="CR8">2008b</xref>; Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR12">2009</xref>). &#x0201c;<xref rid="Sec22" ref-type="sec">Appendix 1</xref>&#x0201d; shows the most frequent dependency labels with their English equivalent. In this paper we use English labels rather than the Paninian.</p><p id="Par33">In the following section, we provide details of the treebank annotated for Hindi using this Paninian grammatical model.</p></sec><sec id="Sec7"><title>Treebank</title><p id="Par34">In this work, we consider a subset of the Hindi Dependency Treebank (HDT ver-0.5) released as part of Coling 2012 Shared Task on parsing (Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR9">2012</xref>). HDT is a multi-layered dependency treebank (Bhatt et&#x000a0;al. <xref ref-type="bibr" rid="CR15">2009</xref>) annotated with morpho-syntactic (morphological, part-of-speech and chunk information) and syntactico semantic (dependency) information (Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR11">2006</xref>, <xref ref-type="bibr" rid="CR12">2009</xref>). POS and chunk information is annotated following the POS and chunk annotation guidelines (Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR11">2006</xref>). The morphological features have eight mandatory feature attributes for each node. These features are classified as root, coarse POS category, gender, number, person, case, post position (for a noun) or tense aspect modality (for a verb) and suffix. The dependency annotation follows the Paninian grammar scheme described in Sect.&#x000a0;<xref rid="Sec6" ref-type="sec">4.2</xref> which is known to be well-suited to modern Indian languages. Dependency labels are fine-grained, and mark dependencies that are syntactico-semantic in nature, such as agent (usually corresponding to subject), patient (object), and time and place expressions. There are special labels to mark long distance relations like relative clauses, coordination etc (Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR13">1995</xref>, <xref ref-type="bibr" rid="CR12">2009</xref>). Figure&#x000a0;<xref rid="Fig2" ref-type="fig">2</xref> presents the dependency tree for an example sentence <italic>mohan ne raam ke lie kitaab khariidi</italic> (&#x0201c;Mohan bought a book for Ram&#x0201d;).<xref ref-type="fn" rid="Fn5">5</xref> For readability reasons, we will refer to dependency labels with their English equivalents (e.g., <sc>subj, obj, purpose, case</sc> for k1, k2, rt, lwg__psp respectively). A list of the Hindi dependency labels and their English equivalents are provided in the &#x0201c;<xref rid="Sec22" ref-type="sec">Appendix 1</xref>&#x0201d;.<fig id="Fig2"><label>Fig. 2</label><caption><p>An example dependency tree for Hindi (<italic>ERG</italic> ergative case)</p></caption><graphic xlink:href="10579_2017_9379_Fig2_HTML" id="MO3"/></fig>
</p><p id="Par36">In this example, the verb <italic>khariidii</italic> (&#x0201c;bought&#x0201d;) is the root of the sentence. <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;) is the subject (SUBJ) of the verb <italic>khariidii</italic> (&#x0201c;bought&#x0201d;) and <italic>kitaab</italic> (&#x0201c;book&#x0201d;) is the object (OBJ) of the verb. Since the book is bought for <italic>raam</italic> (&#x0201c;Ram&#x0201d;), <italic>raam</italic> is attached to the verb with PURPOSE dependency label. The post-position markers <italic>ne</italic> (Ergative case marker) and <italic>ke_lie</italic> (equivalent to preposition &#x0201c;for&#x0201d;) are attached to corresponding nouns with CASE dependency label.</p><p id="Par37">The Hindi dependency treebank contains 12,041 training, 1233 development and 1828 testing sentences with an average of 22 words per sentence. Data is provided in the Shakti Standard Format (Bharati et&#x000a0;al. <xref ref-type="bibr" rid="CR10">2007</xref>) and CoNLL format. The CoNLL format contains word, lemma, pos-tag, and coarse pos-tag in the <sc>word</sc>, <sc>lemma</sc>, <sc>pos</sc>, and <sc>cpos</sc> fields respectively and morphological features, and chunk information in the <sc>feats</sc> column.<xref ref-type="fn" rid="Fn6">6</xref> We use CoNLL format for all our experiments.</p></sec></sec><sec id="Sec8"><title>Extracting a CCG lexicon</title><p id="Par39">In order to assign CCG lexical categories to words in the treebank sentences, we first make a list of argument and adjunct dependency labels in the treebank. We obtained this list from the Hindi verb frames which make a distinction between arguments and adjuncts for different verbs, from Begum et&#x000a0;al. (<xref ref-type="bibr" rid="CR7">2008a</xref>). For e.g., dependencies with the label SUBJ and OBJ (corresponding to subject and object respectively) are considered to be arguments, while labels like PLACE and TIME (corresponding to place and time expressions) are considered to be adjuncts.</p><p id="Par40">Starting from the root of the dependency tree, we traverse each node. The category of a node depends on both its parent and children. If the node is an argument of its parent, we assign the chunk tag of the node (e.g., NP, PP) as its CCG category. Otherwise, we assign it a category of <italic>X</italic>|<italic>X</italic>, where <italic>X</italic> is the parent&#x02019;s <italic>result</italic> category and | is directionality (<inline-formula id="IEq25"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\backslash $$\end{document}</tex-math><mml:math id="M50"><mml:mo stretchy="true">\</mml:mo></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq25.gif"/></alternatives></inline-formula> or &#x000a0;/&#x000a0;), which depends on the position of the node w.r.t. its parent. The <italic>result</italic> category of a node is the category obtained once its argument slots are saturated. For example, <inline-formula id="IEq26"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_{f}$$\end{document}</tex-math><mml:math id="M52"><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq26.gif"/></alternatives></inline-formula>, is the result category for <inline-formula id="IEq27"><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(S_{f}\setminus NP)\setminus NP$$\end{document}</tex-math><mml:math id="M54"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq27.gif"/></alternatives></inline-formula>. Once we get the partial category of a node based on the node&#x02019;s parent information, we traverse through the children of the node. If a child is an argument, we add that child&#x02019;s chunk tag, with appropriate directionality, to the node&#x02019;s category. If the child is an adjunct, the category of the node is not effected.</p><p id="Par41">Consider the verb <italic>khariidii</italic> (&#x0201c;bought&#x0201d;) in the example sentence in Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3</xref>. Since it is the root of the sentence which is an argument dependency label, it gets a category <inline-formula id="IEq28"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_{f}$$\end{document}</tex-math><mml:math id="M56"><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq28.gif"/></alternatives></inline-formula>, from its parent. It has three children <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;), <italic>raam</italic> (&#x0201c;Ram&#x0201d;) and <italic>kitaab</italic> (&#x0201c;book&#x0201d;). We traverse through each child and update the category of <italic>khariidii</italic> as follows. <italic>Mohan</italic> is subject (&#x0201c;SUBJ&#x0201d;) of <italic>khariidii</italic>. Since SUBJ is a mandatory argument, the category of <italic>khariidii</italic> is updated to <inline-formula id="IEq29"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_{f}\setminus NP$$\end{document}</tex-math><mml:math id="M58"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq29.gif"/></alternatives></inline-formula>. The dependency label between <italic>raam</italic> and <italic>khariidii</italic> is PURPOSE which is an adjunct label. So, the category of <italic>khariidii</italic> (&#x0201c;bought&#x0201d;) is not changed due to this child. The third and final child <italic>kitaab</italic> is an object (&#x0201c;OBJ&#x0201d;) of the verb, which is an argument label. As a result, the category of <italic>khariidii</italic> is updated to <inline-formula id="IEq30"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(S_{f}\setminus NP)\setminus NP$$\end{document}</tex-math><mml:math id="M60"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq30.gif"/></alternatives></inline-formula>.<xref ref-type="fn" rid="Fn7">7</xref>
</p><p id="Par43">Now we consider again the children of the verb <italic>khariidii</italic> (&#x0201c;bought&#x0201d;). <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;) is an argument of <italic>khariidii</italic>, and hence <italic>NP</italic> is the category for this node. <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;) has a case marker <italic>ne</italic> (&#x0201c;ERG&#x0201d;) as a child with the dependency label CASE. The category of <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;) is not changed and remains <italic>NP</italic>. Now consider the child of <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;) which is <italic>ne</italic> (&#x0201c;ERG&#x0201d;). Since <italic>NP</italic> is the result category of its parent <italic>mohan</italic> (&#x0201c;Mohan&#x0201d;) on the left, category of <italic>ne</italic> (&#x0201c;ERG&#x0201d;) will be <inline-formula id="IEq31"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M62"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq31.gif"/></alternatives></inline-formula>.<xref ref-type="fn" rid="Fn8">8</xref> Categories of other nodes are assigned similarly.</p><p id="Par45">The algorithm is sketched in Fig.&#x000a0;<xref rid="Fig4" ref-type="fig">4</xref> and an example of a CCG derivation for a simple sentence, marked with chunk tags, is shown in Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3</xref>. NP and S<inline-formula id="IEq32"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$_{f}$$\end{document}</tex-math><mml:math id="M64"><mml:msub><mml:mrow/><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq32.gif"/></alternatives></inline-formula> are the chunk tags for noun and finite verb chunks respectively.<xref ref-type="fn" rid="Fn9">9</xref> Some important special cases are described in detail in the following subsections.<fig id="Fig3"><label>Fig. 3</label><caption><p>An example dependency tree with its CCG derivation</p></caption><graphic xlink:href="10579_2017_9379_Fig3_HTML" id="MO4"/></fig>
<fig id="Fig4"><label>Fig. 4</label><caption><p>Algorithm for extracting a CCG lexicon from a dependency tree</p></caption><graphic xlink:href="10579_2017_9379_Fig4_HTML" id="MO5"/></fig>
</p><p id="Par47">The process described above yields a &#x0201c;coarse-grained&#x0201d; lexicon, in which case is not distinguished. We also created a &#x0201c;fine-grained&#x0201d; lexicon, in which we retain morphological information in noun categories. For example, consider the noun chunk <italic>raam ne</italic> (&#x0201c;Ram ERG&#x0201d;). In the fine-grained lexicon, the CCG categories for <italic>raam</italic> and <italic>ne</italic> are <italic>NP</italic> and <inline-formula id="IEq34"><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[ne]\setminus NP}$$\end{document}</tex-math><mml:math id="M66"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq34.gif"/></alternatives></inline-formula> respectively. Morphological information such as ergative case &#x02018;-ne&#x02019; in noun categories is expected to help with determining their dependency labels, but makes the lexicon more sparse. We therefore extract both a coarse-grained and a fine-grained lexicon; details of the machine-readable format for both lexicons is presented in &#x0201c;<xref rid="Sec24" ref-type="sec">Appendix 3</xref>&#x0201d;.</p><sec id="Sec9"><title>Morphological markers</title><p id="Par48">In Hindi, morphological information is encoded in the form of post-positional markers on nouns, and tense, aspect and modality markers on verbs. A post-positional marker following a noun plays the role of a case-marker (e.g., <italic>raam ne</italic> (&#x0201c;Ram ERG&#x0201d;), here <italic>ne</italic> is the ergative case marker) and a role similar to an English preposition (e.g., <italic>mej par</italic> (&#x0201c;table on&#x0201d;), here <italic>par</italic> is the postpositional equivalent of the English preposition &#x0201c;on&#x0201d;). Post-positional markers on nouns can be simple one word expressions like <italic>ne</italic> or <italic>par</italic>, or multiple words as in <italic>raam ke lie</italic> (&#x0201c;Ram for&#x0201d;). Complex post position markers as a whole give information about how the head noun or verb behaves. For example, <italic>ke lie</italic> is equivalent to &#x0201c;for&#x0201d; and <italic>ke baare me</italic> is equivalent to &#x0201c;about&#x0201d;. The Hindi CCGbank merges complex postpositional markers into single words like <italic>ke_lie</italic> so that the entire marker gets a single CCG category.</p><p id="Par49">For the &#x0201c;fine-grained&#x0201d; lexicon, we explored two variants of the lexicon: normal and type-raised. In the normal version, the ergative case marker like <italic>ne</italic> bears a category <inline-formula id="IEq35"><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[ne]\setminus NP}$$\end{document}</tex-math><mml:math id="M68"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq35.gif"/></alternatives></inline-formula>, looking for an <italic>NP</italic> to the left to yield the case-marked category <italic>NP</italic>[<italic>ne</italic>]. In the type-raised version, the category of <italic>ne</italic> takes an <italic>NP</italic> to its left and creates a category which looks for a VP category <inline-formula id="IEq36"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus NP[ne]}$$\end{document}</tex-math><mml:math id="M70"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq36.gif"/></alternatives></inline-formula>.</p><graphic position="anchor" xlink:href="10579_2017_9379_Figb_HTML" id="MO6"/><p id="Par50">In this variant, the result category <inline-formula id="IEq37"><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S/(S_{f}\setminus NP[ne])}$$\end{document}</tex-math><mml:math id="M72"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq37.gif"/></alternatives></inline-formula> is the full categorial realization of a Hindi ergative cased <italic>NP</italic> for which <italic>NP</italic>[<italic>ne</italic>] is simply a shorthand.</p><p id="Par51">For an adjunct like <italic>raam ke_lie</italic> (&#x0201c;for Ram&#x0201d;) in Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3</xref>, we pass the adjunct information to the post-position marker <italic>ke_lie</italic>, with <italic>NP</italic> as the category for the head noun phrase, and the category <inline-formula id="IEq38"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}/ S_{f})\setminus NP}$$\end{document}</tex-math><mml:math id="M74"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq38.gif"/></alternatives></inline-formula> for the postposition. Adjuncts that modify adjacent adjuncts are assigned identical categories <italic>X</italic>&#x000a0;/&#x000a0;<italic>X</italic> making use of CCG&#x02019;s composition rule and following Cakici (<xref ref-type="bibr" rid="CR20">2005</xref>).</p></sec></sec><sec id="Sec10"><title>CCG lexicon to treebank conversion</title><p id="Par52">Phrase structure to CCG conversion algorithms like Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>) first convert a phrase structure tree into a binary tree. Converting a dependency tree into a binary tree is not possible in the presence of a non-projective arc. For the same reason, direct conversion to CCG trees is not straight-forward. Around 20% of sentences in the Hindi dependency treebank have at least one non-projective arc. In a departure from previous approaches, we therefore use a CCG parser to convert the CCG lexicon to a CCG treebank.</p><p id="Par53">Using the algorithm presented in the previous section, we obtained one CCG category for every word in a sentence. We then run a non-statistical CKY chart parser based on the CCG formalism<xref ref-type="fn" rid="Fn10">10</xref>, which gives CCG derivations based on the lexical categories. This gives multiple derivations for some sentences. We rank these derivations using two criteria. The first criterion is correct recovery of the gold dependencies when the CCG derivation is deterministically mapped back onto a dependency structure. Derivations which lead to gold dependencies are given higher weight. In the second criterion, we prefer derivations which yield intra-chunk dependencies (e.g., verb and auxiliary) prior to inter-chunk (e.g., verb and its arguments). For example, morphological markers (which lead to intra-chunk dependencies) play a crucial role in identifying correct dependencies. Resolving these dependencies first helps the parser in better identification of inter-chunk dependencies such as argument structure of the verb (Ambati <xref ref-type="bibr" rid="CR1">2011</xref>). We thus extract the best derivation for each sentence, which is then included in the Hindi CCGbank.</p><sec id="Sec11"><title>Evaluation</title><p id="Par55">Coverage of the current conversion algorithm, i.e., the number of sentences for which we got at least one complete derivation using this lexicon is 96%. Disabling crossed composition reduced the coverage by around 10%, showing the importance of this rule for a free word-order language with 20% non-projective sentences. The remaining 4% sentences are either cases where there were inconsistent annotations in the original treebank, or constructions which are currently not handled by our conversion algorithm.</p><p id="Par56">As a second method of evaluating the converted Hindi CCG treebank, we obtained dependencies from the CCG treebank and evaluated them against the gold-standard dependencies in the original dependency treebank. We followed the standard category-indexing procedure of Clark and Curran (<xref ref-type="bibr" rid="CR21">2007</xref>) for this purpose in order to obtain dependency labels. For example, <inline-formula id="IEq39"><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S\setminus NP{_1})\setminus NP{_2}}$$\end{document}</tex-math><mml:math id="M76"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq39.gif"/></alternatives></inline-formula> is the indexed version of the category of <inline-formula id="IEq40"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S\setminus NP)\setminus NP}$$\end{document}</tex-math><mml:math id="M78"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq40.gif"/></alternatives></inline-formula>, in which the index 1 marks the subject dependency and 2 marks the object dependency. The indices are not used in the CCG grammar itself, but are important for labeling long-range dependencies in this evaluation.</p><p id="Par57">Following Clark and Curran (<xref ref-type="bibr" rid="CR21">2007</xref>), we manually indexed the CCG categories which occurred at least 10 times in the treebank data. For the rest of the categories, we assigned default indices. The Hindi CCGbank, (which covers 96% of the sentences in the original dependency treebank), correctly captures 99.1% of the dependencies in the dependency treebank, which is the unlabelled recall. Manually providing indices for all categories would give 100% recall but we leave manual annotation of indices for a future version.</p><p id="Par58">In addition, we performed full manual annotation of 165 sentences with their CCG derivations and compared them with the derivations extracted using our automatic conversion algorithm. Our conversion algorithm failed to provide a derivation for two sentences. Out of these two sentences, the original dependency annotation was wrong for one sentence; correcting the annotation helped the algorithm to handle this sentence. The remaining sentence is the case of argument cluster coordination which is not handled in the current version of the Hindi CCGbank. We also extracted dependencies from these CCG derivations and evaluated with the dependencies in the dependency treebank. We could capture 99.7% (unlabelled recall) of the dependencies present in the dependency treebank. The rest are the cases of less frequent CCG categories where the indices were not manually annotated and are incorrect.<fig id="Fig5"><label>Fig. 5</label><caption><p>Sentential coordination</p></caption><graphic xlink:href="10579_2017_9379_Fig5_HTML" id="MO7"/></fig>
</p></sec></sec><sec id="Sec12"><title>Coordination constructions</title><p id="Par59">Coordination is one of the most frequent sources of long distance dependencies in corpora. Coordination in Hindi can occur between similar components, like noun&#x02013;noun coordination and verb-verb coordination, but also between some dissimilar but compatible components, like adjective-noun coordination. In the Hindi dependency treebank, there are several instances where an adjectival chunk (JJP) and a noun chunk (NP) are co-ordinated. All of these are cases where the adjectival chunk has an elided noun which is not present explicitly. One such example is</p><graphic position="anchor" xlink:href="10579_2017_9379_Figc_HTML" id="MO8"/><p id="Par60">In this example, the coordination is between the adjectival chunk <italic>saamajik</italic> (&#x0201c;social&#x0201d;) and the noun chunk <italic>sikhsha ke</italic> (&#x0201c;education&#x0201d;). The adjectival chunk <italic>saamajik</italic> (&#x0201c;social&#x0201d;) has an elided noun <italic>sthithi</italic> (&#x0201c;status&#x0201d;). When the noun is explicitly present as in <italic>saamajik sthithi</italic> (&#x0201c;social status&#x0201d;) then it is annotated as a noun chunk in the original treebank. But when the noun is not present explicitly, as in <italic>saamajik</italic> (&#x0201c;social&#x0201d;), it is annotated as an adjectival chunk. One can argue for a different annotation scheme and annotate such adjectival chunks as noun chunks. But, for now, to handle these cases, we allowed co-ordination between dissimilar but compatible chunks.</p><p id="Par61">The CCG category of a conjunction is <inline-formula id="IEq41"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(X\setminus X)/ X}$$\end{document}</tex-math><mml:math id="M80"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq41.gif"/></alternatives></inline-formula>, where a conjunction looks for a child of type <italic>X</italic> to its right and then a child to its left of the same type <italic>X</italic> to yield a result of the same type <italic>X</italic>. Figure&#x000a0;<xref rid="Fig5" ref-type="fig">5</xref> gives the dependency tree and CCG derivation for an example sentence with sentential (S) coordination. In the Hindi CCGbank, it is the supertagger that identifies the correct instantiation of the type <italic>X</italic> for the conjunction.<xref ref-type="fn" rid="Fn11">11</xref>
</p><p id="Par63">There are four major types of coordination constructions in Hindi. In this section, we first describe each type with an example sentence and then explain how CCG handles them.</p><p id="Par64">
<bold>Type 1</bold> (Conjunction with two children): The CCG category of the conjunction is <inline-formula id="IEq42"><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(X\setminus X)/ X}$$\end{document}</tex-math><mml:math id="M82"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq42.gif"/></alternatives></inline-formula> where <italic>X</italic> depends on the category of the conjuncts. The example given below in Fig.&#x000a0;<xref rid="Fig6" ref-type="fig">6</xref>, <italic>raam ora shyam skool gaye</italic> (&#x0201c;Ram and Shyam went to school&#x0201d;), is the case of noun-phrase (NP) coordination. Conjunct <italic>ora</italic> (&#x0201c;and&#x0201d;) has two noun phrases <italic>raam</italic> (&#x0201c;Ram&#x0201d;) and <italic>shyam</italic> (&#x0201c;Shyam&#x0201d;) as its children. Hence the category of <italic>ora</italic> (&#x0201c;and&#x0201d;) is <inline-formula id="IEq43"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(NP\setminus NP)/ NP}$$\end{document}</tex-math><mml:math id="M84"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq43.gif"/></alternatives></inline-formula>. <italic>ora</italic> (&#x0201c;and&#x0201d;) is first combined with the right child <italic>shyam</italic> and then combined with the left child <italic>raam</italic> leading to a noun phrase, which becomes the subject argument for the verb <italic>gaye</italic> (&#x0201c;went&#x0201d;).<fig id="Fig6"><label>Fig. 6</label><caption><p>Type 1 coordination</p></caption><graphic xlink:href="10579_2017_9379_Fig6_HTML" id="MO9"/></fig>
</p><p id="Par65">
<bold>Type 2</bold> (Conjunction with more than two children and not separated by commas): In Hindi, sometimes a conjunction can have more than two children which are not separated by commas. In such cases, CCG category of the node is type-changed from <italic>X</italic> to a category <inline-formula id="IEq44"><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(X\setminus X)/ (X\setminus X)}$$\end{document}</tex-math><mml:math id="M86"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq44.gif"/></alternatives></inline-formula>. Figure&#x000a0;<xref rid="Fig7" ref-type="fig">7</xref> shows the dependency tree of an example sentence <italic>raam shyam ora sita skool gaye</italic> (&#x0201c;Ram Shyam and Sita went to school&#x0201d;). In this example, the conjunct <italic>ora</italic> (&#x0201c;and&#x0201d;) has three children <italic>raam</italic> (&#x0201c;Ram&#x0201d;), <italic>shyam</italic> (&#x0201c;Shyam&#x0201d;) and <italic>sita</italic> (&#x0201c;Sita&#x0201d;). CCG category of <italic>shyam</italic> is type-changed from <italic>NP</italic> to <inline-formula id="IEq45"><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(NP\setminus NP)/ (NP\setminus NP)}$$\end{document}</tex-math><mml:math id="M88"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq45.gif"/></alternatives></inline-formula> so that it can combine with <italic>ora</italic> and then with <italic>raam</italic> to form an <italic>NP</italic>.<fig id="Fig7"><label>Fig. 7</label><caption><p>Type 2 coordination</p></caption><graphic xlink:href="10579_2017_9379_Fig7_HTML" id="MO10"/></fig>
</p><p id="Par66">
<bold>Type 3</bold> (Conjunction with more than two children separated by commas): The example sentence given below in Fig.&#x000a0;<xref rid="Fig8" ref-type="fig">8</xref>, <italic>raam , shyam ora sita skool gaye</italic> (&#x0201c;Ram, Shyam and Sita went to school&#x0201d;), is the same as the one presented above in Type 2 category. The only difference is that there is a comma between the nouns <italic>raam</italic> (&#x0201c;Ram&#x0201d;) and <italic>shyam</italic> (&#x0201c;Shyam&#x0201d;). The comma gets a CCG category , which is combined with <italic>NP</italic> to form an <italic>NP</italic>. Similar to Type 2, the CCG category of <italic>shyam</italic> is type-changed from <italic>NP</italic> to <inline-formula id="IEq46"><alternatives><tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(NP\setminus NP)/ (NP\setminus NP)}$$\end{document}</tex-math><mml:math id="M90"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq46.gif"/></alternatives></inline-formula>. This allows <italic>shyam</italic> to combine with <italic>ora</italic> and then with <italic>raam</italic> to form an <italic>NP</italic>.</p><p id="Par67">Unlike other CCGbanks which treat comma as a conjunction, we treat comma as a punctuation here. In that way, we don&#x02019;t have to change the dependency tree. If we treat a comma as a conjunction, then we have to change the dependency tree as well, where <italic>ora</italic> (&#x0201c;and&#x0201d;) will have comma and <italic>sita</italic> as children and comma will have <italic>raam</italic> and <italic>shyam</italic> as children. Also, since comma can be missing as in Type 2, treating the comma as a punctuation leads to having a single analysis irrespective of whether a comma is present or not.<fig id="Fig8"><label>Fig. 8</label><caption><p>Type 3 coordination</p></caption><graphic xlink:href="10579_2017_9379_Fig8_HTML" id="MO11"/></fig>
<fig id="Fig9"><label>Fig. 9</label><caption><p>Type 4 coordination</p></caption><graphic xlink:href="10579_2017_9379_Fig9_HTML" id="MO12"/></fig>
</p><p id="Par68">
<bold>Type 4</bold> (Argument cluster coordination): Fig.&#x000a0;<xref rid="Fig9" ref-type="fig">9</xref> presents an example sentence for argument cluster coordination, <italic>raam ne seb ora sita ne aam khaaya</italic> (&#x0201c;Ram ate an apple and Sita ate a mango&#x0201d;). <italic>khaaya</italic> (&#x0201c;ate&#x0201d;) is the shared verb for both the co-ordinates. To handle such constructions, the dependency tree introduces a dummy &#x0201c;NULL&#x0201d; node which is co-indexed with the main verb <italic>khaaya</italic> and acts as the verb for the 1st sentence as shown in the dependency tree in Fig.&#x000a0;<xref rid="Fig9" ref-type="fig">9</xref>. CCG can handle such constructions without introducing NULL nodes. The subject <italic>raam ne</italic> is type-raised from <italic>NP</italic> to a category which looks for an intransitive verb, <inline-formula id="IEq47"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}/ (S_{f}\setminus NP)}$$\end{document}</tex-math><mml:math id="M92"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq47.gif"/></alternatives></inline-formula>. Similarly, the object <italic>seb</italic> (&#x0201c;apple&#x0201d;) is type-raised from <italic>NP</italic> to a category which looks for a transitive verb, <inline-formula id="IEq48"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}\setminus NP)/ TV}$$\end{document}</tex-math><mml:math id="M94"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>T</mml:mi><mml:mi>V</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq48.gif"/></alternatives></inline-formula>.<xref ref-type="fn" rid="Fn12">12</xref> Now, these two nodes are combined leading to <inline-formula id="IEq50"><alternatives><tex-math id="M95">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}/ TV}$$\end{document}</tex-math><mml:math id="M96"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mi>T</mml:mi><mml:mi>V</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq50.gif"/></alternatives></inline-formula> which takes a transitive verb and forms a sentence. Similarly, subject and object arguments of the second sentence, <italic>sita ne</italic> (&#x0201c;Sita&#x0201d;) and <italic>aam</italic> (&#x0201c;Mango&#x0201d;) are type-raised and combined. Now, these type-raised arguments are combined using the conjunction <italic>ora</italic> (&#x0201c;and&#x0201d;) which is then combined with the main verb <italic>khaaya</italic> to form a sentence.<xref ref-type="fn" rid="Fn13">13</xref>
</p></sec><sec id="Sec13"><title>&#x0201c;Non-projective&#x0201d; constructions</title><p id="Par71">In the tradition of dependency grammar (Hays <xref ref-type="bibr" rid="CR23">1964</xref>), constructions which induce dependency arcs which cross as in Fig.&#x000a0;<xref rid="Fig10" ref-type="fig">10</xref> are referred to as &#x0201c;non-projective&#x0201d;, because they cannot be generated by the core context-free dependency grammar, and are generally supposed to arise from some separate component of the grammar, such as transformational rules (Robinson <xref ref-type="bibr" rid="CR53">1970</xref>).<fig id="Fig10"><label>Fig. 10</label><caption><p>A dependency tree with a &#x0201c;non-projective&#x0201d; dependency</p></caption><graphic xlink:href="10579_2017_9379_Fig10_HTML" id="MO13"/></fig>
</p><p id="Par72">Such dependencies arise in all languages from processes like relativization and various instances of coordination reduction. To call them &#x0201c;non-projective&#x0201d; is confusing in the present context, since the central claim of CCG is that <italic>all</italic> dependencies are projective, in the sense of arising directly from near-context free syntactic projection. In the dependency parsing literature techniques like swap action (Nivre <xref ref-type="bibr" rid="CR47">2009</xref>) or pseudo-projective parsing algorithm (Nivre and Nilsson <xref ref-type="bibr" rid="CR48">2005</xref>) are used to handle these crossing arcs. In case of CCG, we can extract such crossing dependencies using indexed categories.<xref ref-type="fn" rid="Fn14">14</xref> Section&#x000a0;<xref rid="Sec16" ref-type="sec">8.3</xref> provides an example derivation showing how indexed categories can be used to extract crossing dependencies. In this section, we present different constructions and/or dependency labels which lead to crossing arcs in the dependency treebank, and explain how CCG can be made to handle them projectively.</p><p id="Par74">Because Hindi has a comparatively free word-order, crossing dependencies are more frequent in the Hindi dependency treebank than in comparable English data. There are a total of 20% sentences with non-projective arcs in the Hindi dependency treebank, amounting to 1.1% of total arcs. There is some previous work on analyzing different non-projective constructions in Hindi and other Indian languages (Mannem et&#x000a0;al. <xref ref-type="bibr" rid="CR41">2009</xref>; Bhat and Sharma <xref ref-type="bibr" rid="CR14">2012</xref>). We categorize the non-projective constructions in the Hindi dependency treebank based on this previous work. Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref> shows the distribution of non-projective arcs across different constructions.<table-wrap id="Tab1"><label>Table 1</label><caption><p>Distribution of different non-projective constructions in the treebank</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Type of construction</th><th align="left">Percentage (%)</th></tr></thead><tbody><tr><td align="left">Clausal complements</td><td char="." align="char">32.4</td></tr><tr><td align="left">Relative clause constructions</td><td char="." align="char">19.7</td></tr><tr><td align="left">Topicalization</td><td char="." align="char">15.3</td></tr><tr><td align="left">Genitives and dislocated/discontinuous genitives</td><td char="." align="char">12.8</td></tr><tr><td align="left">Paired connectives</td><td char="." align="char">10.5</td></tr><tr><td align="left">Others</td><td char="." align="char">9.3</td></tr></tbody></table></table-wrap>
</p><p id="Par75">In the following sections, we discuss different constructions which lead to crossing arcs in the dependency treebank, and explain how CCG can be made to handle them projectively. In this process, we modified the original dependency tree in two cases: (a) when the original annotation is wrong and (b) in the presence of extraposed clauses. We provide details in the respective sections.</p><sec id="Sec14"><title>Clausal complements</title><p id="Par76">Clausal complements of NP forming a complex NP are the cases where clauses elaborate on a noun/pronoun. These are annotated with the CCOM dependency label. For example, in the sentence given below in Fig.&#x000a0;<xref rid="Fig11" ref-type="fig">11</xref>, <italic>baat</italic> (&#x0201c;fact&#x0201d;) is the subject (&#x0201c;SUBJ&#x0201d;) and <italic>yaha</italic> (&#x0201c;this&#x0201d;) is its noun complement (&#x0201c;SCOM&#x0201d;), which are attached to the verb. Whereas the clause <italic>ki vo kal aayegaa</italic> (&#x0201c;that he will come tomorrow&#x0201d;) has a dependency relation with <italic>yaha</italic> (&#x0201c;this&#x0201d;) and is denoted by CCOM dependency label. 32% of crossing arcs in the treebank are due to this construction.</p><p id="Par77">There are two options to handle this case. In the first option we don&#x02019;t change the dependency tree. Since <italic>ki</italic> (&#x0201c;that&#x0201d;) is a subordinate conjunction, its chunk tag is CCP. As it looks for a clause/sentence to its right, CCG category for <italic>ki</italic> (&#x0201c;that&#x0201d;) will be <inline-formula id="IEq51"><alternatives><tex-math id="M97">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${CCP/ S_{f}}$$\end{document}</tex-math><mml:math id="M98"><mml:mrow><mml:mi>C</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq51.gif"/></alternatives></inline-formula>. This gives <italic>yaha</italic> (&#x0201c;this&#x0201d;) a CCG category of <italic>NP</italic>&#x000a0;/&#x000a0;<italic>CCP</italic>, since the result category of its child <italic>ki</italic> (&#x0201c;that&#x0201d;) is <italic>CCP</italic>. We can combine <italic>yaha</italic> (&#x0201c;this&#x0201d;) and <italic>hai</italic> (&#x0201c;is&#x0201d;) using Backward Crossing Composition (<inline-formula id="IEq52"><alternatives><tex-math id="M99">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${&#x0003c;}B_{\times }$$\end{document}</tex-math><mml:math id="M100"><mml:mrow><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mo>&#x000d7;</mml:mo></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq52.gif"/></alternatives></inline-formula>) which can then be combined with <italic>ki</italic> (&#x0201c;that&#x0201d;) to establish the crossing dependency. Figure&#x000a0;<xref rid="Fig11" ref-type="fig">11</xref> gives the CCG derivation for this example.<fig id="Fig11"><label>Fig. 11</label><caption><p>CCOM: CCG derivation (original dependency tree)</p></caption><graphic xlink:href="10579_2017_9379_Fig11_HTML" id="MO14"/></fig>
</p><p id="Par78">Another option is to systematically change the dependency trees concerned to reflect an analysis in terms of extraposition, where <italic>ki vo kal aayegaa</italic> (&#x0201c;that he will come tomorrow&#x0201d;&#x02019;) is syntactically a sentential adjunct, and the complement is only linked to its head <italic>baath</italic> (&#x0201c;(the) fact&#x0201d;&#x02019;) by anaphora at the level of logical form. As a result, the complementizer <italic>ki</italic> is assigned the category <inline-formula id="IEq53"><alternatives><tex-math id="M101">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(\mathtt{S}_{f}\setminus \mathtt{S}_{f})/\mathtt{S}_{f}$$\end{document}</tex-math><mml:math id="M102"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="monospace">S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:msub><mml:mi mathvariant="monospace">S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi mathvariant="monospace">S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq53.gif"/></alternatives></inline-formula>, which will first combine with the clause to its right <italic>vo kal aayegaa</italic>, and then with the clause to its left <italic>baat yaha hai</italic>, resulting in the derivation shown below in Fig.&#x000a0;<xref rid="Fig12" ref-type="fig">12</xref>. For the CCGbank conversion, we followed this option and modified the dependency tree so that the CCG derivation is consistent with other extraposed constructions.<xref ref-type="fn" rid="Fn15">15</xref> We return to the question of extraposition at a number of points below.<fig id="Fig12"><label>Fig. 12</label><caption><p>CCOM: CCG derivation (modified dependency tree)</p></caption><graphic xlink:href="10579_2017_9379_Fig12_HTML" id="MO15"/></fig>
</p></sec><sec id="Sec15"><title>Relative clause constructions</title><p id="Par80">Relative clauses are the second major type of constructions which lead to crossing dependency arcs in the original treebank. 20% of such arcs in the data are due to relative clauses. In the original English CCGbank, relative clauses have the category type <inline-formula id="IEq54"><alternatives><tex-math id="M103">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M104"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq54.gif"/></alternatives></inline-formula>, where they combine with a noun phrase on the left to give a resulting noun phrase. Hindi has relative clauses of the type <inline-formula id="IEq55"><alternatives><tex-math id="M105">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M106"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq55.gif"/></alternatives></inline-formula> or <italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic> based on the position of the relative clause with respect to the head noun.</p><p id="Par81">For instance, for the example sentence in Fig.&#x000a0;<xref rid="Fig13" ref-type="fig">13</xref>, the relative clause has <inline-formula id="IEq56"><alternatives><tex-math id="M107">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M108"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq56.gif"/></alternatives></inline-formula> as its CCG category, since it is to the right of the head noun. Whereas in Fig.&#x000a0;<xref rid="Fig14" ref-type="fig">14</xref>, the category of the relative clause is <italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic> since it is to the left of the head noun. Similar to English, in Hindi also, we pass down this information to the relative pronoun rather than the main verb of the relative clause. As a result, the relative pronoun will have a CCG category of (<italic>NP</italic>|<italic>NP</italic>)|<italic>X</italic> where the directionality depends on the position of the relative pronoun in the clause and the category <italic>X</italic> depends on the grammatical role of the relative pronoun.</p><p id="Par82">
<bold>Embedded</bold> This is a simple case of relative clause where the relative clause is to the right of its head noun. Mahajan (<xref ref-type="bibr" rid="CR40">2000</xref>) calls this relative construction as &#x0201c;Normal&#x0201d; since it is similar to the English relative clause construction. This type of relative clause doesn&#x02019;t lead to crossing dependency arcs. Figure&#x000a0;<xref rid="Fig13" ref-type="fig">13</xref> gives an example sentence, <italic>vo ladakaa jo khadaa hai raam hai</italic> (&#x0201c;The boy who is standing is Ram&#x0201d;) with its dependency tree and corresponding CCG derivation.<xref ref-type="fn" rid="Fn16">16</xref> The relative clause is marked within the brackets in the following figure. In this example, the category of the relative pronoun <italic>jo</italic> (&#x0201c;who&#x0201d;) is <inline-formula id="IEq57"><alternatives><tex-math id="M109">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(NP\setminus NP)/ (S_{f}\setminus NP)}$$\end{document}</tex-math><mml:math id="M110"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq57.gif"/></alternatives></inline-formula> which is similar to English relative pronouns. The relative pronoun <italic>jo</italic> (&#x0201c;who&#x0201d;) first combines with the verb phrase <italic>khadaa hai</italic> (&#x0201c;is standing&#x0201d;) to form a relative clause with category <inline-formula id="IEq58"><alternatives><tex-math id="M111">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M112"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq58.gif"/></alternatives></inline-formula>. The relative clause then combines with its head noun phrase <italic>vo ladakaa</italic> (&#x0201c;that boy&#x0201d;) which is then combined with the main verb phrase to form a sentence <inline-formula id="IEq59"><alternatives><tex-math id="M113">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_{f}$$\end{document}</tex-math><mml:math id="M114"><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq59.gif"/></alternatives></inline-formula>.<fig id="Fig13"><label>Fig. 13</label><caption><p>Embedded relative clause</p></caption><graphic xlink:href="10579_2017_9379_Fig13_HTML" id="MO16"/></fig>
</p><p id="Par84">
<bold>Correlative</bold> In Hindi, a relative clause can occur to the left of the head noun as well, which is the most frequent form of the construction. This type of relative clause also doesn&#x02019;t lead to crossing dependency arcs. Figure&#x000a0;<xref rid="Fig14" ref-type="fig">14</xref> gives the dependency tree and corresponding CCG derivation for an example sentence, <italic>jo ladakaa khadaa hai vah raam hai</italic> (&#x0201c;The boy who is standing is Ram&#x0201d;). In this example, as the relative pronoun <italic>jo</italic> (&#x0201c;who&#x0201d;) occurs as a demonstrative its category is <inline-formula id="IEq60"><alternatives><tex-math id="M115">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${((NP/ NP)/ (S_{f}\setminus NP))/ NP}$$\end{document}</tex-math><mml:math id="M116"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq60.gif"/></alternatives></inline-formula>. The relative pronoun <italic>jo</italic> (&#x0201c;who&#x0201d;) combines with its head noun <italic>ladakaa</italic> (&#x0201c;boy&#x0201d;) which is then combined with the verb phrase leading to the category of relative clause <italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>. Since the relative clause is to the left of the head noun, its category is <italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic> rather than <inline-formula id="IEq61"><alternatives><tex-math id="M117">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M118"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq61.gif"/></alternatives></inline-formula> which we saw in the previous embedded relative clause.<fig id="Fig14"><label>Fig. 14</label><caption><p>Correlative relative clause</p></caption><graphic xlink:href="10579_2017_9379_Fig14_HTML" id="MO17"/></fig>
<fig id="Fig15"><label>Fig. 15</label><caption><p>Extraposed relative clause (Example 1): original dependency tree</p></caption><graphic xlink:href="10579_2017_9379_Fig15_HTML" id="MO18"/></fig>
<fig id="Fig16"><label>Fig. 16</label><caption><p>Extraposed relative clause (Example 1): modified dependency tree</p></caption><graphic xlink:href="10579_2017_9379_Fig16_HTML" id="MO19"/></fig>
<fig id="Fig17"><label>Fig. 17</label><caption><p>Extraposed relative clause (Example 2)</p></caption><graphic xlink:href="10579_2017_9379_Fig17_HTML" id="MO20"/></fig>
</p><p id="Par85">
<bold>Extraposed</bold> Unlike the previous two cases of embedded and correlative constructions where the relative clause is next to the head noun, Hindi, like English, has constructions where the relative clause is not next to its head noun. Figure&#x000a0;<xref rid="Fig15" ref-type="fig">15</xref> shows one such example sentence <italic>vah ladakaa raam hai jo khadaa hai</italic> (&#x0201c;That boy is Ram who is standing&#x0201d;). This type of construction lead to a crossing dependency arc. We can&#x02019;t extract a CCG derivation with the original dependency. Extraposed dependencies are treated anaphorically in CCG, in the semantics, with the extraposed clause treated syntactically as a sentential adjunct. So, to handle this construction, we change the dependency tree slightly. Instead of the relative clause modifying the head noun, we make it modify the main verb. As a result the relative pronoun will have a CCG category of (<italic>S</italic>|<italic>S</italic>)|<italic>X</italic> instead of (<italic>NP</italic>|<italic>NP</italic>)|<italic>X</italic>. Changing the dependency tree is linguistically justified to the extent that extraposed dependencies are generally regarded as not being purely syntactically mediated. Since this is a case of extraposed/dislocated relative clause, the category of relative clause is <italic>S</italic>|<italic>S</italic> rather than <italic>NP</italic>|<italic>NP</italic>. Figure&#x000a0;<xref rid="Fig16" ref-type="fig">16</xref> shows the modified dependency tree with corresponding CCG derivation. The problematic RELC arc dependent on the noun <italic>ladakaa</italic> in Fig.&#x000a0;<xref rid="Fig15" ref-type="fig">15</xref> is replaced by an arc with the same label dependent on the main verb in Fig.&#x000a0;<xref rid="Fig16" ref-type="fig">16</xref>. Note that it is easy to recover the dependency between the relative clause and its head noun, as the head noun chunk will have a word whose root is <italic>vo</italic> (&#x0201c;that&#x0201d;).<xref ref-type="fn" rid="Fn17">17</xref>
</p><p id="Par87">Figure&#x000a0;<xref rid="Fig17" ref-type="fig">17</xref> presents another example sentence which is similar to Fig.&#x000a0;<xref rid="Fig15" ref-type="fig">15</xref>, except that the relative pronoun is not at the starting of the relative clause and it is also not the mandatory argument of the verb of relative clause. Here, the relative pronoun <italic>jaisaa</italic> (&#x0201c;like-what&#x0201d;) is neither at the beginning of the clause nor a mandatory argument. It is an adverbial modifier (ADV) for the verb <italic>kahaa</italic> (&#x0201c;said&#x0201d;). As a result, the relative pronoun <italic>jaisaa</italic> will have a CCG category <inline-formula id="IEq62"><alternatives><tex-math id="M119">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}/ S_{f})/ S_{f}}$$\end{document}</tex-math><mml:math id="M120"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq62.gif"/></alternatives></inline-formula>. <italic>jaisaa</italic> is combined with the verb <italic>kahaa</italic> (&#x0201c;said&#x0201d;) using forward crossed composition (<inline-formula id="IEq63"><alternatives><tex-math id="M121">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${B_\times }$$\end{document}</tex-math><mml:math id="M122"><mml:msub><mml:mi>B</mml:mi><mml:mo>&#x000d7;</mml:mo></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq63.gif"/></alternatives></inline-formula>) which leads to a category of <inline-formula id="IEq64"><alternatives><tex-math id="M123">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}/ S_{f}}$$\end{document}</tex-math><mml:math id="M124"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq64.gif"/></alternatives></inline-formula> for the relative clause in the end. Similar to the previous example, this is a case of extraposed relative clause.</p></sec><sec id="Sec16"><title>Topicalization</title><p id="Par88">The node which is the object/patient of the verb is marked with OBJ dependency label. Topicalization of the object/patient of the verb is the cause for 11.3% of crossing dependency arcs in the treebank.</p><p id="Par89">Figure&#x000a0;<xref rid="Fig18" ref-type="fig">18</xref> presents an example sentence where a crossing arc is created due to a topicalised object (OBJ) relation. In the example sentence, <italic>khaanaa raam khaakar dukaan gayaa</italic> (&#x0201c;Ram after eating food went to the shop&#x0201d;), there are two verbs: <italic>khaakar</italic> (&#x0201c;having-eaten&#x0201d;), a non-finite verb and <italic>gayaa</italic> (&#x0201c;went&#x0201d;), a finite verb. <italic>raam</italic> (&#x0201c;Ram&#x0201d;) is the shared subject (SUBJ) of both the verbs. As per Hindi dependency guidelines, <italic>raam</italic> cannot have two parents. So it is marked as SUBJ of the main verb <italic>gayaa</italic> (&#x0201c;went&#x0201d;). If the subject, <italic>raam</italic>, was at the start of the sentence then the sentence would be <italic>raam khaanaa khaakar dukaan gayaa</italic>, which is the most frequent construction. Then it would not have created the crossing arc. Shared subject <italic>raam</italic> appearing within non-finite verb phrase <italic>khaanaa khaakar</italic> (&#x0201c;having eaten food&#x0201d;), although grammatical, is not very common in the treebank as compared to the topicalised variant, which is more frequent.</p><p id="Par90">To handle these types of constructions, we relax the constraint of a node having multiple parents. <italic>raam</italic> is subject of both the verbs: <italic>khaakar</italic> (&#x0201c;having eaten&#x0201d;) and <italic>gayaa</italic> (&#x0201c;went&#x0201d;). But due to the tree constraint, the subject <italic>raam</italic> cannot have two parents. We let the CCG derivation have <italic>raam</italic> as the subject for both the verbs. As a result, <italic>khaakar</italic> will have the CCG category <inline-formula id="IEq65"><alternatives><tex-math id="M125">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${((S_{f}/ (S_{f}\setminus NP{_2}))\setminus NP{_1})\setminus NP{_2}}$$\end{document}</tex-math><mml:math id="M126"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq65.gif"/></alternatives></inline-formula>.<xref ref-type="fn" rid="Fn18">18</xref> The first part of the category, <inline-formula id="IEq66"><alternatives><tex-math id="M127">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}/ (S_{f}\setminus NP{_2}))}$$\end{document}</tex-math><mml:math id="M128"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq66.gif"/></alternatives></inline-formula>, captures the information that it is a verbal modifier which shares an argument with the main verb. <italic>khaakar</italic> (&#x0201c;having-eaten&#x0201d;) first combines with <italic>raam</italic> and then with <italic>khaanaa</italic> (&#x0201c;food&#x0201d;) to form <inline-formula id="IEq67"><alternatives><tex-math id="M129">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}/ (S_{f}\setminus NP{_2})}$$\end{document}</tex-math><mml:math id="M130"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mrow/><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq67.gif"/></alternatives></inline-formula>. This is then combined with the VP <italic>dukaan gayaa</italic> (&#x0201c;went to shop&#x0201d;) resulting in a sentence <inline-formula id="IEq68"><alternatives><tex-math id="M131">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}}$$\end{document}</tex-math><mml:math id="M132"><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq68.gif"/></alternatives></inline-formula>. Note that <italic>gayaa</italic> and <italic>raam</italic> are never combined directly in the derivation. But this dependency is resolved using the indices.<fig id="Fig18"><label>Fig. 18</label><caption><p>Topicalization</p></caption><graphic xlink:href="10579_2017_9379_Fig18_HTML" id="MO21"/></fig>
</p></sec><sec id="Sec17"><title>Paired connectives</title><p id="Par92">Paired connectives such as <italic>agar-to</italic> (&#x0201c;if&#x02013;then&#x0201d;) are the cause for 10.5% of crossing dependency arcs in the treebank. These constructions involve VMOD, verbal modifier, dependency label. Any verbal modifier which cannot be categorised as a specific relation like subject (SUBJ), object (OBJ) etc. is marked by a VMOD relation.</p><p id="Par93">
<bold>Original Annotation</bold> Figure&#x000a0;<xref rid="Fig19" ref-type="fig">19</xref> presents an example &#x02018;if-then&#x02019; construction. In the original dependency tree for this sentence, <italic>agar unhone muh kholaa to wo unhe maar daalegaa</italic> (&#x0201c;If they opened their mouth then he will kill them&#x0201d;), <italic>to</italic> (&#x0201c;then&#x0201d;) is the ROOT of the sentence. <italic>maar</italic> (&#x0201c;kill&#x0201d;) is the child of <italic>tho</italic> (&#x0201c;then&#x0201d;) with the dependency relation COORD. <italic>agar</italic> (&#x0201c;if&#x0201d;) is the child of <italic>maar</italic> (&#x0201c;kill&#x0201d;) with dependency relation VMOD and <italic>kholaa</italic> (&#x0201c;opened&#x0201d;) is the child of <italic>agar</italic> (&#x0201c;if&#x0201d;) with dependency relation COORD. VMOD relation between <italic>maar</italic> (&#x0201c;kill&#x0201d;) and <italic>agar</italic> (&#x0201c;if&#x0201d;) leads to a crossing dependency arc here.<fig id="Fig19"><label>Fig. 19</label><caption><p>Paired connectives: original dependency tree</p></caption><graphic xlink:href="10579_2017_9379_Fig19_HTML" id="MO22"/></fig>
</p><p id="Par94">
<bold>Modified Annotation</bold> We modified the dependency tree to handle this construction since the original dependency annotation is wrong. In the modified tree, <italic>to</italic> (&#x0201c;then&#x0201d;) is still the ROOT of the sentence. Both the verbs <italic>maar</italic> (&#x0201c;kill&#x0201d;) and <italic>kholaa</italic> (&#x0201c;opened&#x0201d;) are children of <italic>to</italic> (&#x0201c;then&#x0201d;) with a COORD dependency relation. <italic>agara</italic> (&#x0201c;if&#x0201d;) is the child of <italic>kholaa</italic> (&#x0201c;opens&#x0201d;) with the dependency relation VMOD.<fig id="Fig20"><label>Fig. 20</label><caption><p>Paired connectives: modified dependency tree and corresponding CCG derivation</p></caption><graphic xlink:href="10579_2017_9379_Fig20_HTML" id="MO23"/></fig>
</p><p id="Par95">In the case of English if-then constructions, the CCG category of <italic>if</italic> is (<italic>S</italic>&#x000a0;/&#x000a0;<italic>S</italic>)&#x000a0;/&#x000a0;<italic>S</italic>[<italic>dcl</italic>] which consumes a sentence to its right, leading to an <italic>S</italic>&#x000a0;/&#x000a0;<italic>S</italic> category for the if-clause. It then consumes the then-clause leading to <italic>S</italic> category. But in the case of Hindi <italic>agar</italic> (&#x0201c;if&#x0201d;) can be optional. To capture this phenomenon, we make the category of <italic>tho</italic> (&#x0201c;then&#x0201d;) to demand <italic>agar</italic> (&#x0201c;if&#x0201d;) clause rather than the opposite. So, the CCG category of <italic>to</italic> (&#x0201c;then&#x0201d;) is <inline-formula id="IEq69"><alternatives><tex-math id="M133">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}\setminus S_{f})/ S_{f}}$$\end{document}</tex-math><mml:math id="M134"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq69.gif"/></alternatives></inline-formula> which consumes a sentence to its right forming a then-clause with the category <inline-formula id="IEq70"><alternatives><tex-math id="M135">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus S_{f}}$$\end{document}</tex-math><mml:math id="M136"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq70.gif"/></alternatives></inline-formula>. It then combines with a sentence to its left which is the if-clause leading to <inline-formula id="IEq71"><alternatives><tex-math id="M137">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}}$$\end{document}</tex-math><mml:math id="M138"><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq71.gif"/></alternatives></inline-formula>. Also, as <italic>agar</italic> (&#x0201c;if&#x0201d;) is optional it takes an adjunct category making the main verb the head of the clause. Figure&#x000a0;<xref rid="Fig20" ref-type="fig">20</xref> shows the modified dependency tree with the corresponding CCG derivation.</p></sec><sec id="Sec18"><title>Genitives and dislocated/discontinuous genitives</title><p id="Par96">The genitive/possessive relation which holds between two nouns is marked by GEN dependency label. It mostly occurs with &#x02018;kaa&#x02019; (masc.) or &#x02018;kii&#x02019; (fem.) postposition marker. A reliable cue for its identification is that the postposition agrees with the noun it modifies in number and gender. In the majority of cases the nouns in genitive relation are next to each other. But, in some cases, due to the free word-order nature of Hindi, some other word can occur between the two nouns in a genitive relation as in the following example in Fig.&#x000a0;<xref rid="Fig21" ref-type="fig">21</xref>. This construction is the source of 7.5% of the crossing arcs in the the dependency treebank.<fig id="Fig21"><label>Fig. 21</label><caption><p>Genitive construction</p></caption><graphic xlink:href="10579_2017_9379_Fig21_HTML" id="MO24"/></fig>
</p><p id="Par97">In the example in Fig.&#x000a0;<xref rid="Fig21" ref-type="fig">21</xref>, <italic>maine uskaa mumbai mai kiraayaa dediyaa</italic> (&#x0201c;I have given his rent in Mumbai&#x0201d;), <italic>uskaa</italic> (&#x0201c;his&#x0201d;) and <italic>kiraayaa</italic> (&#x0201c;rent&#x0201d;) are in genitive relation. But, <italic>mumbai mai</italic> (&#x0201c;in Mumbai&#x0201d;) is between these two nouns leading to a crossing arc. Though the dependency labels are different, the construction is similar to the ones described in Sect.&#x000a0;<xref rid="Sec18" ref-type="sec">8.5</xref>. When two nouns are in a genitive relation, if the both the nouns are next to each other we make the noun with genitive marker demand a noun to its right similar to genitive cases in other languages. But, if both the nouns in genitive relation are not next to each other, then we make the head noun demand the noun with genitive marker as in Fig.&#x000a0;<xref rid="Fig21" ref-type="fig">21</xref>. In this way, we can capture this unusual word ordering elegantly in CCG.</p><p id="Par98">Hindi also has extensive use of &#x0201c;light&#x0201d; verbs, also called conjunct verbs. A conjunct verb is composed of a noun or an adjective followed by a verbalizer. Subject (SUBJ) or Object (OBJ) arguments of a conjunct verb can have the genitive case marker. In such cases, the arguments have a dependency relation with the noun of the conjunct verb since the agreement is with the noun of the conjunct verb and not with the verb. The free word-order nature of adverbs and time and/or place expressions can cause crossing arcs as in the following examples. Such constructions are called dislocated/discontinuous genitives. We treat Part-OF (POF) and subject/object of conjunct verb (CSUBJ/COBJ) as arguments. For example, in Fig.&#x000a0;<xref rid="Fig22" ref-type="fig">22</xref>, the light verb <italic>hua</italic> (&#x0201c;happened&#x0201d;) looks for an <italic>NP</italic>, <italic>udhghaatana</italic> (&#x0201c;inauguration&#x0201d;) to its left. <italic>udhghaatana</italic> has a child <italic>mandir kaa</italic> (&#x0201c;of temple&#x0201d;) with CSUBJ dependency relation. Since CSUBJ is an argument relation, CCG category of <italic>udhghaatana</italic> is <inline-formula id="IEq72"><alternatives><tex-math id="M139">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP_{gen}}$$\end{document}</tex-math><mml:math id="M140"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq72.gif"/></alternatives></inline-formula> which looks for an <italic>NP</italic> with genitive marker to its left. <italic>udhghaatana</italic> first combines with the light verb <italic>hua</italic> and then with the optional time expression <italic>kala</italic> (&#x0201c;yesterday&#x0201d;) leading to <inline-formula id="IEq73"><alternatives><tex-math id="M141">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus NP_{gen}}$$\end{document}</tex-math><mml:math id="M142"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq73.gif"/></alternatives></inline-formula>. The verb phrase <inline-formula id="IEq74"><alternatives><tex-math id="M143">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus NP_{gen}}$$\end{document}</tex-math><mml:math id="M144"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq74.gif"/></alternatives></inline-formula> is then combined with the noun phrase with genitive marker <italic>mandir kaa</italic> (&#x0201c;of temple&#x0201d;) resulting in a sentence <inline-formula id="IEq75"><alternatives><tex-math id="M145">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}}$$\end{document}</tex-math><mml:math id="M146"><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq75.gif"/></alternatives></inline-formula>.<fig id="Fig22"><label>Fig. 22</label><caption><p>Dislocated/discontinuous genitives (time expression)</p></caption><graphic xlink:href="10579_2017_9379_Fig22_HTML" id="MO25"/></fig>
</p><p id="Par99">Figure&#x000a0;<xref rid="Fig23" ref-type="fig">23</xref> is similar to Fig.&#x000a0;<xref rid="Fig22" ref-type="fig">22</xref>, except that the noun with genitive marker <italic>budhdhiimattaa kii</italic> (&#x0201c;intelligence&#x0201d;) is in COBJ dependency relation with the noun of the conjunct verb <italic>taariiph</italic> (&#x0201c;appreciate&#x0201d;). Also the intervening node <italic>jamkara</italic> (&#x0201c;greatly&#x0201d;) which is the cause for the crossing arc is an adverb (ADV) unlike the time expression in the previous case.<fig id="Fig23"><label>Fig. 23</label><caption><p>Dislocated/discontinuous genitives (adverb)</p></caption><graphic xlink:href="10579_2017_9379_Fig23_HTML" id="MO26"/></fig>
</p></sec><sec id="Sec19"><title>Others</title><p id="Par100">Other major dependency labels/constructions which lead to crossing dependency arcs are time/place expressions (TIME/PLACE), noun modifiers (NMOD), SUBJ. These labels corresponds to 9% of crossing arcs.</p><p id="Par101">Similar to adverbs, time/place expressions, due to freer word-order nature of Hindi, can occur at any place in the sentence and can be handled using crossed composition in general cases. But, when these occur between nouns in genitive relation or in the conjunct verbs constructions (as in Sect.&#x000a0;<xref rid="Sec18" ref-type="sec">8.5</xref>), they lead to crossing arcs, and are handled as discussed in Sect.&#x000a0;<xref rid="Sec18" ref-type="sec">8.5</xref>.</p><p id="Par102">NMOD is the label for noun modifier. NMOD constructions which lead to crossing arcs are similar to those of genitives as in Sect.&#x000a0;<xref rid="Sec18" ref-type="sec">8.5</xref>. SUBJ constructions also engender crossing arcs similarly to the OBJ constructions/topicalization in Sect.&#x000a0;<xref rid="Sec16" ref-type="sec">8.3</xref>. These constructions are handled similarly to the ones described in the previous sections.</p></sec></sec><sec id="Sec20"><title>Analysis of the Hindi CCGbank</title><p id="Par103">In this section, we provide a brief analysis of the different CCG categories and combinators in the Hindi CCGbank. Table&#x000a0;<xref rid="Tab2" ref-type="table">2</xref> lists the top 12 most frequent CCG categories in both coarse-grained and fine-grained versions of the lexicon. The most common categories are the category for nouns (<italic>NP</italic>) and noun modifiers like adjectives and determiners (<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>). The next most frequent categories are the categories for post-position markers for nouns and auxiliary or tense, aspect and modality (TAM) markers for verbs. <inline-formula id="IEq76"><alternatives><tex-math id="M147">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus S_{f}}$$\end{document}</tex-math><mml:math id="M148"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq76.gif"/></alternatives></inline-formula> and <inline-formula id="IEq77"><alternatives><tex-math id="M149">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M150"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq77.gif"/></alternatives></inline-formula> are the categories for auxiliary or TAM markers for verbs and post-position markers for nouns respectively. The post-position marker of an adjunct noun phrase gets the category <inline-formula id="IEq78"><alternatives><tex-math id="M151">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}/ S_{f})\setminus NP}. {(NP/ NP)\setminus NP}$$\end{document}</tex-math><mml:math id="M152"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mo>.</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq78.gif"/></alternatives></inline-formula> is the category for both genitive marker and conjunction in NP coordination. <inline-formula id="IEq79"><alternatives><tex-math id="M153">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}\setminus NP)\setminus NP}$$\end{document}</tex-math><mml:math id="M154"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq79.gif"/></alternatives></inline-formula> and <inline-formula id="IEq80"><alternatives><tex-math id="M155">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus NP}$$\end{document}</tex-math><mml:math id="M156"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq80.gif"/></alternatives></inline-formula> are the categories for transitive and intransitive verbs respectively. Adjectival phrase gets a category <italic>JJP</italic>. (<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>)&#x000a0;/&#x000a0;(<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>) is the category for modifier of a noun modifier and <inline-formula id="IEq81"><alternatives><tex-math id="M157">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${CCP/ S_{f}}$$\end{document}</tex-math><mml:math id="M158"><mml:mrow><mml:mi>C</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq81.gif"/></alternatives></inline-formula> is the category for subordinate conjunction.</p><p id="Par104">Categories in the top 12 list of the fine-grained lexicon but not in the coarse-grained are <italic>NP</italic>[0], <inline-formula id="IEq82"><alternatives><tex-math id="M159">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[0\_ne]\setminus NP}$$\end{document}</tex-math><mml:math id="M160"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mi>_</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq82.gif"/></alternatives></inline-formula> and <inline-formula id="IEq83"><alternatives><tex-math id="M161">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[0\_ko]\setminus NP}$$\end{document}</tex-math><mml:math id="M162"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mi>_</mml:mi><mml:mi>k</mml:mi><mml:mi>o</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq83.gif"/></alternatives></inline-formula>. In this lexicon, the coarse category for nouns gets split into <italic>NP</italic> (the category for a noun with a separate lexical item as a case marker) and <italic>NP</italic>[0] (the category for a noun without any case marker). For example, in noun chunks <italic>raam ne</italic> (&#x0201c;Ram ERG&#x0201d;) and <italic>raam</italic> (&#x0201c;Ram&#x0201d;), the category of <italic>raam</italic> is <italic>NP</italic> in first case and <italic>NP</italic>[0] in the later case. 0 here means that the case marker appeared as a separate lexical item. For example, <italic>raam ne</italic> (&#x0201c;Ram ERG&#x0201d;) will have NP[0_ne] as the category whereas <italic>usne</italic> (&#x0201c;he+ERG&#x0201d;) will have NP[ne] as the category. This is the notation followed in the Hindi dependency treebank. The remaining two categories, <inline-formula id="IEq84"><alternatives><tex-math id="M163">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[0\_ne]\setminus NP}$$\end{document}</tex-math><mml:math id="M164"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mi>_</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq84.gif"/></alternatives></inline-formula> and <inline-formula id="IEq85"><alternatives><tex-math id="M165">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[0\_ko]\setminus NP}$$\end{document}</tex-math><mml:math id="M166"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mi>_</mml:mi><mml:mi>k</mml:mi><mml:mi>o</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq85.gif"/></alternatives></inline-formula>, are the categories for ergative (&#x02018;ne&#x02019;) and dative (&#x02018;ko&#x02019;) case-markers.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Distribution of CCG categories in coarse-grained (left) and fine-grained (right) lexicon</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">CCG category</th><th align="left">Percentage (%)</th><th align="left">CCG category</th><th align="left">Percentage (%)</th></tr></thead><tbody><tr><td align="left">
<italic>NP</italic>
</td><td char="." align="char">28.09</td><td align="left">
<italic>NP</italic>
</td><td char="." align="char">17.67</td></tr><tr><td align="left">
<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>
</td><td char="." align="char">16.45</td><td align="left">
<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>
</td><td char="." align="char">16.44</td></tr><tr><td align="left">
<inline-formula id="IEq86"><alternatives><tex-math id="M167">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus S_{f}}$$\end{document}</tex-math><mml:math id="M168"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq86.gif"/></alternatives></inline-formula>
</td><td char="." align="char">9.05</td><td align="left">
<italic>NP</italic>[0]</td><td char="." align="char">9.11</td></tr><tr><td align="left">
<inline-formula id="IEq87"><alternatives><tex-math id="M169">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP\setminus NP}$$\end{document}</tex-math><mml:math id="M170"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq87.gif"/></alternatives></inline-formula>
</td><td char="." align="char">6.99</td><td align="left">
<inline-formula id="IEq88"><alternatives><tex-math id="M171">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus S_{f}}$$\end{document}</tex-math><mml:math id="M172"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq88.gif"/></alternatives></inline-formula>
</td><td char="." align="char">9.05</td></tr><tr><td align="left">
<inline-formula id="IEq89"><alternatives><tex-math id="M173">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}/ S_{f})\setminus NP}$$\end{document}</tex-math><mml:math id="M174"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq89.gif"/></alternatives></inline-formula>
</td><td char="." align="char">6.66</td><td align="left">
<inline-formula id="IEq90"><alternatives><tex-math id="M175">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}/ S_{f})\setminus NP}$$\end{document}</tex-math><mml:math id="M176"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq90.gif"/></alternatives></inline-formula>
</td><td char="." align="char">5.91</td></tr><tr><td align="left">
<inline-formula id="IEq91"><alternatives><tex-math id="M177">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(NP/ NP)\setminus NP}$$\end{document}</tex-math><mml:math id="M178"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq91.gif"/></alternatives></inline-formula>
</td><td char="." align="char">4.53</td><td align="left">
<inline-formula id="IEq92"><alternatives><tex-math id="M179">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(NP/ NP)\setminus NP}$$\end{document}</tex-math><mml:math id="M180"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq92.gif"/></alternatives></inline-formula>
</td><td char="." align="char">4.09</td></tr><tr><td align="left">
<inline-formula id="IEq93"><alternatives><tex-math id="M181">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}/ S_{f}}$$\end{document}</tex-math><mml:math id="M182"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq93.gif"/></alternatives></inline-formula>
</td><td char="." align="char">2.56</td><td align="left">
<inline-formula id="IEq94"><alternatives><tex-math id="M183">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}/ S_{f}}$$\end{document}</tex-math><mml:math id="M184"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq94.gif"/></alternatives></inline-formula>
</td><td char="." align="char">2.56</td></tr><tr><td align="left">
<inline-formula id="IEq95"><alternatives><tex-math id="M185">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${(S_{f}\setminus NP)\setminus NP}$$\end{document}</tex-math><mml:math id="M186"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq95.gif"/></alternatives></inline-formula>
</td><td char="." align="char">2.21</td><td align="left">
<italic>JJP</italic>
</td><td char="." align="char">2.12</td></tr><tr><td align="left">
<italic>JJP</italic>
</td><td char="." align="char">2.11</td><td align="left">(<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>)&#x000a0;/&#x000a0;(<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>)</td><td char="." align="char">1.90</td></tr><tr><td align="left">
<inline-formula id="IEq96"><alternatives><tex-math id="M187">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus NP}$$\end{document}</tex-math><mml:math id="M188"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq96.gif"/></alternatives></inline-formula>
</td><td char="." align="char">2.05</td><td align="left">
<inline-formula id="IEq97"><alternatives><tex-math id="M189">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[0\_ne]\setminus NP}$$\end{document}</tex-math><mml:math id="M190"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mi>_</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq97.gif"/></alternatives></inline-formula>
</td><td char="." align="char">1.84</td></tr><tr><td align="left">(<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>)&#x000a0;/&#x000a0;(<italic>NP</italic>&#x000a0;/&#x000a0;<italic>NP</italic>)</td><td char="." align="char">1.90</td><td align="left">
<inline-formula id="IEq98"><alternatives><tex-math id="M191">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${S_{f}\setminus NP[0]}$$\end{document}</tex-math><mml:math id="M192"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq98.gif"/></alternatives></inline-formula>
</td><td char="." align="char">1.82</td></tr><tr><td align="left">
<inline-formula id="IEq99"><alternatives><tex-math id="M193">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${CCP/ S_{f}}$$\end{document}</tex-math><mml:math id="M194"><mml:mrow><mml:mi>C</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq99.gif"/></alternatives></inline-formula>
</td><td char="." align="char">1.60</td><td align="left">
<inline-formula id="IEq100"><alternatives><tex-math id="M195">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${NP[0\_ko]\setminus NP}$$\end{document}</tex-math><mml:math id="M196"><mml:mrow><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mi>_</mml:mi><mml:mi>k</mml:mi><mml:mi>o</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq100.gif"/></alternatives></inline-formula>
</td><td char="." align="char">1.77</td></tr></tbody></table></table-wrap>
</p><p id="Par105">Table&#x000a0;<xref rid="Tab3" ref-type="table">3</xref> shows the distribution of different CCG combinators in the Hindi CCGbank. Since Hindi is a verb final language, the backward application and composition combinators are more frequent than forward application and composition combinators. Due to freer word-order nature and crossing dependency arcs, there are around 0.5% of crossed composition combinators in the Hindi CCGbank. This shows the importance of crossed composition combinators for freer word-order languages.<table-wrap id="Tab3"><label>Table 3</label><caption><p>Distribution of combinators in the Hindi CCGbank</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">CCG combinator</th><th align="left">Percentage (%)</th></tr></thead><tbody><tr><td align="left">Forward application (&#x0003e;)</td><td char="." align="char">38.61</td></tr><tr><td align="left">Backward application (&#x0003c;)</td><td char="." align="char">45.90</td></tr><tr><td align="left">Forward composition (&#x0003e;B)</td><td char="." align="char">0.01</td></tr><tr><td align="left">Backward composition (&#x0003c;B)</td><td char="." align="char">14.99</td></tr><tr><td align="left">Forward crossed composition (<inline-formula id="IEq101"><alternatives><tex-math id="M197">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${&#x0003e;}B_{X}$$\end{document}</tex-math><mml:math id="M198"><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq101.gif"/></alternatives></inline-formula>)</td><td char="." align="char">0.04</td></tr><tr><td align="left">Backward crossed composition (<inline-formula id="IEq102"><alternatives><tex-math id="M199">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${&#x0003c;}B_{X}$$\end{document}</tex-math><mml:math id="M200"><mml:mrow><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq102.gif"/></alternatives></inline-formula>)</td><td char="." align="char">0.45</td></tr></tbody></table></table-wrap>
</p></sec><sec id="Sec21"><title>Conclusion</title><p id="Par106">We presented an approach for automatically creating a CCGbank from a dependency treebank for Hindi which is a morphologically rich, freer word-order and verb final language. We created two types of lexicon: fine-grained which keeps morphological information in noun categories and coarse-grained which doesn&#x02019;t. We have provided a detailed analysis of various long-range dependencies like coordinate and relative constructions, and shown how to handle them in CCG. We have also discussed in detail the different word-orders that arise from the free word-order nature of Hindi in various constuctions, and provided a unified projective analysis for them under CCG. We have also provided a brief statistical analysis of the different CCG categories and combinators occurring in the Hindi CCGbank.</p><p id="Par107">The approach described here has already been successfully applied to Telugu, another Indian language (Kumari and Rao <xref ref-type="bibr" rid="CR34">2015</xref>). In future we would like to extract CCG lexicons and/or CCGbanks for the many other languages for which dependency treebanks are available, including the languages of the CoNLL dependency parsing shared tasks (Buchholz and Marsi <xref ref-type="bibr" rid="CR19">2006</xref>; Nivre et&#x000a0;al. <xref ref-type="bibr" rid="CR49">2007a</xref>) and universal dependency treebanks (McDonald et&#x000a0;al. <xref ref-type="bibr" rid="CR43">2013</xref>).<xref ref-type="fn" rid="Fn19">19</xref> State of the art results for parsers trained and tested on the treebank are reported in Ambati et&#x000a0;al. (<xref ref-type="bibr" rid="CR3">2013</xref>, <xref ref-type="bibr" rid="CR4">2014</xref>); Ambati (<xref ref-type="bibr" rid="CR2">2016</xref>).</p></sec></body><back><app-group><app id="App1"><sec id="Sec22"><title>Appendix 1: Hindi dependency labels</title><p id="Par109">See Table&#x000a0;<xref rid="Tab4" ref-type="table">4</xref>.<table-wrap id="Tab4"><label>Table 4</label><caption><p>Hindi dependency labels and their English equivalents</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Hindi depenency label</th><th align="left">English equivalent</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">k1 (kartha)</td><td align="left">SUBJ</td><td align="left">Subject/agent</td></tr><tr><td align="left">k1s (kartha samanadhikarana)</td><td align="left">SCOM</td><td align="left">Noun complements of kartha</td></tr><tr><td align="left">k2 (karma)</td><td align="left">OBJ</td><td align="left">Object/patient</td></tr><tr><td align="left">k3 (karana)</td><td align="left">INST</td><td align="left">Instrument</td></tr><tr><td align="left">k4 (sampradaana)</td><td align="left">RCPT</td><td align="left">Recipient</td></tr><tr><td align="left">k5 (apaadaana)</td><td align="left">SRC</td><td align="left">Source</td></tr><tr><td align="left">k7t (kaalaadhikarana)</td><td align="left">TIME</td><td align="left">Time expression</td></tr><tr><td align="left">k7p (deshadhikarana)</td><td align="left">PLACE</td><td align="left">Place expression</td></tr><tr><td align="left">r6 (shashthi)</td><td align="left">GEN</td><td align="left">Possessive/genitive marker</td></tr><tr><td align="left">nmod_relc</td><td align="left">RELC</td><td align="left">Relative clause</td></tr><tr><td align="left">vmod</td><td align="left">VMOD</td><td align="left">Verbal modifier</td></tr><tr><td align="left">nmod</td><td align="left">NMOD</td><td align="left">Noun modifier</td></tr><tr><td align="left">nmod__adj</td><td align="left">AMOD</td><td align="left">Adjectival modifier of a noun</td></tr><tr><td align="left">lwg__psp</td><td align="left">CASE</td><td align="left">Case marker</td></tr><tr><td align="left">lwg__aux</td><td align="left">AUX</td><td align="left">Auxiliary verb or tense, aspect and modality marker for verb</td></tr><tr><td align="left">pof</td><td align="left">POF</td><td align="left">Part-OF units such as conjunct verbs</td></tr><tr><td align="left">rs</td><td align="left">CCOM</td><td align="left">Clausal complement</td></tr><tr><td align="left">r6&#x02013;k1</td><td align="left">CSUB</td><td align="left">SUBJ of conjunct verb</td></tr><tr><td align="left">r6&#x02013;k2</td><td align="left">COBJ</td><td align="left">OBJ of conjunct verb</td></tr></tbody></table></table-wrap>
</p></sec></app><app id="App2"><sec id="Sec23"><title>Appendix 2: Hindi chunk tags</title><p id="Par110">See Table&#x000a0;<xref rid="Tab5" ref-type="table">5</xref>.<table-wrap id="Tab5"><label>Table 5</label><caption><p>Hindi Chunk tagset</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">S. No</th><th align="left">Chunk type</th><th align="left">Tag name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Noun chunk</td><td align="left">NP</td></tr><tr><td align="left">2.1</td><td align="left">Finite verb chunk</td><td align="left">VGF</td></tr><tr><td align="left">2.2</td><td align="left">Non-finite verb chunk</td><td align="left">VGNF</td></tr><tr><td align="left">2.3</td><td align="left">Infinitival verb chunk</td><td align="left">VGINF</td></tr><tr><td align="left">2.4</td><td align="left">Verb chunk (gerund)</td><td align="left">VGNN</td></tr><tr><td align="left">3</td><td align="left">Adjectival chunk</td><td align="left">JJP</td></tr><tr><td align="left">4</td><td align="left">Adverb chunk</td><td align="left">RBP</td></tr><tr><td align="left">5</td><td align="left">Chunk for negatives</td><td align="left">NEGP</td></tr><tr><td align="left">6</td><td align="left">Conjuncts</td><td align="left">CCP</td></tr><tr><td align="left">7</td><td align="left">Chunk fragments</td><td align="left">FRAGP</td></tr><tr><td align="left">8</td><td align="left">Miscellaneous</td><td align="left">BLK</td></tr></tbody></table></table-wrap>
</p></sec></app><app id="App3"><sec id="Sec24"><title>Appendix 3: Machine-readable format</title><p id="Par111">CCG derivation for the first sentence in the Hindi dependency treebank guidelines using fine-grained lexicon is given below. We follow the format of Hockenmaier and Steedman (<xref ref-type="bibr" rid="CR26">2007</xref>) for representing the binary CCG derivation trees with the bracketed notation.</p><graphic position="anchor" xlink:href="10579_2017_9379_Figd_HTML" id="MO27"/><p id="Par112">There are two types of nodes in the derivation trees: Leaf nodes and Non-leaf nodes. Leaf nodes have six fields.</p><p id="Par113">&#x0003c;L NP[ne] NNP NNP raam NP[ne]&#x0003e;</p><p id="Par114">&#x0003c;L CCGCat mod-POS-tag orig-POS-tag word CCGCat2&#x0003e;</p><p id="Par115">
L represents that it is a leaf node. CCGCat is the CCG category of the node. Unlike English, POS tag is not modified during the conversion of dependency trees to CCG derivations. So, in Hindi CCGbank, mod-POS-tag and orig-POS-tag both represent the POS tag of the word. Lexical item is represented using word field. In English CCGbank, CCGCat2 slot is used to represent predicate-argument structure of the CCG category. In Hindi CCGbank, we just use the lexical CCG category to fill this slot.</p><p id="Par116">Non-leaf nodes have four fields. T represents that the node is a non-leaf node. CCGCat is the CCG category of the node. head takes two values: 0 if the left node is the head and 1 if the right node is the head. Since the CCG derivation trees are binary trees, children field will have 1 or 2 based on whether there are one or two children. Example non-leaf node is given below.</p><p id="Par117">&#x0003c;T NP[ne] 0 2
</p><p id="Par118">&#x0003c;T CCGCat head children
<fig id="Fig24"><label>Fig. 24</label><caption><p>Example dependency tree and CCG derivation (fine-grained)</p></caption><graphic position="anchor" xlink:href="10579_2017_9379_Fig24_HTML" id="MO28"/></fig>
</p><p id="Par119">CCG derivation tree with coarse-grained lexicon is provided below in machine-readable format along with the dependency tree and derivation (Fig.&#x000a0;<xref rid="Fig25" ref-type="fig">25</xref>). Figure <xref rid="Fig24" ref-type="fig">24</xref> presents the CCG derivation of the same sentence using fine-grained lexicon.</p><graphic position="anchor" xlink:href="10579_2017_9379_Fige_HTML" id="MO29"/><p id="Par120">
<fig id="Fig25"><label>Fig. 25</label><caption><p>Example dependency tree and CCG derivation (coarse-grained)</p></caption><graphic position="anchor" xlink:href="10579_2017_9379_Fig25_HTML" id="MO30"/></fig>
</p></sec></app></app-group><fn-group><fn id="Fn1"><label>1</label><p id="Par12">
<ext-link ext-link-type="uri" xlink:href="http://www.di.unito.it/%7etutreeb/">http://www.di.unito.it/~tutreeb/</ext-link>.</p></fn><fn id="Fn2"><label>2</label><p id="Par17">
<ext-link ext-link-type="uri" xlink:href="http://www.ethnologue.com/statistics/size">http://www.ethnologue.com/statistics/size</ext-link>.</p></fn><fn id="Fn3"><label>3</label><p id="Par18">S&#x000a0;=&#x000a0;Subject; IO&#x000a0;=&#x000a0;Indirect Object; DO&#x000a0;=&#x000a0;Direct Object; V&#x000a0;=&#x000a0;Verb; ERG&#x000a0;=&#x000a0;Ergative; DAT&#x000a0;=&#x000a0;Dative.</p></fn><fn id="Fn4"><label>4</label><p id="Par20">Hindi is split-ergative. The ergative marker appears on the subject of a transitive verb with perfect morphology.</p></fn><fn id="Fn5"><label>5</label><p id="Par35">All examples have been taken from the corpus, although in many case they are simplified by the omission of modifiers and conjunction.</p></fn><fn id="Fn6"><label>6</label><p id="Par38">
<ext-link ext-link-type="uri" xlink:href="http://nextens.uvt.nl/depparse-wiki/DataFormat">http://nextens.uvt.nl/depparse-wiki/DataFormat</ext-link>.</p></fn><fn id="Fn7"><label>7</label><p id="Par42">We return below to the question of case marking and agreement.</p></fn><fn id="Fn8"><label>8</label><p id="Par44">We treated CASE in this manner for the case of consistency with the dependency treebank and leave more linguistically sophisticated treatments of CASE for future work (although see Sect.&#x000a0;<xref rid="Sec9" ref-type="sec">5.1</xref> for a type-raising analysis).</p></fn><fn id="Fn9"><label>9</label><p id="Par46">VGF is the chunk tag for finite verb chunk in the Hindi dependency treebank. But for the sake of brevity we use S<inline-formula id="IEq33"><alternatives><tex-math id="M201">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$_{f}$$\end{document}</tex-math><mml:math id="M202"><mml:msub><mml:mrow/><mml:mi>f</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq33.gif"/></alternatives></inline-formula> notation here. A list of the Hindi chunk tags are provided in the &#x0201c;<xref rid="Sec23" ref-type="sec">Appendix 2</xref>&#x0201d;.</p></fn><fn id="Fn10"><label>10</label><p id="Par54">
<ext-link ext-link-type="uri" xlink:href="http://openccg.sourceforge.net/">http://openccg.sourceforge.net/</ext-link>.</p></fn><fn id="Fn11"><label>11</label><p id="Par62">This treatment constitutes a slight difference from English CCGbank, where coordination is treated syncategorematically, with conjunction bearing the category <italic>conj</italic>.</p></fn><fn id="Fn12"><label>12</label><p id="Par69">TV is the short form for <inline-formula id="IEq49"><alternatives><tex-math id="M203">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${((S_{f}\setminus NP)\setminus NP)}$$\end{document}</tex-math><mml:math id="M204"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo lspace="0.15em" rspace="0.15em" stretchy="false">\</mml:mo><mml:mi>N</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10579_2017_9379_Article_IEq49.gif"/></alternatives></inline-formula>, the transitive verb category.</p></fn><fn id="Fn13"><label>13</label><p id="Par70">We are not handling argument cluster coordination in the current version of the CCGbank since the current version doesn&#x02019;t include unary type-changing rules. We will handle these constructions in the next version.</p></fn><fn id="Fn14"><label>14</label><p id="Par73">See Clark and Curran (<xref ref-type="bibr" rid="CR21">2007</xref>) for details on how indexed categories are used to extract dependencies.</p></fn><fn id="Fn15"><label>15</label><p id="Par79">It is easy to re-construct the original dependency with the help of lexical item <italic>yaha</italic> (&#x0201c;this&#x0201d;). We can find the parent of <italic>ki</italic> (&#x0201c;that&#x0201d;) and extract the lexical item <italic>yaha</italic> (&#x0201c;this&#x0201d;) from its sub-tree. Assigning it as the parent of <italic>ki</italic> (&#x0201c;that&#x0201d;) would result in the original dependency tree.</p></fn><fn id="Fn16"><label>16</label><p id="Par83">In Hindi dependency treebank POF (part-of) dependency label is used to represent part of units such as conjunct verbs.</p></fn><fn id="Fn17"><label>17</label><p id="Par86">For example, in Fig.&#x000a0;<xref rid="Fig16" ref-type="fig">16</xref>, CCG derivation gives the dependency between <italic>hai</italic> (&#x0201c;is&#x0201d;) of relative clause and <italic>hai</italic> (&#x0201c;is&#x0201d;) of main clause. As the chunk with <italic>vo</italic> (&#x0201c;that&#x0201d;) root word (here <italic>vaha</italic>) is <italic>vaha ladakaa</italic> (&#x0201c;that boy&#x0201d;), the head of <italic>hai</italic> (&#x0201c;is&#x0201d;) as per Hindi dependency guidelines would be <italic>ladakaa</italic> (&#x0201c;boy&#x0201d;).</p></fn><fn id="Fn18"><label>18</label><p id="Par91">Indices for categories are not part of the lexicon but indices are used while extracting dependencies from the CCG derivation.</p></fn><fn id="Fn19"><label>19</label><p id="Par108">
<ext-link ext-link-type="uri" xlink:href="http://universaldependencies.org/">http://universaldependencies.org/</ext-link>.</p></fn></fn-group><ack><title>Acknowledgements</title><p>This work was supported by ERC Advanced Fellowship 249520 GRAMPLUS and EU IST Cognitive Systems IP Xperience grants.</p></ack><ref-list id="Bib1"><title>References</title><ref id="CR1"><mixed-citation publication-type="other">Ambati, B. R. (2011). Hindi dependency parsing and treebank validation. Master&#x02019;s thesis, International Institute of Information Technology, Hyderabad, India.</mixed-citation></ref><ref id="CR2"><mixed-citation publication-type="other">Ambati, B. R. (2016). Transition-based Combinatory Categorial Grammar parsing for English and Hindi. Ph.D. thesis, University of Edinburgh, UK.</mixed-citation></ref><ref id="CR3"><mixed-citation publication-type="other">Ambati, B. R., Deoskar, T., &#x00026; Steedman, M. (2013). Using CCG categories to improve Hindi dependency parsing. In <italic>Proceedings of the 51st annual meeting of the association for computational linguistics</italic> (Vol. 2: Short Papers, pp. 604&#x02013;609). Sofia, Bulgaria.</mixed-citation></ref><ref id="CR4"><mixed-citation publication-type="other">Ambati, B. R., Deoskar, T., &#x00026; Steedman, M. (2014). Improving dependency parsers using combinatory categorial grammar. In <italic>Proceedings of the 14th conference of the European chapter of the association for computational linguistics</italic> (Vol. 2: Short Papers, pp. 159&#x02013;163). Gothenburg, Sweden.</mixed-citation></ref><ref id="CR5"><mixed-citation publication-type="other">Ambati, B. R., Deoskar, T., Johnson, M., &#x00026; Steedman, M. (2015). An incremental algorithm for transition-based CCG parsing. In <italic>Proceedings of the 2015 conference of the North American chapter of the association for computational linguistics: Human language technologies</italic> (pp. 53&#x02013;63), Denver, Colorado.</mixed-citation></ref><ref id="CR6"><mixed-citation publication-type="other">Auli, M., &#x00026; Lopez, A. (2011). A comparison of loopy belief propagation and dual decomposition for integrated CCG supertagging and parsing. In <italic>Proceedings of the 49th annual meeting of the association for computational linguistics: Human language technologies</italic> (pp. 470&#x02013;480). Portland, Oregon, USA.</mixed-citation></ref><ref id="CR7"><mixed-citation publication-type="other">Begum, R., Husain, S., Bai, L., &#x00026; Sharma, D. M. (2008a). Developing verb frames for Hindi. In <italic>Proceedings of LREC</italic>.</mixed-citation></ref><ref id="CR8"><mixed-citation publication-type="other">Begum, R., Husain, S., Dhwaj, A., Sharma, D. M., Bai, L., &#x00026; Sangal, R. (2008b). Dependency annotation scheme for Indian languages. In <italic>Proceedings of the third international joint conference on natural language processing (IJCNLP)</italic> (pp. 721&#x02013;726). Hyderabad, India.</mixed-citation></ref><ref id="CR9"><mixed-citation publication-type="other">Bharati, A., Mannem, P., &#x00026; Sharma, D. M. (2012). Hindi parsing shared task. In <italic>Proceedings of coling workshop on machine translation and parsing in Indian languages</italic>. Kharagpur, India.</mixed-citation></ref><ref id="CR10"><mixed-citation publication-type="other">Bharati, A., Sangal, R., &#x00026; Sharma, D. M. (2007). SSF: Shakti standard format guide. In <italic>Technical report (TR-LTRC-33), LTRC, IIIT-Hyderabad</italic>.</mixed-citation></ref><ref id="CR11"><mixed-citation publication-type="other">Bharati, A., Sangal, R., Sharma, D. M., &#x00026; Bai, L. (2006). AnnCorra: Annotating corpora guidelines for POS and chunk annotation for Indian languages. In <italic>Technical report (TR-LTRC-31), LTRC, IIIT-Hyderabad</italic>.</mixed-citation></ref><ref id="CR12"><mixed-citation publication-type="other">Bharati, A., Sharma, D.&#x000a0;M., Husain, S., Bai, L., Begum, R., &#x00026; Sangal, R. (2009). AnnCorra: TreeBanks for Indian languages, guidelines for annotating Hindi TreeBank (version 2.0). <ext-link ext-link-type="uri" xlink:href="http://ltrc.iiit.ac.in/MachineTrans/research/tb/DS-guidelines/DS-guidelines-ver2-28-05-09.pdf">http://ltrc.iiit.ac.in/MachineTrans/research/tb/DS-guidelines/DS-guidelines-ver2-28-05-09.pdf</ext-link>.</mixed-citation></ref><ref id="CR13"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bharati</surname><given-names>A</given-names></name><name><surname>Chaitanya</surname><given-names>V</given-names></name><name><surname>Sangal</surname><given-names>R</given-names></name></person-group><source>Natural language processing: A paninian perspective</source><year>1995</year><publisher-loc>New Delhi</publisher-loc><publisher-name>Prentice-Hall of India</publisher-name></element-citation></ref><ref id="CR14"><mixed-citation publication-type="other">Bhat, R. A. &#x00026; Sharma, D. M. (2012). Non-projective structures in Indian language treebanks. In <italic>Proceedings of the 11th workshop on treebanks and linguistic theories (TLT11)</italic> (pp. 25&#x02013;30).</mixed-citation></ref><ref id="CR15"><mixed-citation publication-type="other">Bhatt, R., Narasimhan, B., Palmer, M., Rambow, O., Sharma, D. M., &#x00026; Xia, F. (2009). A multi-representational and multi-layered treebank for Hindi/Urdu. <italic>Proceedings of the third linguistic annotation workshop at 47th ACL and 4th IJCNLP</italic> (pp. 186&#x02013;189). Suntec, Singapore.</mixed-citation></ref><ref id="CR16"><mixed-citation publication-type="other">Bos, J., Bosco, C., &#x00026; Mazzei, A. (2009). Converting a dependency treebank to a categorial grammar treebank for Italian. In <italic>Proceedings of the eighth international workshop on treebanks and linguistic theories (TLT8)</italic> (pp. 27&#x02013;38). Italy, Milan.</mixed-citation></ref><ref id="CR17"><mixed-citation publication-type="other">Bos, J., Clark, S., Steedman, M., Curran, J. R., &#x00026; Hockenmaier, J. (2004). Wide-coverage semantic representations from a CCG parser. In <italic>Proceedings of coling 2004</italic> (pp. 1240&#x02013;1246). Geneva, Switzerland. COLING.</mixed-citation></ref><ref id="CR18"><mixed-citation publication-type="other">Brants, S., Dipper, S., Hansen, S., Lezius, W., &#x00026; Smith, G. (2002). The TIGER treebank. In <italic>Proceedings of the first workshop on treebanks and linguistic theories (TLT 2002)</italic>. Sozopol, Bulgaria.</mixed-citation></ref><ref id="CR19"><mixed-citation publication-type="other">Buchholz, S., &#x00026; Marsi, E. (2006). CoNLL-X shared task on multilingual dependency parsing. In <italic>Proceedings of the tenth conference on computational natural language learning</italic> (pp. 149&#x02013;164). New York City, New York.</mixed-citation></ref><ref id="CR20"><mixed-citation publication-type="other">Cakici, R. (2005). Automatic induction of a CCG grammar for Turkish. In <italic>Proceedings of the ACL student research workshop</italic> (pp. 73&#x02013;78). Ann Arbor, Michigan.</mixed-citation></ref><ref id="CR21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Clark</surname><given-names>S</given-names></name><name><surname>Curran</surname><given-names>JR</given-names></name></person-group><article-title>Wide-coverage efficient statistical parsing with CCG and log-linear models</article-title><source>Computational Linguistics</source><year>2007</year><volume>33</volume><fpage>493</fpage><lpage>552</lpage><pub-id pub-id-type="doi">10.1162/coli.2007.33.4.493</pub-id></element-citation></ref><ref id="CR22"><mixed-citation publication-type="other">Collins, M. (1999). Head-driven statistical models for natural language parsing. Ph.D. thesis, University of Pennsylvania.</mixed-citation></ref><ref id="CR23"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hays</surname><given-names>D</given-names></name></person-group><article-title>Dependency theory: A formalism and some observations</article-title><source>Language</source><year>1964</year><volume>40</volume><fpage>511</fpage><lpage>525</lpage><pub-id pub-id-type="doi">10.2307/411934</pub-id></element-citation></ref><ref id="CR24"><mixed-citation publication-type="other">Hockenmaier, J. (2006). Creating a CCGbank and a wide-coverage CCG lexicon for German. In <italic>Proceedings of the 21st international conference on computational linguistics and 44th annual meeting of the association for computational linguistics</italic> (pp. 505&#x02013;512). Sydney, Australia.</mixed-citation></ref><ref id="CR25"><mixed-citation publication-type="other">Hockenmaier, J., &#x00026; Steedman, M. (2002). Generative models for statistical parsing with combinatory categorial grammar. In <italic>Proceedings of 40th annual meeting of the association for computational linguistics</italic> (pp. 335&#x02013;342). Philadelphia, Pennsylvania, USA.</mixed-citation></ref><ref id="CR26"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hockenmaier</surname><given-names>J</given-names></name><name><surname>Steedman</surname><given-names>M</given-names></name></person-group><article-title>CCGbank: A corpus of CCG derivations and dependency structures extracted from the Penn Treebank</article-title><source>Computational Linguistics</source><year>2007</year><volume>33</volume><issue>3</issue><fpage>355</fpage><lpage>396</lpage><pub-id pub-id-type="doi">10.1162/coli.2007.33.3.355</pub-id></element-citation></ref><ref id="CR27"><mixed-citation publication-type="other">Honnibal, M., &#x00026; Curran, J. R. (2007). Improving the complement/adjunct distinction in CCGBank. In <italic>Proceedings of the 10th conference of the pacific association for computational linguistics (PACLING-07)</italic> (pp. 210&#x02013;217).</mixed-citation></ref><ref id="CR28"><mixed-citation publication-type="other">Honnibal, M., Curran, J. R., &#x00026; Bos, J. (2010). Rebanking CCGbank for improved NP interpretation. In <italic>Proceedings of the 48th annual meeting of the association for computational linguistics</italic> (pp. 207&#x02013;215). Uppsala, Sweden.</mixed-citation></ref><ref id="CR29"><mixed-citation publication-type="other">Iida, R., Komachi, M., Inui, K., &#x00026; Matsumoto, Y. (2007). Annotating a Japanese text corpus with predicate-argument and coreference relations. In <italic>Proceedings of the linguistic annotation workshop</italic> (pp. 132&#x02013;139). Association for Computational Linguistics.</mixed-citation></ref><ref id="CR30"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Joshi</surname><given-names>A</given-names></name><name><surname>Vijay-Shanker</surname><given-names>K</given-names></name><name><surname>Weir</surname><given-names>D</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Sells</surname><given-names>P</given-names></name><name><surname>Shieber</surname><given-names>S</given-names></name><name><surname>Wasow</surname><given-names>T</given-names></name></person-group><article-title>The convergence of mildly context-sensitive formalisms</article-title><source>Processing of linguistic structure</source><year>1991</year><publisher-loc>Cambridge, MA</publisher-loc><publisher-name>MIT Press</publisher-name><fpage>31</fpage><lpage>81</lpage></element-citation></ref><ref id="CR31"><mixed-citation publication-type="other">Kawahara, D., Kurohashi, S., &#x00026; Hasida, K. (2002). Construction of a Japanese relevance-tagged corpus. In <italic>LREC</italic>.</mixed-citation></ref><ref id="CR32"><mixed-citation publication-type="other">Kiparsky, P., &#x00026; Staal, J. F. (1969). Syntactic and semantic relations in <inline-graphic xlink:href="10579_2017_9379_Figf_HTML.gif" id="d29e6021"/>. <italic>Foundations of Language</italic>, <italic>5</italic>(1), 83&#x02013;117.</mixed-citation></ref><ref id="CR33"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kuhlmann</surname><given-names>M</given-names></name><name><surname>Koller</surname><given-names>A</given-names></name><name><surname>Satta</surname><given-names>G</given-names></name></person-group><article-title>Lexicalization and generative power in CCG</article-title><source>Computational Linguistics</source><year>2015</year><volume>41</volume><fpage>187</fpage><lpage>219</lpage><pub-id pub-id-type="doi">10.1162/COLI_a_00219</pub-id></element-citation></ref><ref id="CR34"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kumari</surname><given-names>B</given-names></name><name><surname>Rao</surname><given-names>RR</given-names></name></person-group><article-title>Improving Telugu dependency parsing using combinatory categorial grammar supertags</article-title><source>ACM Transactions on Asian and Low-Resource Language Information Processing</source><year>2015</year><volume>14</volume><issue>1</issue><fpage>3</fpage><pub-id pub-id-type="doi">10.1145/2693190.2693191</pub-id></element-citation></ref><ref id="CR35"><mixed-citation publication-type="other">Kwiatkowski, T., Choi, E., Artzi, Y., &#x00026; Zettlemoyer, L. (2013). Scaling semantic parsers with on-the-fly ontology matching. In <italic>Proceedings of the 2013 conference on empirical methods in natural language processing</italic> (pp. 1545&#x02013;1556). Seattle, Washington, USA.</mixed-citation></ref><ref id="CR36"><mixed-citation publication-type="other">Lewis, M., &#x00026; Steedman, M. (2013). Unsupervised induction of cross-lingual semantic relations. In <italic>Proceedings of the 2013 conference on empirical methods in natural language processing</italic> (pp. 681&#x02013;692). Seattle, Washington, USA.</mixed-citation></ref><ref id="CR37"><mixed-citation publication-type="other">Lewis, M., &#x00026; Steedman, M. (2014). A* CCG parsing with a supertag-factored model. In <italic>Proceedings of the 2014 conference on empirical methods in natural language processing</italic>. Doha, Qatar.</mixed-citation></ref><ref id="CR38"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lewis</surname><given-names>M</given-names></name><name><surname>Steedman</surname><given-names>M</given-names></name></person-group><article-title>Combined distributional and logical semantics</article-title><source>Transactions of the Association for Computational Linguistics</source><year>2013</year><volume>1</volume><fpage>179</fpage><lpage>192</lpage></element-citation></ref><ref id="CR39"><mixed-citation publication-type="other">Magerman, D. M. (1994). Natural language parsing as statistical pattern recognition. Ph.D. thesis, Stanford University.</mixed-citation></ref><ref id="CR40"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Mahajan</surname><given-names>A</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Alexiadou</surname><given-names>A</given-names></name><name><surname>Law</surname><given-names>P</given-names></name><name><surname>Meinunger</surname><given-names>A</given-names></name><name><surname>Wilder</surname><given-names>C</given-names></name></person-group><article-title>Relative asymmetries and Hindi correlatives</article-title><source>The syntax of relative clauses</source><year>2000</year><publisher-loc>Amsterdam</publisher-loc><publisher-name>John Benjamins</publisher-name><fpage>201</fpage><lpage>229</lpage></element-citation></ref><ref id="CR41"><mixed-citation publication-type="other">Mannem, P., Chaudhry, H., &#x00026; Bharati, A. (2009). Insights into non-projectivity in Hindi. In <italic>Proceedings of the ACL-IJCNLP 2009 student research workshop</italic> (pp. 10&#x02013;17). Suntec, Singapore.</mixed-citation></ref><ref id="CR42"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Marcus</surname><given-names>MP</given-names></name><name><surname>Santorini</surname><given-names>B</given-names></name><name><surname>Marcinkiewicz</surname><given-names>MA</given-names></name></person-group><article-title>Building a large annotated corpus of English: The Penn Treebank</article-title><source>Computational Linguistics</source><year>1993</year><volume>19</volume><issue>2</issue><fpage>313</fpage><lpage>330</lpage></element-citation></ref><ref id="CR43"><mixed-citation publication-type="other">McDonald, R., Nivre, J., Quirmbach-Brundage, Y., Goldberg, Y., Das, D., Ganchev, K., et al. (2013). Universal dependency annotation for multilingual parsing. In <italic>Proceedings of the 51st annual meeting of the association for computational linguistics</italic> (Vol. 2: Short Papers, pp. 92&#x02013;97). Sofia, Bulgaria.</mixed-citation></ref><ref id="CR44"><mixed-citation publication-type="other">Meyers, A., Reeves, R., Macleod, C., Szekely, R., Zielinska, V., Young, B., et al. (2004). The NomBank project: An interim report. In <italic>Proceedings of HLT-NAACL 2004 workshop: Frontiers in corpus annotation</italic> (pp. 24&#x02013;31). Boston, Massachusetts.</mixed-citation></ref><ref id="CR45"><mixed-citation publication-type="other">Mohanan, K. P. (1982). Grammatical relations and clause structure in Malayalam. In J. Bresnan (Ed.), <italic>The mental representation of grammatical relations</italic>. Cambridge: The MIT Press.</mixed-citation></ref><ref id="CR46"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Mohanan</surname><given-names>T</given-names></name></person-group><source>Argument structure in Hindi</source><year>1994</year><publisher-loc>Stanford</publisher-loc><publisher-name>CSLI Publications</publisher-name></element-citation></ref><ref id="CR47"><mixed-citation publication-type="other">Nivre, J. (2009). Non-projective dependency parsing in expected linear time. In <italic>Proceedings of the joint conference of the 47th annual meeting of the ACL and the 4th international joint conference on natural language processing of the AFNLP</italic> (pp. 351&#x02013;359). Suntec, Singapore.</mixed-citation></ref><ref id="CR48"><mixed-citation publication-type="other">Nivre, J., &#x00026; Nilsson, J. (2005). Pseudo-projective dependency parsing. In <italic>ACL &#x02019;05: Proceedings of the 43rd annual meeting on association for computational linguistics</italic> (pp. 99&#x02013;106). Ann Arbor, Michigan.</mixed-citation></ref><ref id="CR49"><mixed-citation publication-type="other">Nivre, J., Hall, J., K&#x000fc;bler, S., McDonald, R., Nilsson, J., Riedel, S., et al. (2007). The CoNLL 2007 shared task on dependency parsing. In <italic>Proceedings of the CoNLL shared task session of EMNLP-CoNLL 2007</italic> (pp. 915&#x02013;932). Czech Republic, Prague.</mixed-citation></ref><ref id="CR50"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nivre</surname><given-names>J</given-names></name><name><surname>Hall</surname><given-names>J</given-names></name><name><surname>Nilsson</surname><given-names>J</given-names></name><name><surname>Chanev</surname><given-names>A</given-names></name><name><surname>Eryigit</surname><given-names>G</given-names></name><name><surname>K&#x000fc;bler</surname><given-names>S</given-names></name><name><surname>Marinov</surname><given-names>S</given-names></name><name><surname>Marsi</surname><given-names>E</given-names></name></person-group><article-title>MaltParser: A language-independent system for data-driven dependency parsing</article-title><source>Natural Language Engineering</source><year>2007</year><volume>13</volume><issue>2</issue><fpage>95</fpage><lpage>135</lpage></element-citation></ref><ref id="CR51"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Palmer</surname><given-names>M</given-names></name><name><surname>Kingsbury</surname><given-names>P</given-names></name><name><surname>Gildea</surname><given-names>D</given-names></name></person-group><article-title>The proposition bank: An annotated corpus of semantic roles</article-title><source>Computational Linguistics</source><year>2005</year><volume>31</volume><issue>1</issue><fpage>71</fpage><lpage>106</lpage><pub-id pub-id-type="doi">10.1162/0891201053630264</pub-id></element-citation></ref><ref id="CR52"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Reddy</surname><given-names>S</given-names></name><name><surname>Lapata</surname><given-names>M</given-names></name><name><surname>Steedman</surname><given-names>M</given-names></name></person-group><article-title>Large-scale semantic parsing without question&#x02013;answer pairs</article-title><source>Transactions of the Association for Computational Linguistics</source><year>2014</year><volume>2</volume><fpage>377</fpage><lpage>392</lpage></element-citation></ref><ref id="CR53"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Robinson</surname><given-names>J</given-names></name></person-group><article-title>Dependency structures and transformational rules</article-title><source>Language</source><year>1970</year><volume>46</volume><fpage>259</fpage><lpage>285</lpage><pub-id pub-id-type="doi">10.2307/412278</pub-id></element-citation></ref><ref id="CR54"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Shastri</surname><given-names>C</given-names></name></person-group><source>Vyakarana Chandrodya</source><year>1973</year><publisher-loc>New Delhi</publisher-loc><publisher-name>Motilal Banarsidass</publisher-name></element-citation></ref><ref id="CR55"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Steedman</surname><given-names>M</given-names></name></person-group><source>The syntactic process</source><year>2000</year><publisher-loc>Cambridge, MA</publisher-loc><publisher-name>MIT Press</publisher-name></element-citation></ref><ref id="CR56"><mixed-citation publication-type="other">Tse, D., &#x00026; Curran, J. R. (2010). Chinese CCGbank: Extracting CCG derivations from the Penn Chinese Treebank. In <italic>Proceedings of the 23rd international conference on computational linguistics (Coling 2010)</italic> (pp. 1083&#x02013;1091). Beijing, China. Coling 2010 Organizing Committee.</mixed-citation></ref><ref id="CR57"><mixed-citation publication-type="other">Uematsu, S., Matsuzaki, T., Hanaoka, H., Miyao, Y., &#x00026; Mima, H. (2013). Integrating multiple dependency corpora for inducing wide-coverage Japanese CCG resources. In <italic>Proceedings of the 51st annual meeting of the association for computational linguistics</italic> (Volume 1: Long Papers, pp. 1042&#x02013;1051). Sofia, Bulgaria.</mixed-citation></ref><ref id="CR58"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Uematsu</surname><given-names>S</given-names></name><name><surname>Matsuzaki</surname><given-names>T</given-names></name><name><surname>Hanaoka</surname><given-names>H</given-names></name><name><surname>Miyao</surname><given-names>Y</given-names></name><name><surname>Mima</surname><given-names>H</given-names></name></person-group><article-title>Integrating multiple dependency corpora for inducing wide-coverage Japanese CCG resources</article-title><source>ACM Transactions on Asian and Low-Resource Language Information Processing</source><year>2015</year><volume>14</volume><issue>1</issue><fpage>1</fpage><lpage>24</lpage><pub-id pub-id-type="doi">10.1145/2658997</pub-id></element-citation></ref><ref id="CR59"><mixed-citation publication-type="other">Vaidya, A., Husain, S., Mannem, P., &#x00026; Sharma, D. M. (2009). A karaka-based dependency annotation scheme for English. In <italic>Proceedings of computational linguistics and intelligent text processing (CICLing)</italic> (pp. 41&#x02013;52).</mixed-citation></ref><ref id="CR60"><mixed-citation publication-type="other">Xu, W., Clark, S., &#x00026; Zhang, Y. (2014). Shift-reduce CCG parsing with a dependency model. In <italic>Proceedings of the 52nd annual meeting of the association for computational linguistics</italic> (Vol. 1: Long Papers, pp. 218&#x02013;227). Baltimore, Maryland.</mixed-citation></ref><ref id="CR61"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xue</surname><given-names>N</given-names></name><name><surname>Xia</surname><given-names>F</given-names></name><name><surname>Chiou</surname><given-names>F-D</given-names></name><name><surname>Palmer</surname><given-names>M</given-names></name></person-group><article-title>The Penn Chinese TreeBank: Phrase structure annotation of a large corpus</article-title><source>Natural Language Engineering</source><year>2005</year><volume>11</volume><issue>02</issue><fpage>207</fpage><lpage>238</lpage><pub-id pub-id-type="doi">10.1017/S135132490400364X</pub-id></element-citation></ref><ref id="CR62"><mixed-citation publication-type="other">Zhang, Y., &#x00026; Clark, S. (2011). Shift-reduce CCG parsing. In <italic>Proceedings of the 49th annual meeting of the association for computational linguistics: Human language technologies</italic> (pp. 683&#x02013;692). Portland, Oregon, USA.</mixed-citation></ref></ref-list></back></article>