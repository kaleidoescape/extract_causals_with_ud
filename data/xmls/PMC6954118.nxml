<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.2 20190208//EN" "JATS-archivearticle1-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">NPJ Syst Biol Appl</journal-id><journal-id journal-id-type="iso-abbrev">NPJ Syst Biol Appl</journal-id><journal-title-group><journal-title>NPJ Systems Biology and Applications</journal-title></journal-title-group><issn pub-type="epub">2056-7189</issn><publisher><publisher-name>Nature Publishing Group UK</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">31934349</article-id><article-id pub-id-type="pmc">6954118</article-id><article-id pub-id-type="publisher-id">120</article-id><article-id pub-id-type="doi">10.1038/s41540-019-0120-5</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>A scalable method for parameter-free simulation and validation of mechanistic cellular signal transduction network models</article-title></title-group><contrib-group><contrib contrib-type="author" equal-contrib="yes"><name><surname>Romers</surname><given-names>Jesper</given-names></name><xref ref-type="aff" rid="Aff1">1</xref></contrib><contrib contrib-type="author" equal-contrib="yes"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-6482-3928</contrib-id><name><surname>Thieme</surname><given-names>Sebastian</given-names></name><xref ref-type="aff" rid="Aff1">1</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-8939-7643</contrib-id><name><surname>M&#x000fc;nzner</surname><given-names>Ulrike</given-names></name><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author" corresp="yes"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-7843-8342</contrib-id><name><surname>Krantz</surname><given-names>Marcus</given-names></name><address><email>marcus.krantz@rxncon.org</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2248 7639</institution-id><institution-id institution-id-type="GRID">grid.7468.d</institution-id><institution>Institute for Biology, Humboldt-Universit&#x000e4;t zu Berlin, </institution></institution-wrap>Berlin, Germany </aff><aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 0372 2033</institution-id><institution-id institution-id-type="GRID">grid.258799.8</institution-id><institution>Bioinformatics Center, Institute for Chemical Research, Kyoto University, </institution></institution-wrap>Uji, Japan </aff></contrib-group><pub-date pub-type="epub"><day>10</day><month>1</month><year>2020</year></pub-date><pub-date pub-type="pmc-release"><day>10</day><month>1</month><year>2020</year></pub-date><pub-date pub-type="collection"><year>2020</year></pub-date><volume>6</volume><elocation-id>2</elocation-id><history><date date-type="received"><day>18</day><month>8</month><year>2018</year></date><date date-type="accepted"><day>20</day><month>11</month><year>2019</year></date></history><permissions><copyright-statement>&#x000a9; The Author(s) 2020</copyright-statement><license license-type="OpenAccess"><license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article&#x02019;s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article&#x02019;s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p></license></permissions><abstract id="Abs1"><p id="Par1">The metabolic modelling community has established the gold standard for bottom-up systems biology with reconstruction, validation and simulation of mechanistic genome-scale models. Similar methods have not been established for signal transduction networks, where the representation of complexes and internal states leads to scalability issues in both model formulation and execution. While rule- and agent-based methods allow efficient model definition and execution, respectively, model parametrisation introduces an additional layer of uncertainty due to the sparsity of reliably measured parameters. Here, we present a scalable method for parameter-free simulation of mechanistic signal transduction networks. It is based on rxncon and uses a bipartite Boolean logic with separate update rules for reactions and states. Using two generic update rules, we enable translation of any rxncon model into a unique Boolean model, which can be used for network validation and simulation&#x02014;allowing the prediction of system-level function directly from molecular mechanistic data. Through scalable model definition and simulation, and the independence of quantitative parameters, it opens up for simulation and validation of mechanistic genome-scale models of signal transduction networks.</p></abstract><abstract id="Abs2" abstract-type="LongSummary"><title>Modelling: signal transduction at the genome scale</title><p id="Par2">Mechanistic models are like road maps&#x02014;they help us understand how signals travel through cells and guide cellular decisions. We developed a method to turn these models executable at the genome scale, and show that this method can explain and predict cellular physiology directly from molecular mechanisms. The bottom line is that the regulatory structure of the network is encoded in the molecular mechanisms, and we capture this knowledge in two generic update rules. These can be used to assemble molecular mechanisms, LEGO-brick style, into a functional model&#x02014;without parametrisation or model fitting. This makes it possible to use the method for network validation and simulation of systems that are far too large to be parametrised, opening the door to genome-scale mechanistic models of cellular signal transduction.</p></abstract><kwd-group kwd-group-type="npg-subject"><title>Subject terms</title><kwd>Biochemical networks</kwd><kwd>Molecular biology</kwd><kwd>Software</kwd></kwd-group><funding-group><award-group><funding-source><institution-wrap><institution-id institution-id-type="FundRef">https://doi.org/10.13039/501100002347</institution-id><institution>Bundesministerium f&#x000fc;r Bildung und Forschung (Federal Ministry of Education and Research)</institution></institution-wrap></funding-source><award-id>FKZ0316193</award-id><principal-award-recipient><name><surname>Krantz</surname><given-names>Marcus</given-names></name></principal-award-recipient></award-group></funding-group><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#x000a9; The Author(s) 2020</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1" sec-type="introduction"><title>Introduction</title><p id="Par3">Systems biology aims at the integrative analysis of large-scale biological systems up to whole cells. To realise this goal, we integrate knowledge into executable or computational models.<sup><xref ref-type="bibr" rid="CR1">1</xref></sup> This process has been developed the furthest in the field of metabolic modelling, where the community routinely works with genome-scale models. These models are defined at the level of biochemical reactions, cover the entire metabolic network of even complex cells, and can be simulated to predict system-level functionality.<sup><xref ref-type="bibr" rid="CR2">2</xref>,<xref ref-type="bibr" rid="CR3">3</xref></sup> The methodology is well established and supported by rich toolboxes for network reconstruction, validation and simulation,<sup><xref ref-type="bibr" rid="CR4">4</xref></sup> and it constitutes the paradigm for bottom-up modelling. However, these tools cannot be used for signal transduction networks, due to the difference between mass and information transfer networks.<sup><xref ref-type="bibr" rid="CR5">5</xref></sup></p><p id="Par4">Mechanistic modelling of signal transduction is challenging at several levels. First, at the level of model definition: empirical data on site-specific modifications of, or bonds between, signalling components combine combinatorially into a large number of possible configurations, or microstates.<sup><xref ref-type="bibr" rid="CR6">6</xref></sup> This combinatorial complexity effectively makes it impossible to create detailed mechanistic models of large signalling networks using models based on enumeration of microstates (as in e.g. normal ODE-models, Petri nets or SBGN-PD diagrams).<sup><xref ref-type="bibr" rid="CR7">7</xref></sup> Consequently, representation and simulation of these networks were limited to very small and/or heavily simplified models. To solve this, the community developed simulation tools with adaptive resolution, such as the rule-based modelling languages BioNetGen and Kappa.<sup><xref ref-type="bibr" rid="CR8">8</xref>,<xref ref-type="bibr" rid="CR9">9</xref></sup> Second, simulation may be prohibitively expensive even with an efficient model definition, as is the case for classical rule-based modelling, in which the full network of microstates must be generated. This was solved by the development of the network-free simulation tool for rule-based models, NFsim.<sup><xref ref-type="bibr" rid="CR10">10</xref></sup> Third, quantitative dynamic models require rate laws that must be parametrised in terms of rate constants and initial molecule amounts. Reliable information on these quantities is sparse, precluding meaningful parametrisation of most mechanistic models. While the lack of quantitative knowledge is an experimental rather than a theoretical challenge (more dedicated biochemistry is required), a simulation method that voids the need for parametrisation would be extremely helpful in evaluating mechanistic large-scale signalling models until this knowledge gap can be filled.</p><p id="Par5">Parameter-free simulation of cellular networks is typically performed through constraint-based or Boolean methods.<sup><xref ref-type="bibr" rid="CR11">11</xref></sup> Constraint-based methods rely on mass transfer <italic>through</italic> the network, and can therefore not be used to model signal transduction which primarily rely on interaction between and reversible modification of the signalling components. In contrast, Boolean methods can be used to simulate signal transduction networks. In these networks, entities (called &#x0201c;targets&#x0201d; below)&#x02014;typically representing signalling components&#x02014;are either true (active) or false (inactive) and edges define how the target states at time <italic>t</italic>&#x02009;+&#x02009;1 depend on the target states at time <italic>t</italic>. Boolean networks have been used extensively in modelling, and different methods and toolboxes have been developed.<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> However, most of these Boolean models are not <italic>mechanistic</italic>, i.e. they abstract signalling to a binary on/off state of components, ignoring the actual state changes that transmit the information. While such phenomenological modelling have been used to simulate signalling successfully, models that account for the mechanisms of signal transduction increase the explanatory and predictive power by: (i) accounting for signalling components with more than two (on/off) states, such as the cyclin-dependent kinase that are activated against different targets by different cyclins. (ii) Enabling the model to have the same resolution as data, facilitating model creation and evaluation as well as comparison to empirical data. (iii) Supporting functional analysis as e.g. in simulation of the effect of (combinations of) point mutations. Despite the potential advantages, only three mechanistic Boolean modelling methods have been developed until today: one is derived from SBGN-PD diagrams, one from rule-based models, and one is based on rxncon, the reaction-contingency language.<sup><xref ref-type="bibr" rid="CR13">13</xref>&#x02013;<xref ref-type="bibr" rid="CR15">15</xref></sup> These methods support a detailed description of signalling events. However, the first is based on a microstate description, inheriting the scalability issues of these approaches;<sup><xref ref-type="bibr" rid="CR13">13</xref></sup> the second requires a fully parametrised rule-based model, inheriting the problem of parametrisation;<sup><xref ref-type="bibr" rid="CR14">14</xref></sup> and the third inherited shortcomings in expressiveness and precision from the first generation of the rxncon language.<sup><xref ref-type="bibr" rid="CR15">15</xref></sup> Consequently, new methods are needed to support parameter-free, and hence scalable, simulation of signal transduction networks.</p><p id="Par6">Here, we present a parameter-free simulation method that supports large-scale mechanistic models of signal transduction networks. This bipartite Boolean modelling (bBM) logic is based on the second generation rxncon language (Fig. <xref rid="Fig1" ref-type="fig">1</xref>), which is tailored for formalising signal transduction models based on empirical data:<sup><xref ref-type="bibr" rid="CR16">16</xref></sup> the reaction network is defined in terms of <italic>elemental states</italic>, i.e. modifications (or lack thereof) at specific residues and bonds (or lack thereof) at specific domains. The definition is bipartite: <italic>elemental reactions</italic> are decontextualised reaction events that define how elemental states are <italic>synthesised, degraded, produced</italic>, or <italic>consumed</italic>, and <italic>contingencies</italic> define how elemental reactions depend on (combinations of) elemental states that are not changed through the reaction. This structure is kept in the bBM: the <italic>state targets</italic> track which components are present, and in which states the components are (i.e., which domains are (not) bound to which other components and which residues are (un)modified). The <italic>reaction targets</italic> track which reactions are eligible to fire. Through a constructive approach, we define two generic update rules for these two target types, and demonstrated that the update rules can be assembled, LEGO-brick style, into large-scale models without any need for optimisation at the system level. Furthermore, we show that the resulting models meaningfully reproduce the behaviour of signalling processes, and that discrepancies between model behaviour and system-level expectations can be used to identify gaps in the network reconstruction and hence to improve the model. In a parallel effort, we use the rxncon language and the bBM formalism presented here to build and analyse a comprehensive and mechanistically detailed model of the network that controls the cell division cycle in baker's yeast<sup><xref ref-type="bibr" rid="CR17">17</xref></sup>&#x02014;validating both the scalability as well as the explanatory and predictive power of the method. Taken together, we present a scalable method for parameter-free validation of mechanistic signal transduction network models, taking an important step to close the gap in capabilities between metabolic and signal transduction modelling, and introduce a method for scalable simulation of signal transduction networks that supports modelling at the genome scale.<fig id="Fig1"><label>Fig. 1</label><caption><title>The reaction-contingency (rxncon) language employs three essential components.</title><p>Elemental states, elemental reactions, and contingencies. The regulatory graph efficiently represents the regulatory structure of the network. <bold>a</bold> Elemental states are empirical observables: signalling molecules encode information through site-specific state changes, i.e. <italic>covalent modification</italic> of specific <italic>residues</italic> or <italic>bonds</italic> between specific <italic>domains</italic>. All elemental states at a single locus are mutually exclusive with each other and their neutral complements (unmodified and unbound, respectively). However, each elemental state only defines the state at a single locus (two for bonds; cartoon: white boxes), leading to a one-to-many relationship between the (empirically measured) elemental states and the (inferred) microstates. <bold>b</bold> Elemental reactions are indivisible reaction events defined in terms of elemental states. They are only defined in terms of the elemental states that are produced, consumed, synthesised or degraded, similar to the reaction centre of a rule in RBMs, and hence have a one-to-many relationship to microstate reactions. <bold>c</bold> The contingencies define constraints on an elemental reaction in terms of elemental states (or Inputs) that do not change through the reaction. Hence, the contingencies reduce the number of valid microstate reactions, and correspond to the reaction contexts of RBMs. Boolean contingencies, employing AND, OR and NOT gates, can specify arbitrarily detailed constraints down to microstates as necessary. Due to this adaptive resolution, rxncon models can faithfully mirror the empirical knowledge. <bold>d</bold> The regulatory graph (right) provides a compact representation of the regulatory structure of the rxncon network. It is a simplified version of the elemental species-reaction graph (left), leaving out the neutral states to reduce graph complexity, to remove non-informative cycles, and to improve readability. Both graphs are bipartite, with two types of nodes and two types of edges: reaction-to-state (reaction) edges show the effect of each reaction on its source and product states, and state-to-reaction (contingency and source state) edges the impact of states on reactions. The bipartite nature of the graph highlights the requirement for both reactions and contingencies for information transfer through the network, as both types of edges are necessary to traverse the graph. This figure and legend is reproduced from ref. <sup><xref ref-type="bibr" rid="CR17">17</xref></sup>.</p></caption><graphic xlink:href="41540_2019_120_Fig1_HTML" id="d29e392"/></fig></p></sec><sec id="Sec2" sec-type="results"><title>Results</title><sec id="Sec3"><title>A new approach to Boolean modelling</title><p id="Par7">The central result presented in this work is a method to derive a parameter-free Boolean model from a rxncon network, in a completely mechanistic fashion. The starting point is an arbitrary model defined in the second generation rxncon language, and the end point a bipartite Boolean model prepared for simulation with the Boolnet package.<sup><xref ref-type="bibr" rid="CR18">18</xref></sup> The model generation process is implemented in the rxncon compiler, which generates three output files: A.boolnet file containing the model, a.csv file containing the initial values of all targets (see discussion below) and a.csv file linking the model aliases to the original rxncon names. The two first are used to simulate the model, and the third is necessary to interpret the results (see the methods section for detail). Hence, we use a well-established format for Boolean modelling, but the meaning we assign to nodes and edges are fundamentally different than those used in previous Boolean models. Below, we describe the derivation of this modelling logic and exemplify it on two minimal motifs, a small pathway and a detailed model of the yeast pheromone pathway that cannot be meaningfully simulated with conventional methods at this level of mechanistic resolution.</p></sec><sec id="Sec4"><title>A rxncon model uniquely defines a bipartite network</title><p id="Par8">A rxncon model can be represented by a bipartite network (elemental species-reaction graph, see Fig. <xref rid="Fig1" ref-type="fig">1</xref>), which consists of two distinct types of nodes: <italic>elemental states</italic> and <italic>elemental reactions</italic>. These nodes are connected by two distinct types of directed edges: <italic>reaction edges</italic>, which connect elemental reactions to elemental states, and <italic>contingency edges</italic>, which connect elemental states to elemental reactions. The mapping from a rxncon network to an elemental species-reaction graph is unique: the reaction list of the rxncon model contains the information needed to generate the nodes and the reaction edges, i.e. which elemental reactions and states that exist, which elemental reactions change which elemental states, and how. We consider two types of elemental states; <italic>internal states</italic>, which are the property of a single molecule (e.g. covalent modifications such as phosphorylation or ubiquitylation, or an empty binding domain) and <italic>bond states</italic>, which are shared between two molecules or two domains in the same molecule (e.g. protein-protein interactions and intra-protein interactions, respectively). Importantly, both these types of states are <italic>elemental</italic>, meaning they define a single, indivisible property of one molecule (two for intra-molecular bonds), at a single site (two for bonds) which we call residue (for modifications) or domain (for bonds). An elemental reaction can act on each state in one of four different ways: through <italic>synthesis</italic> (the state appears together with the component as the latter is synthesised), <italic>degradation</italic> (the state disappears together with the component as the latter is degraded), <italic>production</italic> (the state appears on an already present component) and <italic>consumption</italic> (the state disappears but the component remains). The mode of action is defined from the perspective of each state. For example, the Cak1_P&#x02009;+&#x02009;_Cdc28_[T169] phosphorylation reaction produces the phosphorylated Cdc28_[(T169)]-{P} state and consumes the unphosphorylated Cdc28_[(T169)]-{0} state (Fig. <xref rid="Fig1" ref-type="fig">1a, b</xref>). The effect of a reaction is directly defined by the <italic>skeleton rule</italic> underlying the reaction.<sup><xref ref-type="bibr" rid="CR16">16</xref></sup> This rule is similar to a rule-based model rule, such as can be defined in BNGL, but consists solely of a centre, without context:<disp-quote><p id="Par9">The definitions, where RHS and LHS refer to the right-hand respectively left-hand side of the skeleton rule, are: <italic>Production:</italic> a state is produced by a reaction if it appears on the RHS, not on the LHS, but the component carrying the state does appear on the LHS. <italic>Consumption:</italic> a state is consumed by a reaction if it appears on the LHS, not on the RHS, but the component carrying the state does appear in the RHS. <italic>Synthesis:</italic> a state is synthesised by a reaction if it appears on the RHS, and the component carrying the state does not appear on the LHS. <italic>Degradation:</italic> a state is degraded by a reaction if the component carrying the state appears on the LHS, no state mutually exclusive with it appears on the LHS, and the component carrying the state does not appear on the RHS.</p></disp-quote></p><p id="Par10">The contingency list contains the information needed to generate the contingency edges, i.e. which elemental states influence which elemental reaction, and how. This information corresponds to the reaction context of rule based models, i.e. they define the contextual constraints on the reactions in terms of elemental states that do not change through the reaction. There are six types of contingencies that define which role an elemental state plays in a reaction: absolutely required (&#x0201c;!&#x0201d;), stimulating (&#x0201c;K+&#x0201d;), no effect (&#x0201c;0&#x0201d;), inhibitory (&#x0201c;K&#x02212;&#x0201d;), absolutely inhibitory (&#x0201c;x&#x0201d;), and no known effect (&#x0201c;?&#x0201d;; treated as &#x0201c;0&#x0201d;). The qualitative contingencies (&#x0201c;!&#x0201d;/&#x0201c;x&#x0201d;) must be fulfilled for a reaction to occur, while the quantitative contingencies (&#x0201c;K+&#x0201d;/&#x0201c;K&#x02212;&#x0201d;) change the rate with which a reaction occurs. Of course, many reactions depend on more than one elemental state, such as reactions requiring dual phosphorylation or the assembly of a multimeric complex. Such complex contingencies that require negation of and/or multiple elemental states can be defined using Boolean (AND, OR, NOT) contingencies, which, for clarity, are visualised as separate nodes in the graph.</p><p id="Par11"><italic>Note</italic>: <italic>The resulting graph is deceptively similar to the bipartite species-reaction graphs used in e.g. metabolic networks or SBGN-PD diagrams. However, the elemental states are not disjunct&#x02014;i.e., a single molecule typically occupies several elemental states. In fact, each molecule must occupy exactly one elemental state for each residue and domain that the molecule contains (see</italic> Fig. <xref rid="Fig1" ref-type="fig">1a</xref><italic>). In contrast, SBGN-PD, the KEGG metabolic maps or Petri nets uses disjunct microstates that are mutually exclusive. Microstates are defined by a combinatorial enumeration of all (relevant) elemental states and therefore associated with severe scalability issues. In these, each molecule occupies exactly one microstate. This critical difference precludes the use of simulation methods developed for disjunct networks, and necessitates the development of a new simulation method tailored to rxncon network models</italic>.</p></sec><sec id="Sec5"><title>From a rxncon network to a Boolean model: basic assumptions and desired model behaviour</title><p id="Par12">The first step in defining the modelling logic is to define what true and false means for the elemental reaction and state targets. The interpretation we assign to the value of these targets is as follows:<list list-type="bullet"><list-item><p id="Par13">If a <italic>reaction target</italic> is true, the cellular regulatory network is, at that point in time, in a configuration where it can accommodate that reaction. This is required, but not sufficient, for the reaction to take place: In the absence of its source state(s), a reaction will not &#x0201c;fire&#x0201d; even though its value is true, as the reaction targets are purely a description of the regulatory layer of the biological cell. In rxncon terms, the reaction updates implement the contingencies.</p></list-item><list-item><p id="Par14">A <italic>state target</italic> is true if there are a sufficient number of molecules carrying that state present in the cell for it to be considered functionally relevant. In rxncon terms, the state updates implement the elemental reactions.</p></list-item></list></p><p id="Par15">The second step is to define the desired model behaviour. We desire both reaction and state targets to describe <italic>system-level</italic> properties, not molecular ones. A consequence of this is, for example, that two states that are mutually exclusive on a single molecule (e.g. a single residue being phosphorylated and unphosphorylated), can be simultaneously true in our Boolean system.</p><p id="Par16">The behaviour of the reaction targets is determined by the contingencies. The basic interpretation is straightforward: reactions should only fire if all required (&#x0201c;!&#x0201d;) and no absolutely inhibitory (&#x0201c;x&#x0201d;) contingencies are fulfilled. We note that quantitative effects (&#x0201c;K+&#x0201d;/&#x0201c;K&#x02212;&#x0201d;) lack interpretation in a deterministic Boolean system, and chose to treat them as no effect (&#x0201c;0&#x0201d;), but also implement the option to treat them as absolutely required or inhibitory, respectively. To accommodate contingencies consisting of multiple elemental states we need to make our first assumption: that any combination of elemental states is true if all single elemental states are true. With this assumption, it becomes straightforward that for a reaction to be true, all required elemental states (&#x0201c;!&#x0201d;) must be true and all absolutely inhibitory elemental states (&#x0201c;x&#x0201d;) must be false.</p><p id="Par17">The state targets are determined by the reactions. Here, we assume a quasi-steady-state at each update step. From this follows a natural hierarchy between the reaction types introduced above: <italic>synthesis</italic> is stronger than <italic>degradation</italic> which is stronger than <italic>production</italic> which is stronger than <italic>consumption</italic>. Due to the crude concept of Boolean time, we consider a quasi-steady-state at each update step. It is then easy to see that a protein that is both synthesised and degraded must be present in the system. In the case where the synthesis reaction is too weak to maintain functional level of the protein, it would be considered off. Similar, production, from the perspective of a specific state, will be dominant over consumption: in the presence of a phosphorylation cycle with both kinases and phosphatases active, both forms will be present. Finally, degradation is dominant over production, as depletion of a protein will deplete the phosphorylated form regardless of kinase activity (except when protected from degradation, as covered by contingencies).</p><p id="Par18">To define the desired behaviour in detail, we designed and studied the minimal irreducible motifs containing two (for modification reactions; Fig. <xref rid="Fig2" ref-type="fig">2a</xref>) or three elemental states (for interactions; Fig. <xref rid="Fig3" ref-type="fig">3a</xref>), and the reactions acting upon them. Each motif contains four reaction types that synthesise, degrade, produce or consume the states. By varying which reactions are active and inactive, and which states are initially present, we arrive at 64 (2<sup>6</sup>) and 128 (2<sup>7</sup>), respectively, distinct models for the two motifs. We define, given an initial configuration for the states and the absence or presence of each of the reactions, the desired steady-state behaviour (Figs. <xref rid="Fig2" ref-type="fig">2b</xref> and <xref rid="Fig3" ref-type="fig">3b</xref>). The crux of the matter then becomes to find update rules for the states so that the (deterministic) attractor reproduces this steady state.<fig id="Fig2"><label>Fig. 2</label><caption><title>Behaviour of a minimal modification motif.</title><p><bold>a</bold> The motif includes two states of A, unphosphorylated (A-{0}) and phosphorylated (A-{P}). The motif contains four different reaction types: component A can be synthesised (in its neutral state A-{0}), degraded (in either state), phosphorylated (consumes A-{0}, produces A-{P}) or dephosphorylated (consumes A-{P}, produces A-{0}). The regulatory and elemental species-reaction graphs of the motif can be found in Supplementary Fig. <xref rid="MOESM1" ref-type="media">1</xref>. <bold>b&#x02013;d</bold> Initial conditions, expectations and simulation results. Each line correspond to the simulation of one or more model variants, and visualise which reactions are active, which states are initiated, which behaviour we expect, and the behaviour we observed. <bold>b</bold> To define the desired behaviour of the motif, we create 64 variants of the motif with each of the four reactions constitutively ON (true) or OFF (false) (columns 1&#x02013;4), and each of the elemental states initially true or false (columns 5 and 6), and define the expected steady state as a function of initial state and active reactions (&#x0201c;Expected attractor&#x0201d;; columns 7 and 8). (I) In the absence of any reactions, the steady state will be identical to the initial state. (II&#x02013;III) In the absence of synthesis or degradation, but in the presence of component A (A-{0} or A-{P} true), the equilibrium depends on the (de)phosphorylation reactions. With only one of these reactions, only the fully (de)phosphorylated form is present at steady state. However, with both reactions present we expect both elemental states to be present at steady state. (IV) With degradation but not synthesis active, the protein will be depleted and both states will be false at steady state. (V) With active synthesis, the neutral state will always be present. The phosphorylated state will only be present if there is also a phosphorylation reaction or if the state is initially present and both the degradation and dephosphorylation reactions are off. <bold>c</bold> The attractors reached after simulation with the update rules in the original ansatz. The attractors correspond to the expected attractors (see B) for 62 out of 64 configurations. The exception are the cyclic attractors in block (III), where both phosphorylation and dephosphorylation are active and only one of the elemental states are initiated as true. <bold>d</bold> The attractors reached after simulation with the smoothed update rules. The attractors are identical to the expected attractors in all cases.</p></caption><graphic xlink:href="41540_2019_120_Fig2_HTML" id="d29e583"/></fig><fig id="Fig3"><label>Fig. 3</label><caption><title>Behaviour of a minimal interaction motif.</title><p><bold>a</bold> The motif includes the unbound state of A (A--0), the unbound state of B (B--0) and the bound state (A--B). As in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, the motif contains four different reaction types: component A can be synthesised (in its neutral state A--0) or degraded (in either state), and Component A and Component B can bind (ppi+; consumes A--0 and B--0, produces A--B) or dissociate (ppi- consumes A--B, produces A--0 and B--0). Not that degradation of A in the A--B dimer releases B--0, hence this reaction is a degradation reaction of A and conditional production reaction for B--0. The regulatory and elemental species-reaction graphs of the motif can be found in Supplementary Fig. <xref rid="MOESM1" ref-type="media">1</xref>. <bold>b&#x02013;d</bold> Initial conditions, expectations and simulation results. Each line correspond to the simulation of one or more model variants, and visualise which reactions are active, which states are initiated, which behaviour we expect, and the behaviour we observed. <bold>b</bold> To define the desired behaviour of the motif, we create 128 variants of the motif with each of the four reactions constitutively ON (true) or OFF (false) (columns 1&#x02013;4), and each of the elemental states initially true or false (columns 5&#x02013;7), and define the expected steady state as a function of initial state and active reactions (&#x0201c;Expected attractor&#x0201d;; columns 8 and 9). As in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, the initial state is preserved when no reaction is active. However, the steady state in the presence of active reactions is more complex, as both unbound states are necessary for the reaction to fire&#x02014;which affects both the generation of the A--B state and the depletion of the unbound states. With degradation and without synthesis, A--0 and A--B is removed, releasing B--0 in the latter case. Finally, synthesis of A only leads to A--B in the presence of the forward reaction, in which case B--0 is depleted unless A--B is turned over by degradation or dissociation. <bold>c</bold> The attractors reached after simulation with the update rules in the original ansatz. The attractors correspond to the expected attractors (see B), except when either component is present in only one state (unbound or bound). This happens in the analogous case to the spurious oscillations in the modification motif in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, but also when A is synthesised if B is only present in one form. <bold>d</bold> The attractors reached after simulation with the smoothed update rules. The attractors are identical to the expected attractors in all cases.</p></caption><graphic xlink:href="41540_2019_120_Fig3_HTML" id="d29e621"/></fig></p></sec><sec id="Sec6"><title>Defining the notation: reactions, states and components</title><p id="Par19">A rxncon system will contain <italic>N</italic><sub><italic>R</italic></sub> reactions denoted by <italic>R</italic><sub><italic>i</italic></sub>, <italic>N</italic><sub><italic>s</italic></sub> elemental states denoted by <italic>S</italic><sub><italic>i</italic></sub>, and <italic>N</italic><sub><italic>c</italic></sub> components denoted by <italic>C</italic><sub><italic>i</italic></sub>. For the components that appear without any internal states, such as e.g. those that solely appear as catalysts, the component is its own state (which does not appear in the original rxncon system). For those components that do carry internal or bond states, the component can be expanded as a Boolean expression of elemental states grouped by the site (domain or residue) on which they live (Eq. <xref rid="Equ1" ref-type="">1</xref>):<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$C_i = \mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {{\rm{site}}\,j\,{\rm{on}}} \\ {{\rm{component}}\,i} \end{array}} {\mathop {\bigcup}\limits_{\begin{array}{*{20}{c}} {{\rm{state}}\,k\,{\rm{on}}} \\ {{\rm{site}}\,j} \end{array}} {S_k} }$$\end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo> &#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">site</mml:mi><mml:mspace width="0.25em"/><mml:mi>j</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">on</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">component</mml:mi><mml:mspace width="0.25em"/><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:munder><mml:mrow><mml:mo>&#x022c3;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">state</mml:mi><mml:mspace width="0.25em"/><mml:mi>k</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">on</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">site</mml:mi><mml:mspace width="0.25em"/><mml:mi>j</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>The origin of this expression is in the mutual exclusivity of elemental states that live on the same residue or domain: for each of these sites, at least one of the states living on the site needs to be present for the component itself to be present. A consequence of this is that for components that carry internal or bond states, the dynamic behaviour of the component is fully determined by the states which the component carries.</p><p id="Par20">Furthermore, we define functions mapping states and reactions to Boolean expressions of states. First, the functions <italic>K</italic>(<italic>R</italic><sub><italic>i</italic></sub>) list the components which are reacting in reaction <italic>R</italic><sub><italic>i</italic></sub> (Eq. <xref rid="Equ2" ref-type="">2</xref>):<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$K\left( {R_i} \right) = \mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {{\rm{component}}\,j} \\ {{\rm{reacts}}\,{\rm{in}}\,R_i} \end{array}} {C_j}$$\end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mi>K</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo> &#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">component</mml:mi><mml:mspace width="0.25em"/><mml:mi>j</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">reacts</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">in</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>whereas the functions <italic>K</italic>(<italic>S</italic><sub><italic>i</italic></sub>) list the components carrying the state <italic>S</italic><sub><italic>i</italic></sub>. Bond states are carried by two components, whereas modifications are carried by one (Eq. <xref rid="Equ3" ref-type="">3</xref>):<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$K\left( {S_i} \right) = \mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {{\rm{component}}\,j} \\ {{\rm{carries}}\,S_i} \end{array}} {C_j}$$\end{document}</tex-math><mml:math id="M6"><mml:mrow><mml:mi>K</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo> &#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">component</mml:mi><mml:mspace width="0.25em"/><mml:mi>j</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">carries</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>In the update rule for the states, we will require the following combinations. First, a reaction together with its source states (Eq. <xref rid="Equ4" ref-type="">4</xref>):<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R_i^\prime = R_i\mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {S_j\,{\rm{consumed}}} \\ {{\rm{by}}\,R_i} \end{array}} {S_j}$$\end{document}</tex-math><mml:math id="M8"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:munder><mml:mrow><mml:mo> &#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">consumed</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">by</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula>The neutral state (unmodified, unbound) counterpart for a particular state <italic>S</italic><sub><italic>i</italic></sub> is denoted by <italic>N</italic>(<italic>S</italic><sub><italic>i</italic></sub>).</p><p id="Par21">These notations enable us to write down the synthesis term &#x003a3;, which describes whether a state is either directly or indirectly being synthesised (Eq. <xref rid="Equ5" ref-type="">5</xref>):<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathrm{\Sigma }}\left( {S_i} \right) = \left\{ {\begin{array}{*{20}{l}}\qquad\qquad {\mathop {\bigcup}\limits_{\begin{array}{*{20}{l}}{R_j\,{\rm{synthesizes}}} \\\qquad {S_i} \end{array}} {R_j^\prime } \,{\mathrm{for}}\,{\mathrm{neutral}}\,{\mathrm{states}}\,S_i} \hfill \\ {\mathop {\bigcup}\limits_{\begin{array}{*{20}{l}} {R_j\,{\rm{synthesizes}}} \\ {N(S_i)} \end{array}} {R_j^\prime } \bigcap \mathop {\bigcup}\limits_{\begin{array}{*{20}{c}} {R_k\,{\rm{produces}}} \\ {S_i} \end{array}} {R_k^\prime } \,{\mathrm{for}}\,{\mathrm{non}}{\text{-}}{\mathrm{neutral}}\,{\mathrm{states}}\,S_i} \hfill \end{array}} \right.$$\end{document}</tex-math><mml:math id="M10"><mml:mrow><mml:mi mathvariant="normal">&#x003a3;</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced close="" open="{" separators=""><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mspace width="2.0em"/><mml:mspace width="2.0em"/><mml:munder><mml:mrow><mml:mo>&#x022c3;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">synthesizes</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mspace width="2.0em"/><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">for</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">neutral</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">states</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:munder><mml:mrow><mml:mo>&#x022c3;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">synthesizes</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup><mml:mo mathsize="big"> &#x022c2;</mml:mo><mml:munder><mml:mrow><mml:mo>&#x022c3;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">produces</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:munderover><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">for</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">non</mml:mi><mml:mi mathvariant="normal">-</mml:mi><mml:mi mathvariant="normal">neutral</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">states</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>All systems we considered contain only states &#x0201c;one step&#x0201d; removed from the neutral states, so the expression for non-neutral states describes an active path coming from the synthesised state to the state under consideration. For states that are multiple steps removed from the synthesised neutral state, this expression has to be appropriately amended.</p><p id="Par22">Finally, we denote the Boolean expression representing the contingency for reaction <italic>R</italic><sub><italic>i</italic></sub> by <italic>L</italic>(<italic>R</italic><sub><italic>i</italic></sub>) (Eq. <xref rid="Equ6" ref-type="">6</xref>):<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$L\left( {R_i} \right) = \mathop {\bigcap}\limits_j {L_j^!} (R_i)\mathop {\bigcap}\limits_k {\overline {L_k^ \times (R_i)} }$$\end{document}</tex-math><mml:math id="M12"><mml:mrow><mml:mi>L</mml:mi><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo> &#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>!</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mo>&#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x000d7;</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula>where the <inline-formula id="IEq1"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$L_j^!(R_i)$$\end{document}</tex-math><mml:math id="M14"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>!</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="41540_2019_120_Article_IEq1.gif"/></alternatives></inline-formula> and <inline-formula id="IEq2"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$L_k^x(R_i)$$\end{document}</tex-math><mml:math id="M16"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="41540_2019_120_Article_IEq2.gif"/></alternatives></inline-formula> enumerate the required, respectively, inhibitory contingencies for reaction <italic>R</italic><sub><italic>i</italic></sub>, which are themselves possibly nested Boolean expressions.</p><sec id="Sec7"><title>The expected behaviour of a small reaction circuit and update rule ansatz</title><p id="Par23">The reaction update rules are quite straightforward. We require the strict contingencies for the reaction to be satisfied and the presence of the components on which the reaction acts (Eq. <xref rid="Equ7" ref-type="">7</xref>):<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R_i\left( {t + 1} \right) = K(R_i;t) \cap L(R_i;t)$$\end{document}</tex-math><mml:math id="M18"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02229;</mml:mo><mml:mi>L</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula></p><p id="Par24">The state update rules are more complex and explicitly require the hierarchy between types of reactions that was alluded to above. First of all, if a state is synthesised by any reaction, it will be true. If synthesis is false, the necessary, but not sufficient, requirement for the state to be true is that degradation is also false, and that the component(s) carrying the state are present. Now, there are two options for the state to be true: either the state is being produced by some reaction, in which case it is immaterial what the previous value of the state was, or the state was already true and it is not being consumed by any reaction (Figs. <xref rid="Fig2" ref-type="fig">2</xref> and <xref rid="Fig3" ref-type="fig">3</xref>). Eq. <xref rid="Equ8" ref-type="">8</xref>:<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_i\left( {t + 1} \right) = {\mathrm{\Sigma }}(t) \bigcup \left( {K(S_i;t)\mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {R_k{\rm{degrades}}} \\ {S_i} \end{array}} {\overline {R_k^\prime } (t)} \bigcap \left\{ {\mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {R_l\,{\rm{produces}}} \\ {S_i} \end{array}} {{R_l^\prime } (t)} \bigcup \left[ {S_i(t)\mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {R_m{\rm{consumes}}} \\ {S_i} \end{array}} {\overline {R_m^\prime } (t)} } \right]} \right\}} \right)$$\end{document}</tex-math><mml:math id="M20"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x003a3;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo mathsize="big">&#x022c3;</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mo>&#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal">degrades</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo accent="true">&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo mathsize="big">&#x022c2;</mml:mo><mml:mfenced close="}" open="{" separators=""><mml:mrow><mml:munder><mml:mrow><mml:mo>&#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">produces</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo mathsize="big">&#x022c3;</mml:mo><mml:mfenced close="]" open="[" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mo>&#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal">consumes</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:mover accent="true"><mml:mrow><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:munderover></mml:mrow><mml:mo accent="true">&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula></p><p id="Par25">In other words, a state remains true as long as it is neither consumed nor degraded. If a reaction produces the state, it becomes or remains true even when it is actively consumed, but not if it is degraded. Finally, if the state is synthesised, it becomes or remains true regardless of any other active reaction. See supplementary discussion for an example.</p><p id="Par26">As can be seen in this formula, the translation of &#x0201c;the state is being produced&#x0201d; <italic>et cetera</italic> contains the primed reactions, meaning the reaction producing that state and the source state(s) of that reaction (see Eq. <xref rid="Equ4" ref-type="">4</xref>). This is due to the semantics of the reaction targets, which only tell us about the regulatory state of the network.</p><p id="Par27">Note that most reactions act on multiple states (typically source and product states). It is imperative that these are updated simultaneously to avoid simulation artefacts. Hence, we use only synchronous deterministic update schemes.</p></sec></sec><sec id="Sec8"><title>Testing the generic update rules</title><p id="Par28">To test if the update logic described above captures the expected behaviour, we implemented the model generation process and used it to generate the 64 models corresponding to the minimal modification circuitry above (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). The models were simulated using BoolNet,<sup><xref ref-type="bibr" rid="CR18">18</xref></sup> as described in the methods. The attractor states are visualised in Fig. <xref rid="Fig2" ref-type="fig">2c</xref>. The model behaviours correspond to our expectations with one notable exception. In the absence of synthesis and degradation, but in the presence of both phosphorylation and dephosphorylation, the model displays an oscillatory behaviour when only one of the two states is initiated. Closer inspection reveals that this is due to periodic source state depletion. The phosphorylation and dephosphorylation reactions are constitutive (no contingencies, no loss of components), and the oscillations occur due to the state updates, which are completely encoded in the state update rule. Indeed, as soon as a reaction executes, dependent on its source state, it depletes the source state pool. Hence, the reactions alternate in firing, triggering out-of-phase oscillations in the truth value of the states. Consistently, these oscillations disappear when both states are initiated or when the source state is repleted through synthesis. We observe the same phenomenon in the interaction motif, when the reaction cycle is active and at least one component is initiated in and remains in a single form (Fig. <xref rid="Fig3" ref-type="fig">3c</xref>). We consider these spurious oscillations undesirable in our systems-level description, but note that they would be appropriate for models of single molecules. Nevertheless, the outcome is highly encouraging, as 62 out of 64 models matched the expected behaviour.</p></sec><sec id="Sec9"><title>Source state smoothing eliminates the spurious oscillations</title><p id="Par29">To eliminate the oscillations that plagued our initial ansatz, we adapted the updates rules for states by widening the window in which we checked for source state availability: a reaction needs the source state to be present, or to be produced. To achieve this, in Eq. (<xref rid="Equ8" ref-type="">8</xref>) we substitute for the reactions producing the state, <italic>R&#x02019;</italic><sub><italic>l</italic></sub> the following (Eq. <xref rid="Equ9" ref-type="">9</xref>):<disp-formula id="Equ9"><label>9</label><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R_l^{\prime\prime} (t) = R_l(t)\mathop {\bigcap}\limits_{\begin{array}{*{20}{c}} {S_j\,{\rm{consumed}}} \\ {{\rm{by}}\,R_l} \end{array}} {S_j(t)}\,{\bigcup}\, {S_j(t + 1)}$$\end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02033;</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mo>&#x022c2;</mml:mo></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">consumed</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi mathvariant="normal">by</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.25em"/><mml:mo mathsize="big">&#x022c3;</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math><graphic xlink:href="41540_2019_120_Article_Equ9.gif" position="anchor"/></alternatives></disp-formula>where the S<sub>j</sub>(t + 1) is the full expression (Eq. <xref rid="Equ8" ref-type="">8</xref>), without this substitution.</p><p id="Par30">We consider this adaptation quite natural: there are large numbers of molecules undergoing the same set of reactions. Therefore, it is highly unlikely that all of these reactions are temporally completely in phase, justifying a smoothing over molecules. In addition, the time scale in a Boolean model is basically set by the slowest of the reactions, since all rate constants are absent. For molecule pools acted upon by reactions that are faster than the slowest in the system, it is likely that they will pass through mutually exclusive states within the window of a Boolean time step, justifying a &#x0201c;time smoothing&#x0201d;. Both effects are captured by the reworked update rules.</p><p id="Par31">The smoothing assumption only breaks down in the context of few molecules and low reaction rates, and there are cases in which smoothing is inappropriate. In other work,<sup><xref ref-type="bibr" rid="CR17">17</xref></sup> we have introduced a hybrid model containing both the molecular reactions and states described here, and additionally macroscopic reactions and states that are governed by the non-smoothed update rules. However, for most states in a signal transduction network, the smoothed update rule is more appropriate. Having established the smoothing logic, we implemented it into the rxncon compiler tool and recreated the 64 modification motif (Fig. <xref rid="Fig2" ref-type="fig">2</xref>) and 128 interaction motif (Fig. <xref rid="Fig3" ref-type="fig">3</xref>) models with smoothing. We repeated the simulation and compared the results to the original simulation (Fig. <xref rid="Fig2" ref-type="fig">2d</xref>, Fig. <xref rid="Fig3" ref-type="fig">3d</xref>). The oscillatory behaviour disappeared, but no other simulation results changed. Hence, the simulation results exactly match the behaviour we expect from a model of these reaction motifs.</p></sec><sec id="Sec10"><title>The update rules can be used as LEGO bricks to assemble a systems level model</title><p id="Par32">Next, we applied the bBM logic to simulate a linear pathway. Both the reaction and contingency motifs are fully defined at the local level, as they only depend on the reactions (for state updates) and the contingencies (for reaction updates) in the system. We postulated that these locally defined update rules would suffice to define system-level function, and tested this hypothesis with a simplified model of the HOG MAP kinase pathway from <italic>Saccharomyces cerevisiae</italic> (Fig. <xref rid="Fig4" ref-type="fig">4</xref>; adapted from<sup><xref ref-type="bibr" rid="CR15">15</xref></sup>). We created a rxncon 2.0 model of this pathway (Supplementary Model 1), and used this to generate the bBM using the generic update rules with smoothing (see Supplementary discussion for implementation details). Already this small model has 28 reaction and state, and hence 2<sup>28</sup> (~10<sup>8</sup>) possible initial states. We deemed this too many for an exhaustive search, and decided to use a generic start state for all simulations: all neutral elemental states (that is, unbound binding domains and neutral modifications) are true, all generic component states (for components with no elemental states) are true, and all other targets are false. From this highly artificial initial state, we let the model find its own natural &#x0201c;off state&#x0201d; by executing it until an attractor is reached (Fig. <xref rid="Fig4" ref-type="fig">4b</xref>). At this point, we take this attractor as a new initial state and change the input state (Turgor in this case) and repeat to see the response of the pathway to the input, and repeat this process until the model returns to a state vector we have already seen. As can be seen from Fig. <xref rid="Fig4" ref-type="fig">4b</xref>, the HOG pathway responds appropriately to turgor: it turns off the kinase cascade. For comparison, we repeated the simulation with the non-smoothed logic (Fig. <xref rid="Fig5" ref-type="fig">5a</xref>), where we see the signal passing through the network despite spurious oscillations. However, the system does not converge to point attractors, leading to more complex analysis and interpretation. There are three striking blocks in the heatmap (Fig. <xref rid="Fig4" ref-type="fig">4b</xref>): first, the initial neutral states never turn off. Second, there is a block of reactions that turns on directly, and stays on throughout the simulation. Third, there is a block that turns on and off in response to the signal. The third block contains the reactions and states that actually transmit the information. The second block contains constitutive reactions, which are either unregulated (e.g. dephosphorylation reactions), or regulated at the level of source state availability (e.g. phosphotransfer from Sln1 to Ypd1). The first block contains all the neutral states. These remain true because the reactions that produce them are considered unregulated, which may be due to experimental bias as discussed below. Hence, the logic of the generic update rules is sufficient to convert the molecular level knowledge in a rxncon network into a functional bBM that accurately predicts system-level function. It is highly non-trivial that generic update rules, which were defined for isolated reactions and states, suffice to define a complete model that functions at the systems level, with no further tweaking or parametrisation. Taken together, the generic update rules map a given rxncon network on a unique Boolean model that predicts systems level function.<fig id="Fig4"><label>Fig. 4</label><caption><title>From reactions to a functional pathway.</title><p>We used the smoothed update rules to generate and simulate a model of the Sln1 branch of the high osmolarity glycerol (HOG) pathway. <bold>a</bold> The pathway visualised as a rxncon regulatory graph. In the absence of turgor, Sln1 stays unphosphorylated. As turgor increases, the auto-phosphorylation of Sln1 initiates a phosphotransfer cascade converging at Ssk1. The phosphorylated form of Ssk1 turns off the downstream MAP kinase pathway leading to dephosphorylation of the downstream transcription factor Hot1. The dashed line indicates a feedback loop that is included in the cyclic version only. The model has 29 different targets: 12 reaction targets (pink nodes), 16 state targets corresponding to 15 elemental states (blue nodes) and a component state for the phosphatase (not displayed in the graph), and the single input/output target &#x0201c;Turgor&#x0201d; (grey node). <bold>b</bold> Simulation of a linear version of the model using source state smoothing of the update rules. (I) We use our default assumptions on the initial state and simulate the model until we reach an attractor (first OFF trajectory). (II) We activate the system by turning [Turgor] ON and simulate again (ON trajectory) until we reach an attractor state. (III) From there, we set [Turgor] OFF again and simulate the model until we reach an attractor. We observe that the model responds as expected to the input. <bold>c</bold> We extended the HOG model with a feedback loop, where activation of the pathway leads to increased turgor (via Hot1-{P}). This is simplification of an adaptive response through increased glycerol production and retention, which increases turgor. We simulate this model from the initial OFF attractor (see panel B), and note that the system oscillates as expected: the trajectory is cyclic, where the last time step is followed by the first, and turgor is now a model variable that turns on and off during the cycle (grey row in the heatmap).</p></caption><graphic xlink:href="41540_2019_120_Fig4_HTML" id="d29e1912"/></fig><fig id="Fig5"><label>Fig. 5</label><caption><title>Smoothing is required to make pathway simulation interpretable.</title><p>We repeated the simulation of the HOG pathway with the un-smoothed update rules from the initial ansatz. <bold>a</bold> Simulation of the linear model without smoothing. The signal goes through the pathway, but analysis is complicated by the spurious oscillations as the system no longer converges on point attractors. Each of the three simulation trajectories (I-III) ends with a cyclic attractor of length two. <bold>b</bold> Simulation of the cyclic HOG model without smoothing. Here, the entire oscillation cycle breaks down into a period two oscillator involving all the states (and their complements) and reactions that transmit the information.</p></caption><graphic xlink:href="41540_2019_120_Fig5_HTML" id="d29e1929"/></fig></p></sec><sec id="Sec11"><title>The bipartite Boolean logic correctly reproduces real oscillations</title><p id="Par33">The HOG pathway is a homeostatic pathway that maintains proper turgor pressure. The pathway output eventually leads to signal cessation through a physiological feedback loop.<sup><xref ref-type="bibr" rid="CR19">19</xref></sup> To simulate this, we linked the most downstream component to the input that turns the pathway off (dashed line in Fig. <xref rid="Fig4" ref-type="fig">4a</xref>). We repeated the model creation and simulation, using the initial steady state of the linear model as starting condition. As shown in Fig. <xref rid="Fig4" ref-type="fig">4c</xref>, the model now shows a periodic activation/deactivation behaviour, similar to that when the input is changed manually. Hence, the bBM logic is fully capable of predicting biologically relevant oscillations. As comparison, we also simulated the cyclic HOG model without source state smoothing (Fig. <xref rid="Fig5" ref-type="fig">5b</xref>). Here, the pathway signal is completely washed out by the spurious oscillations and breaks down to a two-state cyclic attractor. The source state smoothing facilitates bBM analysis and clearly improves the interpretability of the simulation results. Taken together, the bBM logic generates Boolean models that can predict systems level function for both linear and cyclic systems.</p></sec><sec id="Sec12"><title>The bipartite Boolean logic scales to large-scale systems</title><p id="Par34">Finally, we applied the method on the pheromone response pathway of baker&#x02019;s yeast. We chose this pathway to benchmark the bBM method due to the existence of an excellently annotated, comprehensive and mechanistically detailed rule based model (RBM).<sup><xref ref-type="bibr" rid="CR20">20</xref></sup> The original RBM contains 229 rules with 200 parameters (166 unknown) that define how 18 components can assume over 200.000 distinct states (<ext-link ext-link-type="uri" xlink:href="http://yeastpheromonemodel.org/wiki/Extracting_the_model">http://yeastpheromonemodel.org/wiki/Extracting_the_model</ext-link>). While this is one of the most carefully built and curated RBMs, it remains difficult to meaningfully simulate it as such.<sup><xref ref-type="bibr" rid="CR21">21</xref></sup> Hence, it constitutes an excellent benchmark target for the bBM method.</p><p id="Par35">We simulated the pheromone bBM using a standardised simulation workflow.<sup><xref ref-type="bibr" rid="CR22">22</xref></sup> The rxncon translation of the RBM, which is described elsewhere,<sup><xref ref-type="bibr" rid="CR16">16</xref></sup> is defined by 95 elemental reactions and 231 (non-zero) contingencies. We generated the bBM using the smoothed update rules, which produced a bipartite Boolean model with 130 reaction targets (due to separation of bidirectional reactions and duplication of degradation reactions) and 118 state targets. With 248 targets, the model is too large to use an exhaustive search of initial states (statespace = 2<sup>248</sup>; ca 10<sup>74</sup> distinct configurations), so we fall back on our default initiation state vector (all neutral state targets are true, all generic component targets true, all other targets are false). From this initial state, we first simulated the model to a first point attractor, to let it find its natural &#x0201c;off state&#x0201d;, as explained for the HOG pathway above: thereafter, we iteratively switched the input to true and false. Analysing the outcome, we found that the pathway was constitutively active and unresponsive to pheromone. First, we examined if this was due to the interpretation of quantitative effects that are lost in the Boolean model. However, neither treating all quantitative (&#x0201c;K+&#x0201d;/&#x0201c;K&#x02212;&#x0201d;) contingencies as absolute (&#x0201c;!&#x0201d;/&#x0201c;x&#x0201d;), nor treating them as no effect (&#x0201c;0&#x0201d;), solves the problem. Furthermore, the original RBM was never simulated and proven to be functional. Hence, we proceeded with the minimal model (treating quantitative contingencies as no effect) and looked deeper into the pathway behaviour, finding that it activates in the absence of signal due to constitutive release of Ste4, which represents the beta/gamma subunit of the trimeric G-protein at the top of the cascade, as well as constitutively free&#x02014;and hence active&#x02014;Ste12. To address these problems, we change four quantitative contingencies into qualitative contingencies. In addition, we needed to limit turnover of Ste4 bound Gpa1 (to prevent signal-independent release of unbound Ste4, the activator of the pathway) and to remove Fus3 dependent degradation of Ste12 which made the pathway &#x0201c;single-shot&#x0201d;. The final model with changes can be found in Supplementary Model <xref rid="MOESM2" ref-type="media">2</xref>, and the simulation trajectories are shown in Fig. <xref rid="Fig6" ref-type="fig">6</xref>. This updated version of the model responds to pheromone exposure and withdrawal as expected, despite containing 83 quantitative contingencies&#x02014;which are ignored in the model generation&#x02014;indicating that a much simpler model would suffice to capture the key features of the pathway.<fig id="Fig6"><label>Fig. 6</label><caption><title>The updated pheromone model responds as expected to pheromone.</title><p>We generated a bBM form the updated pheromone model and (I) simulated it in the absence of pheromone (unbound pheromone set to false) until the first steady state, where (II) free pheromone was set to true, representing pheromone stimulation, and the simulation repeated until next steady state was reached, before (III) pheromone was removed (by setting both free and bound pheromone to false) and the model simulated to the next steady state. The pathway turns on and off as expected, and finds a natural off state in the first simulation despite two activation pulses that go through the pathway. These are due to proteins that activate the pathway in their neutral states: the upstream Ste4, as discussed in the text, and the Ste12 transcription factor&#x02014;which, according to the model, is active when not bound to Dig1 and Dig2. However, both pulses are transient and the steady state is robust against these transient dynamics. Panel (<bold>a</bold>) displays the input and output trajectories and panel (<bold>b</bold>) all the 248 state and reaction trajectories with the 149 unregulated targets condensed to three lines. Grey lines in (<bold>b</bold>) indicate the input/output states as displayed in (<bold>a</bold>).</p></caption><graphic xlink:href="41540_2019_120_Fig6_HTML" id="d29e2011"/></fig></p></sec></sec><sec id="Sec13" sec-type="discussion"><title>Discussion</title><p id="Par36">Here, we present a qualitative simulation method for large-scale, mechanistically detailed signal transduction network models. The formalism is based on Boolean logic and can be simulated and studied by a standard package such as BoolNet. However, we present a fundamentally new concept to formulate Boolean models. First, we create a bipartite model at the level of elemental reactions and states, capturing the key elements in signal transduction at an appropriate resolution for mechanistic modelling of these processes. Second, based on detailed analysis of two minimal reaction motifs, and on a small set of standard assumptions, we define two generic update rules: one for reaction targets and one for state targets. These generic update rules map a bipartite rxncon network on a unique bBM with defined truth tables. The elemental reactions define the update rules for the state targets, and the contingencies define the update rules for the reaction targets. We show that these building blocks can be assembled like LEGO bricks into a bipartite Boolean model that predicts system-level function from molecular mechanisms, without optimisation at the system level.</p><p id="Par37">The unique mapping from rxncon to an executable bBM that predicts system behaviour is highly non-trivial. Normally, it is relatively easy to build a Boolean model structure, but challenging to define truth tables that enable the model to reproduce the behaviour of the system.<sup><xref ref-type="bibr" rid="CR23">23</xref></sup> Here, we find that the regulatory structure encoded in the rxncon network already uniquely defines a Boolean model with set truth tables, and that this Boolean model meaningfully predicts system-level behaviour. Thus, the bBM logic we present here bridges the microscopic (biochemical reactions) and macroscopic (input-output) levels of cellular signal transduction, fulfilling the requirements for the cellular &#x0201c;mechanics&#x0201d; proposed by Hlavacek and Faeder&#x02014;at least qualitatively.<sup><xref ref-type="bibr" rid="CR6">6</xref></sup></p><p id="Par38">This has far-reaching implications: first, it provides an efficient validation tool in the model building process. This allows the model construction to be separated in to two phases: a qualitative and a quantitative phase. Boolean models are computationally inexpensive, and the automatic model generation supports iterative model creation, analysis and improvement. In addition, we are better equipped with knowledge at the qualitative level, suggesting that this level should be optimised first. As rxncon supports compilation into both RBMs and bBMs (as well as several graphical formats), it can be used to facilitate this process:<sup><xref ref-type="bibr" rid="CR22">22</xref></sup> the structural model can be created and validated using graphical tools and bBM simulation, and later the improved network can be used to create a rule-based model. Hence, the more expensive parameterisation cycles can be performed after the qualitative model has passed the validation process. Second, the bBM method can be used for validation of large-scale signal transduction networks. Previously, large-scale reconstruction of signal transduction has been limited to graphical maps that cannot be executed.<sup><xref ref-type="bibr" rid="CR24">24</xref>&#x02013;<xref ref-type="bibr" rid="CR26">26</xref></sup> The method we present here changes this: we can now validate&#x02014;through simulation&#x02014;large-scale reconstructions of signal transduction networks.</p><p id="Par39">The bBM formalism we presented here is fundamentally different from its previous incarnation.<sup><xref ref-type="bibr" rid="CR15">15</xref></sup> First, it has been designed to capture system-level behaviour, not the states of individual molecule instances in the network, meaning that states that would be mutually exclusive on a single molecule can be true at the same time. As we show in Fig. <xref rid="Fig5" ref-type="fig">5</xref>, this is critical for meaningful system-level predictions. Second, we used a constructive approach, defining all possible behaviours at the level of two families of minimal reaction motifs, to design two generic update rules. These update rules can be used to map any rxncon system, even extended by new reaction types, through the interpretation of the flexible skeleton rule definition as synthesis, degradation, production or consumption of different states. Third, the method we present here inherits the expressiveness and flexibility of rxncon 2.0, including the explicit representation of neutral states.<sup><xref ref-type="bibr" rid="CR16">16</xref></sup> Fourth, the reimplementation has improved the model generation, enabled the use of different export options, and improved the model creation and analysis workflow. While the previous incarnation worked well in many instances,<sup><xref ref-type="bibr" rid="CR15">15</xref>,<xref ref-type="bibr" rid="CR27">27</xref>,<xref ref-type="bibr" rid="CR28">28</xref></sup> these models had issues with certain reaction types (most notably degradation) and spurious oscillations. That the latter appeared so rarely was due to the implicit dominance of modified states: neutral states were not explicitly represented, making modification or binding reactions dominant over reactions that returned components to their neutral state. Here, we eliminate this artificial hierarchy, which we consider undesirable, and explicitly include the neutral states. However, most of these states are constantly true in our simulations. This may have two reasons: first, it could reflect biology: there would be a constant pool of unmodified components as long as there is a constant turnover (and hence synthesis, which per definition occurs in the neutral states). Second, it could reflect an experimental bias, as we know much more about the modifying reactions than about the reactions that reverse the modification (e.g. phosphorylation vs dephosphorylation,<sup><xref ref-type="bibr" rid="CR29">29</xref></sup>). If so, the formalism we present here helps us make this information bias explicit, and will allow us to integrate the regulation on these reactions as the knowledge becomes available.</p><p id="Par40">Finally, the method enables a scale-shift in signal transduction modelling. Hitherto, executable signalling models have been mechanistically detailed or large-scale, but not both. Most mechanistic large-scale reconstructions are technically microstate models that could be simulated after parametrisation. However, they are actually divided into several unconnected modules and could hence not be simulated at the system level.<sup><xref ref-type="bibr" rid="CR24">24</xref>&#x02013;<xref ref-type="bibr" rid="CR26">26</xref></sup> Rule-based modelling languages have been used to build relatively large models,<sup><xref ref-type="bibr" rid="CR21">21</xref>,<xref ref-type="bibr" rid="CR30">30</xref></sup> but even these models are limited to few (18 in these cases) components and parametrisation is already an outstanding challenge. In contrast, comprehensive signalling models will need to account for hundreds or thousands of signalling components, carrying many thousands of distinct elemental states. Here, we present a method that can deal with mechanistic signalling networks at this scope, and we have successfully used this method to build and analyse a comprehensive mechanistic model of the yeast cell division cycle, which accounts for 229 proteins, 790 elemental reactions and 1238 elemental states down to residue resolution when applicable<sup><xref ref-type="bibr" rid="CR17">17</xref></sup>&#x02014;far beyond the potential of previous mechanistic modelling. The method is qualitative, but this may be an advantage given the sparsity of reliable quantitative information on rate constants. In addition, even metabolic modelling&#x02014;clearly the state of the art in genome-scale modelling&#x02014;is limited to qualitative or semi-quantitative simulation methods at the genome scale.<sup><xref ref-type="bibr" rid="CR31">31</xref></sup></p><p id="Par41">Taken together, we present a parameter-free model creation and simulation method for models of signal transduction. Unique models are generated directly from empirical data formalised in the rxncon 2.0 language, without need for fitting or optimisation. For the first time, we can simulate mechanistic models of signal transduction network at the genome scale.</p></sec><sec id="Sec14"><title>Methods</title><sec id="Sec15"><title>rxncon installation and execution</title><p id="Par42">The rxncon framework requires Python 3.5 or 3.6. Make sure you have one of these Python versions installed. Anaconda (<ext-link ext-link-type="uri" xlink:href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</ext-link>) provides an easy way to install the most current Python version. With Python installed and up to date, you are ready to install rxncon:</p><p id="Par43">Under Windows:<list list-type="order"><list-item><p id="Par44">Open the console and type &#x0201c;pip install rxncon&#x0201d;.<xref ref-type="fn" rid="Fn1">1</xref> The default installation folder will depend on your Python installation. With Anaconda, the rxncon folder appears in [user]/Anaconda3/lib/Site-packages. The files you will need to call appear in [user]/Anaconda3/Scripts.</p></list-item><list-item><p id="Par46">To test the installation, navigate the console to the folder with the scripts and type &#x0201c;python rxncon2bngl.py&#x0201d;.<xref ref-type="fn" rid="Fn2">2</xref> Expect a string &#x0201c;Usage: rxncon2bngl.py [OPTIONS] EXCEL_FILE&#x0201d; and an error message &#x0201c;Error: Missing argument &#x0201c;excel_file&#x0201d;.</p></list-item></list></p><p id="Par48">Under OS X:<list list-type="order"><list-item><p id="Par49">Open the console and type &#x0201d;pip install rxncon&#x0201d;. The default installation folder will depend on your Python installation. With Anaconda, the rxncon folder appears in [user]/Anaconda3/lib/python3.6/Site-packages. The files you will need to call appear in [user]/Anaconda3/bin.</p></list-item><list-item><p id="Par50">To test the installation, navigate the console to the folder with the scripts and type &#x0201c;python rxncon2bngl.py&#x0201d;.<xref ref-type="fn" rid="Fn3">3</xref> Expect a string &#x0201c;Usage: rxncon2bngl.py [OPTIONS] EXCEL_FILE&#x0201d; and an error message &#x0201c;Error: Missing argument &#x0201c;excel_file&#x0201d;.</p></list-item></list></p><p id="Par52">Under Linux:<list list-type="order"><list-item><p id="Par53">Make sure you have PIP installed. If not, use your package manager to install it. E.g., on debian-based systems type &#x0201c;sudo apt install python3-pip&#x0201d;.</p></list-item><list-item><p id="Par54">Open a terminal and type &#x0201c;pip3 install rxncon &#x02013;user&#x0201d;. This installs into $HOME/.local, the executables are in $HOME/.local/bin.</p></list-item></list><list list-type="simple"><list-item><label>3.</label><p id="Par55">To get easy access to the rxncon scripts, you can update your PATH environment variable to include this directory: put something like &#x0201c;export PATH=$HOME/.local/bin:$PATH&#x0201d; into your .bashrc.</p></list-item><list-item><label>4.</label><p id="Par56">To test the installation, type &#x0201c;rxncon2bngl.py&#x0201d;.<xref ref-type="fn" rid="Fn4">4</xref> Expect a string &#x0201c;Usage: rxncon2bngl.py [OPTIONS] EXCEL_FILE&#x0201d; and an error message &#x0201c;Error: Missing argument &#x0201c;excel_file&#x0201d;.</p></list-item></list></p><sec id="Sec16"><title>Boolnet installation</title><p id="Par58">The logical simulation of rxncon networks uses BoolNet, an R package. To use these tools:<list list-type="order"><list-item><p id="Par59">(Optional) Download and install R-studio (<ext-link ext-link-type="uri" xlink:href="https://www.rstudio.com">https://www.rstudio.com</ext-link>).<xref ref-type="fn" rid="Fn5">5</xref></p></list-item><list-item><p id="Par61">Make sure you have R installed. R can be installed through Anaconda, by opening the console and typing: &#x0201c;conda install &#x02013;c r r-essentials&#x0201d;.<xref ref-type="fn" rid="Fn6">6</xref></p></list-item><list-item><p id="Par63">The BoolNet package can be installed from R. In the console, type &#x0201c;R&#x0201d; to enter the R environment. Then type &#x0201c;install.packages(&#x0201c;BoolNet&#x0201d;)&#x0201d; and select the download server.</p></list-item></list></p></sec><sec id="Sec17"><title>Model creation and analysis</title><p id="Par64">The creation of the rxncon models are described elsewhere. The High Osmolarity Glycerol (HOG) model was taken from<sup><xref ref-type="bibr" rid="CR15">15</xref></sup> and adapted to rxncon 2.0. The pheromone (PHER) model was translated from the yeastpheromonemodel.org wiki as described in.<sup><xref ref-type="bibr" rid="CR16">16</xref></sup> The bipartite Boolean model files were created with the rxncon compiler software, by calling the &#x0201c;rxncon2boolnet.py&#x0201d; script on the model (.xls) files with default setting:</p><p id="Par65">
python rxncon2boolnet.py path/model.xls
</p><p id="Par66">from the folder where the rxncon3.boolnet.py script is located, and where path/model.xls is the path to and file name of the rxncon model, with the file extension.</p><p id="Par67">To access the possible options, call the script without a but with the &#x02013;help command:</p><p id="Par68">
python rxncon2boolnet.py &#x02013;help
</p><p id="Par69">This lists the possible options that can be appended to the call command, e.g:</p><p id="Par70">
python rxncon2boolnet.py path/model.xls &#x02013;k_plus strict &#x02013;k_minus strict
</p><p id="Par71">to run the model generation considering with quantitative contingencies (&#x0201c;K+&#x0201d;/&#x0201c;K&#x02212;&#x0201d;) considered absolute (&#x0201c;!&#x0201d;/&#x0201c;x&#x0201d;) instead of being ignored.</p><p id="Par72">The rxncon2boolnet.py script generates three files. First, the bipartite Boolean model file (&#x0003c;ModelName&#x0003e;.boolnet) contains the update rules using states and reaction IDs. Second, the symbol mapping file (&#x0003c;ModelName&#x0003e;_symbols.csv) defines which IDs correspond to which states and reactions in the rxncon file. Third, the initial vector (&#x0003c;ModelName&#x0003e;_initial_vals.csv&#x02019;) sets the initial state of the Boolean simulation.</p><p id="Par73">Model simulation was done with the R CRAN package BoolNet.<sup><xref ref-type="bibr" rid="CR18">18</xref></sup> To facilitate simulation, we prepared an R script that can be downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/rxncon/tools">https://github.com/rxncon/tools</ext-link> (BoolNetSim.R). To use this script through R studio:<list list-type="bullet"><list-item><p id="Par74">Save the network files and the R script into a single directory.</p></list-item><list-item><p id="Par75">Start RStudio.</p></list-item><list-item><p id="Par76">Open a new project and create it in the directory where you saved your files.</p></list-item><list-item><p id="Par77">Make sure your model files are located in the project folder.</p></list-item><list-item><p id="Par78">Open the R script. Set the filePrefix in the R script to &#x0003c;model&#x0003e;.</p></list-item><list-item><p id="Par79">Execute the entire script by selecting all text (ctrl+a) and pressing ctrl+enter.</p></list-item></list></p><p id="Par80">The script generates five files: (i) &#x0003c;ModelName&#x0003e;.pdf, which graphically displays the simulation trajectory from initial state to the attractor, (ii) &#x0003c;ModelName&#x0003e;_trajectory_first.csv, with the trajectory as values (0/1) in tabular format, (iii) &#x0003c;ModelName&#x0003e;_2.pdf, which graphically displays the simulation trajectory from the attractor (useful to distinguish a point attractor (two columns) from a cyclic attractor (&#x0003e;2 columns), (iv) &#x0003c;ModelName&#x0003e;_trajectory_second.csv, with the second trajectory in tabular format, and (v) &#x0003c;ModelName&#x0003e;_new_attractor.csv, with the new attractor as an initial values file.</p><p id="Par81">Where &#x0201c;&#x0003c;ModelName&#x0003e;&#x0201d; is the file name (without extension) of your rxncon model.</p><p id="Par82">Within a Boolean model, we expect the output to be responsive to the input. The sign of the dependence does not matter, and we can start with the input either on or off. We simulate the model until it reaches an attractor. If it is a point attractor, we use it as starting point for the next simulation but turn the Input signal into a truth value, activating the output target and simulate again until we reach another attractor. We iteratively change inputs and simulate to an attractor state until we reach an attractor we have already seen. For a detailed discussion of the workflow, see<sup><xref ref-type="bibr" rid="CR22">22</xref></sup> (pre-print at arXiv: <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1802.01328">https://arxiv.org/abs/1802.01328</ext-link>).</p></sec><sec id="Sec18"><title>Software and model availability</title><p id="Par83">The rxncon software is open source, distributed under the lGPL licence, and can be installed from the python package index with &#x0201c;pip install rxncon&#x0201d; (code also available at <ext-link ext-link-type="uri" xlink:href="https://github.com/rxncon/rxncon">https://github.com/rxncon/rxncon</ext-link> but without dependencies). The rxncon model files are available as Supplementary Model 1 (HOG model), Supplementary Model <xref rid="MOESM2" ref-type="media">2</xref> (final pheromone model) or through download from <ext-link ext-link-type="uri" xlink:href="https://github.com/rxncon/models/">https://github.com/rxncon/models/</ext-link> (YeastPheromoneModel.xls (the initial pheromone model).</p></sec></sec></sec><sec sec-type="supplementary-material"><title>Supplementary information</title><sec id="Sec19"><p>
<supplementary-material content-type="local-data" id="MOESM1"><media xlink:href="41540_2019_120_MOESM1_ESM.pdf"><caption><p>Supplementary Information</p></caption></media></supplementary-material>
<supplementary-material content-type="local-data" id="MOESM2"><media xlink:href="41540_2019_120_MOESM2_ESM.xls"><caption><p>Supplementary Model 2</p></caption></media></supplementary-material>
<supplementary-material content-type="local-data" id="MOESM3"><media xlink:href="41540_2019_120_MOESM3_ESM.pdf"><caption><p>reporting-summary</p></caption></media></supplementary-material>
</p></sec></sec></body><back><fn-group><fn id="Fn1"><label>1</label><p id="Par45">On some computers, the installation of Pyeda fails for unknown reasons. In this case, try typing &#x0201c;pip install&#x02014;no-cache-dir rxncon&#x0201d;.</p></fn><fn id="Fn2"><label>2</label><p id="Par47">In this case, by typing&#x0201d;cd Anaconda3/Scripts&#x0201d;.</p></fn><fn id="Fn3"><label>3</label><p id="Par51">In this case, by typing&#x0201d;cd Anaconda3/bin&#x0201d;.</p></fn><fn id="Fn4"><label>4</label><p id="Par57">This only works with the path set. Without this, type &#x0201c;=$HOME/.local/bin/rxncon2bngl.py&#x0201d;.</p></fn><fn id="Fn5"><label>5</label><p id="Par60">Depending on installation method, this may or may not come with R. If not, the location of R must be set in the dialogue box. If R is installed from Anaconda, the windows path would be &#x0201c;[user]/Anaconda3/R&#x0201d;.</p></fn><fn id="Fn6"><label>6</label><p id="Par62">If the conda command is not recognised, try to close and reopen the console.</p></fn><fn><p><bold>Publisher&#x02019;s note</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></fn><fn><p>These authors contributed equally: Jesper Romers, Sebastian Thieme.</p></fn></fn-group><sec><title>Supplementary information</title><p><bold>Supplementary information</bold> is available for this paper at 10.1038/s41540-019-0120-5.</p></sec><ack><title>Acknowledgements</title><p>This work was supported by the German Federal Ministry of Education and Research via e:Bio Cellemental (FKZ0316193, to MK).</p></ack><notes notes-type="author-contribution"><title>Author contributions</title><p>J.R., S.T. and M.K. designed the method. JR and ST implemented the method, and contributed equally to the work. U.M. validated the method. All authors contributed to and approved of the final manuscript.</p></notes><notes notes-type="data-availability"><title>Data availability</title><p>The models and code are freely available through the paper or public repositories.</p><p>The rxncon software is open source, distributed under the lGPL licence, and can be installed from the python package index with &#x0201c;pip install rxncon&#x0201d;. The code is also available downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/rxncon/rxncon">https://github.com/rxncon/rxncon</ext-link>. The rxncon model files are available as Supplementary Model 1 (HOG model), Supplementary Model <xref rid="MOESM2" ref-type="media">2</xref> (final pheromone model), Supplementary Model 3 (covalent motif), Supplementary Model 4 (interaction motif) or through download from <ext-link ext-link-type="uri" xlink:href="https://github.com/rxncon/models/">https://github.com/rxncon/models/</ext-link> (YeastPheromoneModel.xls (initial pheromone model)).</p></notes><notes notes-type="COI-statement"><title>Competing interests</title><p id="Par84">The authors declare no competing interests.</p></notes><ref-list id="Bib1"><title>References</title><ref id="CR1"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fisher</surname><given-names>J</given-names></name><name><surname>Henzinger</surname><given-names>TA</given-names></name></person-group><article-title>Executable cell biology</article-title><source>Nat. Biotechnol.</source><year>2007</year><volume>25</volume><fpage>1239</fpage><lpage>1249</lpage><pub-id pub-id-type="doi">10.1038/nbt1356</pub-id><pub-id pub-id-type="pmid">17989686</pub-id></element-citation></ref><ref id="CR2"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Herrgard</surname><given-names>MJ</given-names></name><etal/></person-group><article-title>A consensus yeast metabolic network reconstruction obtained from a community approach to systems biology</article-title><source>Nat. Biotechnol.</source><year>2008</year><volume>26</volume><fpage>1155</fpage><lpage>1160</lpage><pub-id pub-id-type="doi">10.1038/nbt1492</pub-id><pub-id pub-id-type="pmid">18846089</pub-id></element-citation></ref><ref id="CR3"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thiele</surname><given-names>I</given-names></name><etal/></person-group><article-title>A community-driven global reconstruction of human metabolism</article-title><source>Nat. Biotechnol.</source><year>2013</year><volume>31</volume><fpage>419</fpage><lpage>425</lpage><pub-id pub-id-type="doi">10.1038/nbt.2488</pub-id><pub-id pub-id-type="pmid">23455439</pub-id></element-citation></ref><ref id="CR4"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thiele</surname><given-names>I</given-names></name><name><surname>Palsson</surname><given-names>BO</given-names></name></person-group><article-title>A protocol for generating a high-quality genome-scale metabolic reconstruction</article-title><source>Nat. Protoc.</source><year>2010</year><volume>5</volume><fpage>93</fpage><lpage>121</lpage><pub-id pub-id-type="doi">10.1038/nprot.2009.203</pub-id><pub-id pub-id-type="pmid">20057383</pub-id></element-citation></ref><ref id="CR5"><label>5.</label><mixed-citation publication-type="other">M&#x000fc;nzner, U., Lubitz, T., Klipp, E. &#x00026; Krantz, M. In <italic>Systems Biology</italic> (eds Nielsen, J. &#x00026; Hohmann, S.) 215&#x02013;242 (Wiley, 2017).</mixed-citation></ref><ref id="CR6"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hlavacek</surname><given-names>WS</given-names></name><name><surname>Faeder</surname><given-names>JR</given-names></name></person-group><article-title>The complexity of cell signaling and the need for a new mechanics</article-title><source>Sci. Signal</source><year>2009</year><volume>2</volume><fpage>pe46</fpage><pub-id pub-id-type="doi">10.1126/scisignal.281pe46</pub-id><pub-id pub-id-type="pmid">19638613</pub-id></element-citation></ref><ref id="CR7"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hlavacek</surname><given-names>WS</given-names></name><name><surname>Faeder</surname><given-names>JR</given-names></name><name><surname>Blinov</surname><given-names>ML</given-names></name><name><surname>Perelson</surname><given-names>AS</given-names></name><name><surname>Goldstein</surname><given-names>B</given-names></name></person-group><article-title>The complexity of complexes in signal transduction</article-title><source>Biotechnol. Bioeng.</source><year>2003</year><volume>84</volume><fpage>783</fpage><lpage>794</lpage><pub-id pub-id-type="doi">10.1002/bit.10842</pub-id><pub-id pub-id-type="pmid">14708119</pub-id></element-citation></ref><ref id="CR8"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blinov</surname><given-names>ML</given-names></name><name><surname>Faeder</surname><given-names>JR</given-names></name><name><surname>Goldstein</surname><given-names>B</given-names></name><name><surname>Hlavacek</surname><given-names>WS</given-names></name></person-group><article-title>BioNetGen: software for rule-based modeling of signal transduction based on the interactions of molecular domains</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>3289</fpage><lpage>3291</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bth378</pub-id><pub-id pub-id-type="pmid">15217809</pub-id></element-citation></ref><ref id="CR9"><label>9.</label><mixed-citation publication-type="other">Danos, V., Feret, J., Fontana, W., Harmer, R. &#x00026; Krivine, J. Rule-Based Modelling of Cellular Signalling. In <italic>CONCUR 2007&#x02014;Concurrency Theory</italic>: <italic>18th International Conference</italic>, <italic>CONCUR 2007, Lisbon, Portugal, September 3&#x02013;8, 2007. Proceedings</italic> (eds Caires, L. &#x00026; Vasconcelos, V. T.) 17&#x02013;41 (Springer, Berlin, Heidelberg, 2007).</mixed-citation></ref><ref id="CR10"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sneddon</surname><given-names>MW</given-names></name><name><surname>Faeder</surname><given-names>JR</given-names></name><name><surname>Emonet</surname><given-names>T</given-names></name></person-group><article-title>Efficient modeling, simulation and coarse-graining of biological complexity with NFsim</article-title><source>Nat. Methods</source><year>2011</year><volume>8</volume><fpage>177</fpage><lpage>183</lpage><pub-id pub-id-type="doi">10.1038/nmeth.1546</pub-id><pub-id pub-id-type="pmid">21186362</pub-id></element-citation></ref><ref id="CR11"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Machado</surname><given-names>D</given-names></name><etal/></person-group><article-title>Modeling formalisms in systems biology</article-title><source>AMB Express</source><year>2011</year><volume>1</volume><fpage>45</fpage><pub-id pub-id-type="doi">10.1186/2191-0855-1-45</pub-id><pub-id pub-id-type="pmid">22141422</pub-id></element-citation></ref><ref id="CR12"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abou-Jaoude</surname><given-names>W</given-names></name><etal/></person-group><article-title>Logical modeling and dynamical analysis of cellular networks</article-title><source>Front Genet.</source><year>2016</year><volume>7</volume><fpage>94</fpage><pub-id pub-id-type="doi">10.3389/fgene.2016.00094</pub-id><pub-id pub-id-type="pmid">27303434</pub-id></element-citation></ref><ref id="CR13"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Handorf</surname><given-names>T</given-names></name><name><surname>Klipp</surname><given-names>E</given-names></name></person-group><article-title>Modeling mechanistic biological networks: an advanced Boolean approach</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><fpage>557</fpage><lpage>563</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btr697</pub-id><pub-id pub-id-type="pmid">22199382</pub-id></element-citation></ref><ref id="CR14"><label>14.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kolczyk</surname><given-names>K</given-names></name><name><surname>Samaga</surname><given-names>R</given-names></name><name><surname>Conzelmann</surname><given-names>H</given-names></name><name><surname>Mirschel</surname><given-names>S</given-names></name><name><surname>Conradi</surname><given-names>C</given-names></name></person-group><article-title>The Process-Interaction-Model: a common representation of rule-based and logical models allows studying signal transduction on different levels of detail</article-title><source>BMC Bioinform.</source><year>2012</year><volume>13</volume><fpage>251</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-13-251</pub-id></element-citation></ref><ref id="CR15"><label>15.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Flottmann</surname><given-names>M</given-names></name><name><surname>Krause</surname><given-names>F</given-names></name><name><surname>Klipp</surname><given-names>E</given-names></name><name><surname>Krantz</surname><given-names>M</given-names></name></person-group><article-title>Reaction-contingency based bipartite Boolean modelling</article-title><source>BMC Syst. Biol.</source><year>2013</year><volume>7</volume><fpage>58</fpage><pub-id pub-id-type="doi">10.1186/1752-0509-7-58</pub-id><pub-id pub-id-type="pmid">23835289</pub-id></element-citation></ref><ref id="CR16"><label>16.</label><mixed-citation publication-type="other">Romers, J. C. &#x00026; Krantz, M. rxncon 2.0: a language for executable molecular systems biology. <italic>bioRxiv</italic>. 10.1101/107136 (2017).</mixed-citation></ref><ref id="CR17"><label>17.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>M&#x000fc;nzner</surname><given-names>U</given-names></name><name><surname>Klipp</surname><given-names>E</given-names></name><name><surname>Krantz</surname><given-names>M</given-names></name></person-group><article-title>A comprehensive, mechanistically detailed, and executable model of the cell division cycle in <italic>Saccharomyces cerevisiae</italic></article-title><source>Nat. Commun.</source><year>2019</year><volume>10</volume><fpage>1308</fpage><pub-id pub-id-type="doi">10.1038/s41467-019-08903-w</pub-id><pub-id pub-id-type="pmid">30899000</pub-id></element-citation></ref><ref id="CR18"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mussel</surname><given-names>C</given-names></name><name><surname>Hopfensitz</surname><given-names>M</given-names></name><name><surname>Kestler</surname><given-names>HA</given-names></name></person-group><article-title>BoolNet&#x02013;an R package for generation, reconstruction and analysis of Boolean networks</article-title><source>Bioinformatics</source><year>2010</year><volume>26</volume><fpage>1378</fpage><lpage>1380</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btq124</pub-id><pub-id pub-id-type="pmid">20378558</pub-id></element-citation></ref><ref id="CR19"><label>19.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Klipp</surname><given-names>E</given-names></name><name><surname>Nordlander</surname><given-names>B</given-names></name><name><surname>Kruger</surname><given-names>R</given-names></name><name><surname>Gennemark</surname><given-names>P</given-names></name><name><surname>Hohmann</surname><given-names>S</given-names></name></person-group><article-title>Integrative model of the response of yeast to osmotic shock</article-title><source>Nat. Biotechnol.</source><year>2005</year><volume>23</volume><fpage>975</fpage><lpage>982</lpage><pub-id pub-id-type="doi">10.1038/nbt1114</pub-id><pub-id pub-id-type="pmid">16025103</pub-id></element-citation></ref><ref id="CR20"><label>20.</label><mixed-citation publication-type="other">Thomson, T. M. <italic>Yeast Pheromone Model</italic>, <ext-link ext-link-type="uri" xlink:href="http://yeastpheromonemodel.org">http://yeastpheromonemodel.org</ext-link>.</mixed-citation></ref><ref id="CR21"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thomson</surname><given-names>TM</given-names></name><etal/></person-group><article-title>Scaffold number in yeast signaling system sets tradeoff between system output and dynamic range</article-title><source>Proc. Natl Acad. Sci. USA</source><year>2011</year><volume>108</volume><fpage>20265</fpage><lpage>20270</lpage><pub-id pub-id-type="doi">10.1073/pnas.1004042108</pub-id><pub-id pub-id-type="pmid">22114196</pub-id></element-citation></ref><ref id="CR22"><label>22.</label><mixed-citation publication-type="other">Romers, J., Thieme, S., M&#x000fc;nzner, U. &#x00026; Krantz, M. in <italic>Modeling Biomolecular Site Dynamics: Methods and Protocols</italic> (ed. Hlavacek, W. S.) 71&#x02013;118 (Springer, New York, 2019).</mixed-citation></ref><ref id="CR23"><label>23.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Saez-Rodriguez</surname><given-names>J</given-names></name><etal/></person-group><article-title>Discrete logic modelling as a means to link protein signalling networks with functional analysis of mammalian signal transduction</article-title><source>Mol. Syst. Biol.</source><year>2009</year><volume>5</volume><fpage>331</fpage><pub-id pub-id-type="doi">10.1038/msb.2009.87</pub-id><pub-id pub-id-type="pmid">19953085</pub-id></element-citation></ref><ref id="CR24"><label>24.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fabregat</surname><given-names>A</given-names></name><etal/></person-group><article-title>The reactome pathway knowledgebase</article-title><source>Nucleic Acids Res.</source><year>2016</year><volume>44</volume><fpage>D481</fpage><lpage>D487</lpage><pub-id pub-id-type="doi">10.1093/nar/gkv1351</pub-id><pub-id pub-id-type="pmid">26656494</pub-id></element-citation></ref><ref id="CR25"><label>25.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kawakami</surname><given-names>E</given-names></name><etal/></person-group><article-title>Network analyses based on comprehensive molecular interaction maps reveal robust control structures in yeast stress response pathways</article-title><source>Npj Syst. Biol. Appl.</source><year>2016</year><volume>2</volume><fpage>15018</fpage><pub-id pub-id-type="doi">10.1038/npjsba.2015.18</pub-id><pub-id pub-id-type="pmid">28725465</pub-id></element-citation></ref><ref id="CR26"><label>26.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kuperstein</surname><given-names>I</given-names></name><etal/></person-group><article-title>Atlas of cancer signalling network: a systems biology resource for integrative analysis of cancer data with Google Maps</article-title><source>Oncogenesis</source><year>2015</year><volume>4</volume><fpage>e160</fpage><pub-id pub-id-type="doi">10.1038/oncsis.2015.19</pub-id><pub-id pub-id-type="pmid">26192618</pub-id></element-citation></ref><ref id="CR27"><label>27.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mori</surname><given-names>T</given-names></name><name><surname>Flottmann</surname><given-names>M</given-names></name><name><surname>Krantz</surname><given-names>M</given-names></name><name><surname>Akutsu</surname><given-names>T</given-names></name><name><surname>Klipp</surname><given-names>E</given-names></name></person-group><article-title>Stochastic simulation of Boolean rxncon models: towards quantitative analysis of large signaling networks</article-title><source>BMC Syst. Biol.</source><year>2015</year><volume>9</volume><fpage>45</fpage><pub-id pub-id-type="doi">10.1186/s12918-015-0193-8</pub-id><pub-id pub-id-type="pmid">26259567</pub-id></element-citation></ref><ref id="CR28"><label>28.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lubitz</surname><given-names>T</given-names></name><etal/></person-group><article-title>Network reconstruction and validation of the Snf1/AMPK pathway in baker&#x02019;s yeast based on a comprehensive literature review</article-title><source>Npj Syst. Biol. Appl.</source><year>2015</year><volume>1</volume><fpage>15007</fpage><pub-id pub-id-type="doi">10.1038/npjsba.2015.7</pub-id><pub-id pub-id-type="pmid">28725459</pub-id></element-citation></ref><ref id="CR29"><label>29.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tiger</surname><given-names>CF</given-names></name><etal/></person-group><article-title>A framework for mapping, visualisation and automatic model creation of signal-transduction networks</article-title><source>Mol. Syst. Biol.</source><year>2012</year><volume>8</volume><fpage>578</fpage><pub-id pub-id-type="doi">10.1038/msb.2012.12</pub-id><pub-id pub-id-type="pmid">22531118</pub-id></element-citation></ref><ref id="CR30"><label>30.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Creamer</surname><given-names>MS</given-names></name><etal/></person-group><article-title>Specification, annotation, visualization and simulation of a large rule-based model for ERBB receptor signaling</article-title><source>BMC Syst. Biol.</source><year>2012</year><volume>6</volume><fpage>107</fpage><pub-id pub-id-type="doi">10.1186/1752-0509-6-107</pub-id><pub-id pub-id-type="pmid">22913808</pub-id></element-citation></ref><ref id="CR31"><label>31.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Srinivasan</surname><given-names>S</given-names></name><name><surname>Cluett</surname><given-names>WR</given-names></name><name><surname>Mahadevan</surname><given-names>R</given-names></name></person-group><article-title>Constructing kinetic models of metabolism at genome-scales: a review</article-title><source>Biotechnol. J.</source><year>2015</year><volume>10</volume><fpage>1345</fpage><lpage>1359</lpage><pub-id pub-id-type="doi">10.1002/biot.201400522</pub-id><pub-id pub-id-type="pmid">26332243</pub-id></element-citation></ref></ref-list></back></article>