<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.2 20190208//EN" "JATS-archivearticle1-mathml3.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">PLoS One</journal-id><journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">plosone</journal-id><journal-title-group><journal-title>PLoS ONE</journal-title></journal-title-group><issn pub-type="epub">1932-6203</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, CA USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">31923182</article-id><article-id pub-id-type="pmc">6953802</article-id><article-id pub-id-type="publisher-id">PONE-D-17-44000</article-id><article-id pub-id-type="doi">10.1371/journal.pone.0226877</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive Science</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Language</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Language</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Language</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Physiology</subject><subj-group><subject>Biological Locomotion</subject><subj-group><subject>Swimming</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Medicine and Health Sciences</subject><subj-group><subject>Physiology</subject><subj-group><subject>Biological Locomotion</subject><subj-group><subject>Swimming</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social Sciences</subject><subj-group><subject>Linguistics</subject><subj-group><subject>Grammar</subject><subj-group><subject>Syntax</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Sensory Perception</subject><subj-group><subject>Vision</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Sensory Perception</subject><subj-group><subject>Vision</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Sensory Perception</subject><subj-group><subject>Vision</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Engineering and Technology</subject><subj-group><subject>Mechanical Engineering</subject><subj-group><subject>Engines</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Software Engineering</subject><subj-group><subject>Software Development</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Engineering and Technology</subject><subj-group><subject>Software Engineering</subject><subj-group><subject>Software Development</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Computer Software</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Programming Languages</subject></subj-group></subj-group></article-categories><title-group><article-title>A definition-by-example approach and visual language for activity patterns in engineering disciplines</article-title><alt-title alt-title-type="running-head">A definition-by-example approach and visual language for activity patterns</alt-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Janke</surname><given-names>Mario</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Formal analysis</role><role content-type="http://credit.casrai.org/">Methodology</role><role content-type="http://credit.casrai.org/">Visualization</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"/><xref ref-type="corresp" rid="cor001">*</xref></contrib><contrib contrib-type="author"><name><surname>Kuschke</surname><given-names>Tobias</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Data curation</role><role content-type="http://credit.casrai.org/">Formal analysis</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Methodology</role><role content-type="http://credit.casrai.org/">Resources</role><role content-type="http://credit.casrai.org/">Software</role><role content-type="http://credit.casrai.org/">Validation</role><role content-type="http://credit.casrai.org/">Visualization</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><xref ref-type="aff" rid="aff001"/></contrib><contrib contrib-type="author"><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-6871-2707</contrib-id><name><surname>M&#x000e4;der</surname><given-names>Patrick</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Funding acquisition</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Methodology</role><role content-type="http://credit.casrai.org/">Project administration</role><role content-type="http://credit.casrai.org/">Resources</role><role content-type="http://credit.casrai.org/">Supervision</role><role content-type="http://credit.casrai.org/">Validation</role><role content-type="http://credit.casrai.org/">Visualization</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"/><xref ref-type="corresp" rid="cor001">*</xref></contrib></contrib-group><aff id="aff001">
<addr-line>Software Engineering for Safety-critical Systems Group, Technische Universit&#x000e4;t Ilmenau, Ilmenau, Germany</addr-line>
</aff><contrib-group><contrib contrib-type="editor"><name><surname>Shalin</surname><given-names>Valerie L.</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">
<addr-line>Wright State University, UNITED STATES</addr-line>
</aff><author-notes><fn fn-type="COI-statement" id="coi001"><p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p></fn><corresp id="cor001">* E-mail: <email>mario.janke@tu-ilmenau.de</email> (MJ); <email>patrick.maeder@tu-ilmenau.de</email> (PM)</corresp></author-notes><pub-date pub-type="collection"><year>2020</year></pub-date><pub-date pub-type="epub"><day>10</day><month>1</month><year>2020</year></pub-date><volume>15</volume><issue>1</issue><elocation-id>e0226877</elocation-id><history><date date-type="received"><day>17</day><month>1</month><year>2018</year></date><date date-type="accepted"><day>7</day><month>12</month><year>2019</year></date></history><permissions><copyright-statement>&#x000a9; 2020 Janke et al</copyright-statement><copyright-year>2020</copyright-year><copyright-holder>Janke et al</copyright-holder><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="pone.0226877.pdf"/><abstract><p>Modeling tools are well established in software development. A model is the result of a series of modeling activities. The ability to recognize when a user is working on a certain modeling activity opens up a range of possibilities for context-sensitive support. One possible way to support the user is offering the auto-completion of the current task. The recognition of modeling activities is typically carried out by matching event patterns against events emitted by a user&#x02019;s editing operations. A user that intends to add or customize auto-completions must be able to easily understand and create activity definitions. However, defining the currently required complex event patterns is a challenging and error-prone task even for a person with an intensive knowledge of event-processing languages. In this paper, we propose the visual definition language VisPaRec accompanied by a method that allows creating activity definitions in a semi-automated and graphical way. We evaluate our visual definition language in a comparative user study against the generic event-processing language Rapide. We found that the proposed visual representation increases comprehensibility while reducing time for constructing and modifying activity definitions significantly.</p></abstract><funding-group><award-group id="award001"><funding-source><institution>German Ministry of Education and Research (BMBF)</institution></funding-source><award-id>01IS18074E, 01IS16003B</award-id><principal-award-recipient><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-6871-2707</contrib-id><name><surname>M&#x000e4;der</surname><given-names>Patrick</given-names></name></principal-award-recipient></award-group><award-group id="award002"><funding-source><institution>DFG</institution></funding-source><award-id>MA 5030/3-1</award-id><principal-award-recipient><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-6871-2707</contrib-id><name><surname>M&#x000e4;der</surname><given-names>Patrick</given-names></name></principal-award-recipient></award-group><award-group id="award003"><funding-source><institution>EU EFRE/Th&#x000fc;ringer Aufbaubank (TAB)</institution></funding-source><award-id>2015FE9033</award-id><principal-award-recipient><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-6871-2707</contrib-id><name><surname>M&#x000e4;der</surname><given-names>Patrick</given-names></name></principal-award-recipient></award-group><funding-statement>We are funded by the German Ministry of Education and Research (BMBF) grants: 01IS18074E, 01IS16003B, by DFG grant: MA 5030/3-1, and by the EU EFRE/Th&#x000fc;ringer Aufbaubank (TAB) grant: 2015FE9033.</funding-statement></funding-group><counts><fig-count count="12"/><table-count count="4"/><page-count count="28"/></counts><custom-meta-group><custom-meta id="data-availability"><meta-name>Data Availability</meta-name><meta-value>All files are available via the Harvard Dataverse repository, DOI: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.7910/DVN/FTPF3Z">10.7910/DVN/FTPF3Z</ext-link>:(<ext-link ext-link-type="uri" xlink:href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z">https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z</ext-link>).</meta-value></custom-meta></custom-meta-group></article-meta><notes><title>Data Availability</title><p>All files are available via the Harvard Dataverse repository, DOI: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.7910/DVN/FTPF3Z">10.7910/DVN/FTPF3Z</ext-link>:(<ext-link ext-link-type="uri" xlink:href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z">https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z</ext-link>).</p></notes></front><body><sec sec-type="intro" id="sec001"><title>1 Introduction</title><p>Automating repetitive tasks in software engineering processes has become essential for developers. Apart from increasing the efficiency of the development process, it can also improve the quality of the developed product by obviating human errors. For example, software developers, experts and novices alike, benefit from simple automations like auto-completion in an IDE [<xref rid="pone.0226877.ref001" ref-type="bibr">1</xref>]. Researchers demonstrated that automation can be beneficial for graphical modeling tasks as well [<xref rid="pone.0226877.ref002" ref-type="bibr">2</xref>&#x02013;<xref rid="pone.0226877.ref005" ref-type="bibr">5</xref>]. There are plenty of opportunities to support a developer in recurring activities during model-driven architecture and design (e.g., model refactorings). However, the recognition of these activities is not a trivial task since they include a number of different, related editing operations. Complex event processing (CEP) [<xref rid="pone.0226877.ref006" ref-type="bibr">6</xref>] allows for the recognition of such activities and is the technology we apply for this and previous work. In previous work, we used complex patterns of editing events to update traceability information automatically upon recognizing users&#x02019; modeling activities [<xref rid="pone.0226877.ref007" ref-type="bibr">7</xref>] and successfully brought a visual language approach to traceability analysis [<xref rid="pone.0226877.ref008" ref-type="bibr">8</xref>&#x02013;<xref rid="pone.0226877.ref010" ref-type="bibr">10</xref>]. In a succeeding project, we studied how software modeling activities can be recommended while a developer is editing UML models [<xref rid="pone.0226877.ref011" ref-type="bibr">11</xref>] and how such recommended activities can then be auto-completed [<xref rid="pone.0226877.ref012" ref-type="bibr">12</xref>&#x02013;<xref rid="pone.0226877.ref014" ref-type="bibr">14</xref>]. Both proposed approaches build upon activity definitions captured as event-processing rules. Reactive to every editing operation carried out by the user, an implementation of the latter approach recommends a ranked set of context-relevant modeling activities for auto-completion. The typical workflow of integrating activity pattern-based completion into a tool includes using a general-purpose CEP language or declarative programming language. Alternatively, simple patters can be hardcoded without a proper CEP framework. However, this comes with serious drawbacks in terms of maintainability and expandability. We have previous developed a prototype architecture of an auto-completion tool based on a textual CEP language, but we hypothesize that a specialized visual language can increase the applicability of this and many other approaches. In general, the usefulness of such automation highly depends on their customizability to users&#x02019; needs. However, defining the required event-processing rules is a challenging task because very specific knowledge of the processing platform and its declaration language is required.</p><p>This paper presents the visual language VisPaRec accompanied by a definition method allowing non-CEP-experts to create and maintain activity definitions in a semi-automated way. We see multiple application scenarios where lowering the effort and knowledge necessary to work with activity definitions can benefit developers in the software industry. On one hand, tool vendors of model and code editors can develop CEP pattern based support more easily. On the other hand, modelers using modeling tools directly benefit by being able to customize and define their own activity definitions. The modelers may or may not be active programmers, but have full insight into their personal working patterns and customization wishes. Our approach aims to aid users in defining their own patterns and by that supporting their individual workflows. In this sense, pattern specification should require as little knowledge about programming and CEP as possible. Patterns should be comprehensible at a glance, easily maintainable and expandable. Through the definition-by-demonstration method proposed in this work, users can create activity definitions by demonstrating the desired activity within their modeling environment rather than being requested to write complex event processing rules. Thereby, technical and tool-specific aspects are abstracted and mostly hidden from the user.</p><p>The remainder of this paper is structured as follows. Section 2 reviews related work on complex event patterns, defining model transformations and programming by example. Section 3 describes the concepts of modeling activity definitions and their relation. Section 4 introduces VisPaRec, the visual definition language that we developed for specifying modeling activity definitions, followed by an analysis and comparison of selected event processing languages. Section 5 presents how VisPaRec can be embedded into a &#x0201c;by-demonstration&#x0201d; approach that automates large parts of creating a definition. Section 6 describes a user experiment that we conducted to evaluate comprehensibility, applicability and usability of VisPaRec. Finally, Section 7 concludes our work and outlines future research.</p></sec><sec id="sec002"><title>2 Related work</title><p>Supporting development activities in modeling-based environments is a relatively novel research topic. To the best of our knowledge, there exist no approaches that support users in defining their own activities and in employing them in modeling environments for auto-completion. There do, however, exist generic solutions for supporting users in the definition of complex event patterns and model transformation rules. Complex event processing, in general, is a technique to infer high-level knowledge from streams of low-level events. A core principle is the agglomeration of the simple input events into more structured agglomerations called complex events. Another characterizing feature are queries against these events, simple and complex alike. Usually, incremental evaluation is a key feature. Typical applications range from monitoring tasks, such as evaluating sensory data and network monitoring, over gesture detection to business rule engines.</p><sec id="sec003"><title>Textually defining complex event patterns</title><p>Eckert et al.&#x02019;s [<xref rid="pone.0226877.ref015" ref-type="bibr">15</xref>] comprehensive survey shows that, driven by varying user needs as well as strengths and weaknesses of the underlying engines, a rather high number of textual CEP languages have been proposed in the past. We exemplarily discuss three languages that follow different approaches in their design. Given the large variation in language features in the early days of rule processing, <italic>Rapide</italic> [<xref rid="pone.0226877.ref016" ref-type="bibr">16</xref>, <xref rid="pone.0226877.ref017" ref-type="bibr">17</xref>] was proposed as a language independent of an underlying engine. It has a strong mathematical foundation and was designed as a general language framework. Rapide consists of a comprehensive and expressive set of rule features that has inspired CEP engines since and that is supported by most CEP engines today. The <italic>Drools Rules Language</italic> (DRL) [<xref rid="pone.0226877.ref018" ref-type="bibr">18</xref>, <xref rid="pone.0226877.ref019" ref-type="bibr">19</xref>] is one of many production rule languages. It is tightly coupled with its host language Java. In DRL, persistent state is represented as Java objects called <italic>facts</italic>, which are stored in a <italic>Working Memory</italic>. Pattern matching happens through rules that specify facts and conditions that single or multiple facts must fulfill. <italic>Esper EPL</italic> [<xref rid="pone.0226877.ref020" ref-type="bibr">20</xref>] is a data stream query language. Its language design originates from the database query language SQL. Esper EPL abstracts the input as a data stream of tuples. These streams can be queried much like a relational database. Timing as well as sequencing constraints can be formulated in a high-level syntax. Additionally, Esper EPL allows combining data stream queries with pattern matching. We compare the part of these languages&#x02019; syntax that is relevant to the presented approach in Section 4.3.2.</p></sec><sec id="sec004"><title>Visually defining complex event patterns</title><p>In the field of complex event processing, a number of graphical editors, both proprietary tools and academic approaches, for defining patterns and rules exist. The <italic>SocEDA</italic> project [<xref rid="pone.0226877.ref021" ref-type="bibr">21</xref>] offers an editor for translating high-level definitions of complex event patterns into Esper EPL. The tool supports the pattern definition visually but also requires the user to write code of the underlying event-processing language. The visual representation of a pattern in SocEDA does not contain all information, but rather represents some of it merely within the code. Nowak et al. [<xref rid="pone.0226877.ref022" ref-type="bibr">22</xref>] present an editor based on the <italic>Palantir Government</italic> platform for creating rules in the event-processing language <italic>JESS</italic>. Similar to SocEDA, the visual representation does not include all the relevant information. The editor only presents additional information in a panel when requested by the user. Both approaches reduce the visual load by omitting some information and only showing it on demand. While this is effective for a modeling tool, it does not enable visual comprehension of patterns at all. <italic>Strelka</italic> is a graphical editor for defining rules developed by the <italic>REWERSE Working Group I1</italic> [<xref rid="pone.0226877.ref023" ref-type="bibr">23</xref>]. The tool uses the UML based rule modeling language <italic>URML</italic> that allows users to visually model different types of rules based on UML class models. Boubeta-Puig et al. [<xref rid="pone.0226877.ref024" ref-type="bibr">24</xref>] describe a user-friendly, model-driven approach for specifying complex event patterns. Similar to our proposed method, users are able to design graphical models specifying event patterns. These models are then transformed into platform-specific event-processing code by the use of a corresponding model-to-text transformation. Their editor <italic>MEdit4CEP</italic> provides all instruments that are necessary to express conditions for recognizing modeling activities. However, even low-level language elements like logical operators are displayed by separate visual elements, which leads to high visual complexity and clutter. In contrast to the first two approaches, MEdit4CEP and Strelka do encode rules completely visually. The drawback of this approach is that the visual pattern definitions become very complex even for small rules, since a lot of information that could be represented very compactly, is displayed in a very explicit way. We further investigate this issue in Section 4.3. The introduced editors allow defining event patterns and rules without explicit knowledge of a platform-specific event-processing language, but they all are developed from the viewpoint of complex event processing. Additionally, these approaches do not provide mechanisms for defining auto-completions of modeling activities.</p></sec><sec id="sec005"><title>Defining model transformations</title><p>Sun et al. [<xref rid="pone.0226877.ref025" ref-type="bibr">25</xref>] presented an approach that allows users to demonstrate model transformations and to automatically derive transformation rules from this demonstration. In another study, Sun et al. [<xref rid="pone.0226877.ref026" ref-type="bibr">26</xref>] describe how layout information for model transformations can be captured during user demonstrations and effectively used later on. Biermann et al. [<xref rid="pone.0226877.ref027" ref-type="bibr">27</xref>] propose a framework for <italic>in-place</italic> transformations of EMF-Models. Based on their approach, Arendt et al. [<xref rid="pone.0226877.ref028" ref-type="bibr">28</xref>] developed the transformation language <italic>Henshin</italic>. In their work, they describe concepts like pre- and post-conditions of model states that have similarities to our work. However, transformation rules are intended to change models upon reaching defined states, whereas our approach regards edits, not state. Specifying the evolution of model elements comprising historic element states and restricting the timing of model changes are not the purpose of model transformation rules.</p><p>Graph transformation languages like Story Diagrams [<xref rid="pone.0226877.ref029" ref-type="bibr">29</xref>] can specify patterns similarly to transformation languages. A pattern matches a graph and applies the transformation to it, the outcome is a modified graph. This approach, therefore, cannot be used directly to specify an activity pattern. However, one could try to reinterpret the existing visual notations for graph transformations or augment them. Graph transformations only specify a state before and after the transformation. For the specification of activity patterns, continuous and possibly concurrent changes need to be specified.</p></sec><sec id="sec006"><title>Programming by example</title><p>Raza et. al. [<xref rid="pone.0226877.ref030" ref-type="bibr">30</xref>] propose a solution to the problem of ambiguity in example-based programming. They use the least general generalization to describe a set of examples. The inherent ambiguity involved in such tasks is a highly important issue our approach faces as well. Their approach aims to express rather small changes using a multitude of examples and was evaluated using a Microsoft Powerpoint add-in.</p></sec><sec id="sec007"><title>Conclusions</title><p>We conclude that there are approaches that support the graphical specification of rules. However, none of them provides a desirable solution to the problem of specifying event-processing rules in the context of modeling activity recognition. This is what we aim to accomplish with VisPaRec. VisPaRec is not intended to be a general-purpose EPL, but rather a domain-specific language for the representation of modeling activities that is easy to read and write for non-CEP-experts.</p></sec></sec><sec id="sec008"><title>3 Concepts of modeling activity definitions</title><p>We aim to support a user in developing a model that comprises a set of <italic>model elements</italic>
<italic>E</italic>. Typical model elements are packages, components, classes, interfaces, attributes, methods, associations, dependencies, and generalizations. The user is evolving this model through <italic>editing operations</italic> of the types add, modify, or delete. A modify operation changes attributes of an existing model element, e.g., the element&#x02019;s name or type. This choice of operation types is extendable in nature and may be dependent on the application at hand. For specific applications, it might be useful to formulate more types. However, specific operation types like copying a model element or the act of moving one model element into another can be represented as a pattern of the fundamental types add, delete and modify. We denote the set of all editing operations performed by a user on a model as <italic>O</italic>. A <italic>modeling activity</italic> is then defined as a recurring set of editing operations carried out by the user on model elements.</p><p>As a running example, we introduce a modeling activity that represents the well-known refactoring &#x0201c;Extract Class&#x0201d; (see Fowler [<xref rid="pone.0226877.ref031" ref-type="bibr">31</xref>]) on a UML class diagram. During this refactoring, an attribute of an existing class is extracted into an independent class. <xref ref-type="fig" rid="pone.0226877.g001">Fig 1</xref> shows the modeling activity performed on an example model of a software system. As a precondition, a class must exist and contain an attribute. In the example, the attribute <italic>Engine</italic> of the class <italic>CarConfiguration</italic> is extracted. The ellipses represent editing operations belonging to the modeling activity. The existing attribute is deleted (I) and a new class is added (II) within the same package <italic>CarConfigurator</italic>. The new class will be renamed (III) according to the deleted attribute <italic>Engine</italic>. The activity is completed by adding a new association connecting the two classes (IV) and modifying it into a directed aggregation (V). The user may freely decide about the sequence of editing operations. Naturally, some limitations are imposed by the modeling environment, e.g., classes need to be added before they can be connected.</p><fig id="pone.0226877.g001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g001</object-id><label>Fig 1</label><caption><title>Editing operations for executing the activity &#x0201c;Extracting attribute as class&#x0201d;.</title></caption><graphic xlink:href="pone.0226877.g001"/></fig><p>The event-based recognition of a modeling activity requires an <italic>activity definition</italic> in the set of all activity definitions <inline-formula id="pone.0226877.e001"><alternatives><graphic xlink:href="pone.0226877.e001.jpg" id="pone.0226877.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mi mathvariant="script">T</mml:mi></mml:math></alternatives></inline-formula>. An activity definition specifies: (1) a set of expected editing operations that have to be performed to complete the modeling activity, (2) a set of expected <italic>element versions</italic>
<inline-formula id="pone.0226877.e002"><alternatives><graphic xlink:href="pone.0226877.e002.jpg" id="pone.0226877.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mi mathvariant="script">V</mml:mi></mml:math></alternatives></inline-formula> capturing expected states of model elements during the modeling activity, (3) constraints on model element properties captured in element versions <inline-formula id="pone.0226877.e003"><alternatives><graphic xlink:href="pone.0226877.e003.jpg" id="pone.0226877.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:msub><mml:mi mathvariant="script">P</mml:mi><mml:mi mathvariant="script">V</mml:mi></mml:msub></mml:math></alternatives></inline-formula> and across element versions <inline-formula id="pone.0226877.e004"><alternatives><graphic xlink:href="pone.0226877.e004.jpg" id="pone.0226877.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:msub><mml:mi mathvariant="script">P</mml:mi><mml:mi mathvariant="script">R</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, (4) constraints across editing operations and element versions <inline-formula id="pone.0226877.e005"><alternatives><graphic xlink:href="pone.0226877.e005.jpg" id="pone.0226877.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mi mathvariant="script">R</mml:mi></mml:msub></mml:math></alternatives></inline-formula> restricting the operation sequence, and (5) an action to be executed upon recognition of the specified modeling activity. It is sufficient to store <italic>values</italic> of element properties in <inline-formula id="pone.0226877.e006"><alternatives><graphic xlink:href="pone.0226877.e006.jpg" id="pone.0226877.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:msub><mml:mi mathvariant="script">P</mml:mi><mml:mi mathvariant="script">V</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, while <inline-formula id="pone.0226877.e007"><alternatives><graphic xlink:href="pone.0226877.e007.jpg" id="pone.0226877.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:msub><mml:mi mathvariant="script">P</mml:mi><mml:mi mathvariant="script">R</mml:mi></mml:msub></mml:math></alternatives></inline-formula> needs <italic>references</italic> to multiple element versions. The action part of the definition depends on the usage scenario. There are numerous ways to react to a detected activity, but in the scope of this paper, we illustrate our approach within an auto-completion technique that aims to complete the modeling activity the user started. Information specified in the action part of an activity definition therefore comprises <italic>completion actions</italic>
<inline-formula id="pone.0226877.e008"><alternatives><graphic xlink:href="pone.0226877.e008.jpg" id="pone.0226877.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula> to be executed automatically and <italic>property defaults</italic>
<inline-formula id="pone.0226877.e009"><alternatives><graphic xlink:href="pone.0226877.e009.jpg" id="pone.0226877.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mi mathvariant="script">D</mml:mi></mml:math></alternatives></inline-formula> to specify values of editing operations to be auto-completed.</p><p>Based on the introduced initial concepts, we developed a meta-model for activity definitions (see <xref ref-type="fig" rid="pone.0226877.g002">Fig 2</xref>). Whenever a rule matches, the result must be kept in a structured way to be usable for a possible auto-completion. It must specify editing operations already done, and how to complete the ones not done yet. An example is contained in the experimental replication package (accessible at <ext-link ext-link-type="uri" xlink:href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z">https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z</ext-link>, cp. R1T on page 32) showing how to specify the necessary information using three arrays. Explicit specification is necessary in any general-purpose language.</p><fig id="pone.0226877.g002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g002</object-id><label>Fig 2</label><caption><title>The meta-model for activity definitions.</title></caption><graphic xlink:href="pone.0226877.g002"/></fig></sec><sec id="sec009"><title>4 VisPaRec&#x02014;A language for activity definitions</title><p>Based on the meta-model introduced in the previous section, we developed a visual representation for each concept. We followed Moody&#x02019;s principles for creating efficient visual software engineering notations [<xref rid="pone.0226877.ref032" ref-type="bibr">32</xref>]. Moody argues that the basis for a &#x0201c;good visual notation&#x0201d; is having a clear design goal that specifies what kind of information needs to be presented, what audience is using this information (theory of cognitive fit), and what visual dialect is suitable for that purpose. Moody lists fundamental principles that a notation should fulfill. Referring to the principles of semiotic clarity, perceptual discriminability, semantic transparency, visual expressiveness and dual coding, the basic notation elements should exhibit the following characteristics. They should correspond 1:1 to their semantic construct. Therefore, we mapped each meta-model element to an individual visual notation element while keeping their number cognitively manageable (graphic economy). Furthermore, notation elements should be clearly distinguishable from each other by using the full range and capacity of visual variables like shape, color and size. Also, text should be used redundantly to support graphic elements. In the following, we introduce the notation elements of our visual definition language and explain them on examples.</p><sec id="sec010"><title>4.1 Language concepts</title><sec id="sec011"><title>Model element (C1)</title><p>Each model element involved in an activity is represented by an open ended swim lane, much like in UML (see <xref ref-type="fig" rid="pone.0226877.g003">Fig 3</xref>). A vertical label on the left hand side of this swim lane contains the element type. The swim lane is a container that groups different versions of an evolving model element and the editing operations that transition from one version into the following.</p><fig id="pone.0226877.g003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g003</object-id><label>Fig 3</label><caption><title>Visual representation: Model element (C1).</title></caption><graphic xlink:href="pone.0226877.g003"/></fig><p><italic>Decision</italic>: Group versions of an element via swim lanes. <italic>Rationale</italic>: We see an object over its lifetime as a semantic construct on its own. Swim lanes help to reach the goal of representing each semantic construct 1:1 as they are a single notation element for a single construct. The commonly used alternative is to encode the edited model element through a guard of the object&#x02019;s ID, which corresponds n:1 to the semantic construct. The swim lane concept also contributes towards graphic economy.</p></sec><sec id="sec012"><title>Element version (C2)</title><p>An element version uses the notation of classes from a UML class diagram. We distinguish three types of element versions (see <xref ref-type="fig" rid="pone.0226877.g004">Fig 4</xref>): First, <italic>Existent</italic> specifies that a certain model element must exist before the modeling activity is started. Second, <italic>Non-Existent</italic> specifies that a certain model element may not exist before the start of an activity or after it is being deleted during an activity. Third, ordinary element versions specify certain states in the model element&#x02019;s evolution. Different background colors are used within swim lanes to visually highlight the existence and the non-existence of a model element. Elements within the same swim lane have an implicit sequence constraint (see Sequence Constraints (C5)) among them, while no sequencing between swim lanes is enforced. This allows for more flexible patterns, as concurrency can be formulated.</p><fig id="pone.0226877.g004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g004</object-id><label>Fig 4</label><caption><title>Visual representation: Element versions (C2).</title></caption><graphic xlink:href="pone.0226877.g004"/></fig></sec><sec id="sec013"><title>Editing operation (C3)</title><p>Editing operations are represented with a circular outline. According to the principle of dual coding, we visualize the operation types add, modify, delete, within the circle textually and additionally as a colored symbol (see <xref ref-type="fig" rid="pone.0226877.g005">Fig 5</xref>). An editing operation must be connected to a previous element version that specifies the state of the element before the operation is performed and to a resulting element version that specifies the element&#x02019;s state after the operation. Two dashed arrows visualize these relations. The direction of those arrows points from the previous element version to the operation and from the operation to the resulting element version. The visual representation of model elements, element versions and editing operations all differ in shape and size. The graphical grouping of versions and operations into swim lanes is intended to clearly visualize the involved model elements and their evolution throughout a modeling activity.</p><fig id="pone.0226877.g005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g005</object-id><label>Fig 5</label><caption><title>Visual representation: Editing operations (C3).</title></caption><graphic xlink:href="pone.0226877.g005"/></fig><p><italic>Decision</italic>: Each operation type has its own icon distinguished by color and shape. <italic>Rationale</italic>: As the operation type has a huge impact on the interpretation of an edit, it must represent the types in a clearly distinguishable way ensuring semiotic clarity. Varying color and shape ensure perceptual discriminability. We expect this design to ease comprehension compared to all current solutions, which represent these concepts solely by a different name or id of the change type.</p></sec><sec id="sec014"><title>Property constraint (C4)</title><p>Property constraints specify values of element properties and are expressed as logical terms. To keep the graphical complexity manageable, we chose to not represent logical expressions in a graphical way. Instead, we specify these expressions textually by using operators like those shown in <xref ref-type="fig" rid="pone.0226877.g006">Fig 6</xref>. Property constraints are partitioned into static and dynamic ones. Static constraints <italic>P</italic><sub><italic>V</italic></sub> specify constraints on concrete values of element properties and are therefore defined within an element version. A very common static property constraint is the specification of the type of an element. Dynamic constraints <italic>P</italic><sub><italic>R</italic></sub> are defined as references across properties of versions of the same or different model elements involved in an activity. These references are visualized as directed connectors that point from the constrained to the referenced element version. Two elements having the same name, or one element being the child of another one are typical dynamic property constraints. The left hand part of <xref ref-type="fig" rid="pone.0226877.g006">Fig 6</xref> shows the two visual representations of property constraints. Property constraints can be applied to restrict all element versions except those of the type <italic>Non-Existent</italic>. We do not check for syntactical or semantical mistakes within property constraints at modeling time. However, at a later point, the transformation into executable event processing rules (cp. Section 5.4) does check syntax.</p><fig id="pone.0226877.g006" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g006</object-id><label>Fig 6</label><caption><title>Visual representations: Property constraints (C4) (left) and possible constraint operators (right).</title></caption><graphic xlink:href="pone.0226877.g006"/></fig><p><italic>Decision</italic>: Represent static and dynamic property constraints differently. <italic>Rationale</italic>: A fixed parameter and a reference between multiple model elements are semantically rather different. Separate visual representations help to uncover and visualize dependencies between model elements to the user and contribute to better perceptual discriminability of concepts.</p></sec><sec id="sec015"><title>Sequence constraints (C5)</title><p>Sequence constraints express timing and order conditions. They start and end at element versions or editing operations (see Section 3). We decided to visually distinguish sequence constraints from property constraints.</p><p>Sequence constraints use orange connectors instead of blue ones and squares as source symbols instead of dots. <xref ref-type="fig" rid="pone.0226877.g007">Fig 7</xref> shows two examples of sequence constraints. The operator &#x0201c;&#x0003e;&#x0201d; means &#x0201c;<italic>after</italic>&#x0201d; and &#x0201c;<italic>TimeStamp &#x0003e; Created</italic>&#x0201d; (upper example) expresses that the editing operation must be performed after the model element has been created. In contrast &#x0201c;&#x0003c;&#x0201d; means &#x0201c;<italic>before</italic>&#x0201d; and the lower example specifies that the class has to be added before the interface is added.</p><fig id="pone.0226877.g007" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g007</object-id><label>Fig 7</label><caption><title>Visual representation: Sequence constraints (C5).</title></caption><graphic xlink:href="pone.0226877.g007"/></fig><p><italic>Decision</italic>: Distinguish property constraints from sequence constraints. <italic>Rationale</italic>: We regard sequence constraints, which manage event order, and property constraints, which manage event content relations, as semantically different. Accordingly, we represent them differently increasing perceptual discriminability.</p></sec><sec id="sec016"><title>Completion actions (C6)</title><p>Completion actions serve as replacements for those editing operations that have not been performed manually. An activity definition comprises completion actions for all specified editing operations. Each completion action contains property value assignments that correspond to the property constraints of its editing operation. As such, it can be automatically retrieved from the editing operation definition. For that reason, completion actions are not explicitly expressed in a visual activity definition. Instead, each editing operation and the resulting element version visualize the corresponding completion action.</p></sec><sec id="sec017"><title>Completion defaults (C7)</title><p>Completion defaults specify default values for element properties that are applied when the auto-completion of a modeling activity is executed. Completion actions can comprise completion defaults that must be defined explicitly. We integrate the completion defaults into the resulting element versions of editing operations as shown in <xref ref-type="fig" rid="pone.0226877.g008">Fig 8</xref>. The example in the figure specifies that a user must add an association of subtype aggregation or composition to match. If this operation is auto-completed rather than manually executed, an association of subtype composition will be added.</p><fig id="pone.0226877.g008" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g008</object-id><label>Fig 8</label><caption><title>Visual representation: Completion defaults (C7).</title></caption><graphic xlink:href="pone.0226877.g008"/></fig></sec></sec><sec id="sec018"><title>4.2 VisPaRec&#x02019;s expressiveness and scope</title><p>At the core, all EPLs are used to specify patterns by describing participating objects as <italic>variables</italic> and how they are related as <italic>guards</italic>, as well as what should happen whenever a pattern is matched as an <italic>action</italic> [<xref rid="pone.0226877.ref033" ref-type="bibr">33</xref>]. VisPaRec allows users to specify the variables in multiple different ways, tailored to the domain. Both, element versions as well as editing operations, serve as variables. As element versions are allowed to have arbitrary properties, they have full expressiveness. Sequence constraints, property constraints and model elements represent the guard concept. Model elements and sequence constraints, however, can only express specialized relations and are not as expressive as general guards. Property constraints can specify arbitrary relations between elements, and therefore are as expressive as the guard concept. This has the consequence that model elements and sequence constraints can be expressed as property constraints, but doing so results in massively harder to read and write descriptions. One can therefore see them as an abbreviating syntax construct. The completion actions are the equivalent of the action of a CEP pattern. One should note that the action of a CEP rule is only activated when the whole pattern is matched, while completion actions are applied whenever a single variable is matched. The behavior of completion actions is at least as expressive, as one can perform the desired action in the completion action of the object matched last. <xref rid="pone.0226877.t001" ref-type="table">Table 1</xref> summarizes the mapping between the basic CEP concepts and the visual concepts in VisPaRec implementing them. The table shows that for every CEP concept a VisPaRec element with the same expressiveness exist, concepts with full expressiveness are marked in italic. Therefore, VisPaRec can be used to express arbitrary complex events patterns.</p><table-wrap id="pone.0226877.t001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.t001</object-id><label>Table 1</label><caption><title>Mapping between CEP and VisPaRec concepts.</title></caption><alternatives><graphic id="pone.0226877.t001g" xlink:href="pone.0226877.t001"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="right" rowspan="1" colspan="1">Basic CEP concept</th><th align="left" rowspan="1" colspan="1">Matching VisPaRec concept</th></tr></thead><tbody><tr><td align="right" rowspan="1" colspan="1">variable</td><td align="left" rowspan="1" colspan="1"><italic>element version</italic>, editing operation</td></tr><tr><td align="right" rowspan="1" colspan="1">guard</td><td align="left" rowspan="1" colspan="1"><italic>property constraint</italic>, sequence constraint, model element</td></tr><tr><td align="right" rowspan="1" colspan="1">action</td><td align="left" rowspan="1" colspan="1"><italic>completion action</italic>, completion default</td></tr></tbody></table></alternatives></table-wrap></sec><sec id="sec019"><title>4.3 Comparison of event processing languages</title><p>Now, we take a closer look into how different EPLs specify the basic CEP concepts discussed in Section 4.2 as well as the domain specific concepts described in Section 3. <xref ref-type="fig" rid="pone.0226877.g009">Fig 9</xref> shows an example pattern in VisPaRec that we will refer to as the <italic>example activity</italic>. It is a simplified version of the pattern shown in <xref ref-type="fig" rid="pone.0226877.g012">Fig 12</xref> that we reduced for space reasons. We formulate this pattern in various CEP languages in order to compare them with each other. The pattern matches when an attribute is deleted and a class is added, which is then renamed to the name of the deleted attribute. No additional explicit order between these events is enforced. Figs <xref ref-type="fig" rid="pone.0226877.g009">9</xref>, <xref ref-type="fig" rid="pone.0226877.g010">10</xref> and <xref ref-type="fig" rid="pone.0226877.g011">11</xref> show the implementation of this activity in the respective languages.</p><fig id="pone.0226877.g009" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g009</object-id><label>Fig 9</label><caption><title>Example activity modeled in our VisPaRec language.</title></caption><graphic xlink:href="pone.0226877.g009"/></fig><fig id="pone.0226877.g010" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g010</object-id><label>Fig 10</label><caption><title>Example activity modeled in Strelka [<xref rid="pone.0226877.ref023" ref-type="bibr">23</xref>].</title></caption><graphic xlink:href="pone.0226877.g010"/></fig><fig id="pone.0226877.g011" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g011</object-id><label>Fig 11</label><caption><title>Example activity modeled in MEdit4CEP [<xref rid="pone.0226877.ref024" ref-type="bibr">24</xref>].</title></caption><graphic xlink:href="pone.0226877.g011"/></fig><fig id="pone.0226877.g012" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.g012</object-id><label>Fig 12</label><caption><title>VisPaRec definition of the modeling activity &#x0201c;Extracting attribute as class&#x0201d;.</title></caption><graphic xlink:href="pone.0226877.g012"/></fig><sec id="sec020"><title>4.3.1 Evaluation of visual event processing languages</title><p><italic>Strelka</italic>. <xref ref-type="fig" rid="pone.0226877.g010">Fig 10</xref> shows how the example activity can be modeled with Strelka, using URML. The variables are represented by classes following the UML notation. The blue arrows pointing from a class to the rule are so-called <italic>ClassificationCondition</italic>s, specifying what a single class has to fulfill in order to fit the pattern. The blue arrows pointing from an association to the rule are <italic>AssociationCondition</italic>s, specifying how classes must be related in order to fit the pattern. These two concepts represent guards.</p><p><italic>MEdit4CEP</italic>. The model depicted in <xref ref-type="fig" rid="pone.0226877.g011">Fig 11</xref> represents the example activity modeled in MEdit4CEP. <italic>Simple events</italic> serve as variables and are represented as rectangles with a green &#x0201c;E&#x0201d; on the top left corner. If an event has properties, these are listed within the event&#x02019;s rectangle as separate rectangles with a green &#x0201c;P&#x0201d; on the top left corner. Constant values are visualized as black rectangles with rounded corners and a broad border. Any comparison operator is represented by a single model element that is a pink circle containing the comparison symbol. It must have two incoming arrows to specify the arguments, which need to be ordered explicitly by the numbers &#x0201c;1&#x0201d; and &#x0201c;2&#x0201d;. Comparison operators together with constants represent the guard concept. Any pattern must contain a <italic>complex event</italic> that must have at least one property that is connected to a property of a simple event. Complex events are represented much like simple events, but use red labeling.</p><p><italic>Comparison</italic>. The example shows that in Strelka and MEdit4CEP manyfold relations must be explicitly specified. This is the result of the very general nature of both languages. These relations could actually be formulated more intuitively and more compactly. The main problem is that one must explicitly specify which operations and element versions refer to the same object, which happens very frequently in our application. Additionally, the order of editing operations must be specified by enforcing an order between time stamps. Furthermore, MEdit4CEP displays all event properties at all times, which is not necessary for the given application, where the same two event types are used over and over. Note that we left out properties not relevant to the small pattern presented, and more properties are relevant in general. Both diagrams reach the limit of what is comfortably displayable on one screen even for this very small example. We therefore come to the conclusion that the presented unspecialized visual languages are not applicable for larger patterns within our application.</p><p>VisPaRec differentiates itself through several design choices of which we regard the following ones as most significant.
<list list-type="order"><list-item><p>VisPaRec uses swim lanes to keep track of element versions as well as editing operations regarding the same object. The other two considered visual languages use the guard concept to model this. While guards prevent introducing a new concept, they require encoding the semantic of referring to the same object numerous times.</p></list-item><list-item><p>VisPaRec gives editing operations a specialized visualization, whereas Strelka and MEdit4CEP use their respective guard syntax. Thereby, VisPaRec can reduce the number of elements to a more manageable amount and differentiates the semantically very different editing operations visually as well.</p></list-item><list-item><p>VisPaRec colors sequence constraints and property constraints differently, which again keeps semantically different concepts also visually distinguishable.</p></list-item></list></p><p>Regarding graphic economy, Strelka uses a very low number of different symbols. VisPaRec does introduce more symbols than Strelka, as it is necessary to cover the range of semantic constructs deducted from the metamodel in <xref ref-type="fig" rid="pone.0226877.g002">Fig 2</xref>. MEdit4CEP uses some symbols that we find too excessive for the application, and simply inflate the number of symbols. Examples for this are the element naming, the differentiation between element and properties, as well as the numbers identifying the inputs of the = relation (even though it does not matter since = is a symmetric relation).</p></sec><sec id="sec021"><title>4.3.2 Evaluation of textual event processing languages</title><p>To analyze the similarities and differences of common EPLs applicable for the definition of activity patterns, we discuss main language concepts on an example activity written in Rapide, DRL, and Esper EPL (cp. Section 2). The resulting specifications are shown in Listing 1, 2 and 3, respectively. For brevity and readability, we are omitting surrounding parts of the pattern specification like rule declaration, variable declarations, rules&#x02019; action part etc. and focus on the core pattern definitions.</p><p><bold>Listing 1</bold>. Example activity written in Rapide.</p><p><monospace>1 EditingOperation(Element_Version</monospace>
<inline-formula id="pone.0226877.e010"><alternatives><graphic xlink:href="pone.0226877.e010.jpg" id="pone.0226877.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mtext mathcolor="#3333cc" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e011"><alternatives><graphic xlink:href="pone.0226877.e011.jpg" id="pone.0226877.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3) where</monospace></p><p><monospace>2</monospace> &#x02003;<monospace>(</monospace>
<inline-formula id="pone.0226877.e012"><alternatives><graphic xlink:href="pone.0226877.e012.jpg" id="pone.0226877.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3.Type</monospace>
<inline-formula id="pone.0226877.e013"><alternatives><graphic xlink:href="pone.0226877.e013.jpg" id="pone.0226877.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;attribute&#x0201d;)</monospace></p><p><monospace>3</monospace>
<inline-formula id="pone.0226877.e014"><alternatives><graphic xlink:href="pone.0226877.e014.jpg" id="pone.0226877.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>01(Element_Version</monospace>
<inline-formula id="pone.0226877.e015"><alternatives><graphic xlink:href="pone.0226877.e015.jpg" id="pone.0226877.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mtext mathcolor="#3333cc" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e016"><alternatives><graphic xlink:href="pone.0226877.e016.jpg" id="pone.0226877.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V4, Operation_Type</monospace>
<inline-formula id="pone.0226877.e017"><alternatives><graphic xlink:href="pone.0226877.e017.jpg" id="pone.0226877.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mtext mathcolor="#e53332" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;delete&#x0201d;) where</monospace></p><p><monospace>4</monospace> &#x02003;<monospace>(</monospace>
<inline-formula id="pone.0226877.e018"><alternatives><graphic xlink:href="pone.0226877.e018.jpg" id="pone.0226877.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V4.ID</monospace>
<inline-formula id="pone.0226877.e019"><alternatives><graphic xlink:href="pone.0226877.e019.jpg" id="pone.0226877.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e020"><alternatives><graphic xlink:href="pone.0226877.e020.jpg" id="pone.0226877.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3.ID)</monospace></p><p><monospace>5</monospace>
<inline-formula id="pone.0226877.e021"><alternatives><graphic xlink:href="pone.0226877.e021.jpg" id="pone.0226877.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>02(Element_Version</monospace>
<inline-formula id="pone.0226877.e022"><alternatives><graphic xlink:href="pone.0226877.e022.jpg" id="pone.0226877.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mtext mathcolor="#3333cc" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e023"><alternatives><graphic xlink:href="pone.0226877.e023.jpg" id="pone.0226877.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V5, Operation_Type</monospace>
<inline-formula id="pone.0226877.e024"><alternatives><graphic xlink:href="pone.0226877.e024.jpg" id="pone.0226877.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:mtext mathcolor="#e53332" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;add&#x0201d;) where</monospace></p><p><monospace>6</monospace> &#x02003;<monospace>(</monospace>
<inline-formula id="pone.0226877.e025"><alternatives><graphic xlink:href="pone.0226877.e025.jpg" id="pone.0226877.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V5.Type</monospace>
<inline-formula id="pone.0226877.e026"><alternatives><graphic xlink:href="pone.0226877.e026.jpg" id="pone.0226877.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;class&#x0201d;)</monospace></p><p><monospace>7</monospace>
<inline-formula id="pone.0226877.e027"><alternatives><graphic xlink:href="pone.0226877.e027.jpg" id="pone.0226877.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>03(Element_Version</monospace>
<inline-formula id="pone.0226877.e028"><alternatives><graphic xlink:href="pone.0226877.e028.jpg" id="pone.0226877.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mtext mathcolor="#3333cc" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e029"><alternatives><graphic xlink:href="pone.0226877.e029.jpg" id="pone.0226877.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V6, Operation_Type</monospace>
<inline-formula id="pone.0226877.e030"><alternatives><graphic xlink:href="pone.0226877.e030.jpg" id="pone.0226877.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:mtext mathcolor="#e53332" mathvariant="monospace">is</mml:mtext></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;modify&#x0201d;) where</monospace></p><p><monospace>8</monospace> &#x02003;<monospace>(</monospace>
<inline-formula id="pone.0226877.e031"><alternatives><graphic xlink:href="pone.0226877.e031.jpg" id="pone.0226877.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V6.ID</monospace>
<inline-formula id="pone.0226877.e032"><alternatives><graphic xlink:href="pone.0226877.e032.jpg" id="pone.0226877.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e033"><alternatives><graphic xlink:href="pone.0226877.e033.jpg" id="pone.0226877.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V5.ID and</monospace>
<inline-formula id="pone.0226877.e034"><alternatives><graphic xlink:href="pone.0226877.e034.jpg" id="pone.0226877.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V6.Name</monospace>
<inline-formula id="pone.0226877.e035"><alternatives><graphic xlink:href="pone.0226877.e035.jpg" id="pone.0226877.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e036"><alternatives><graphic xlink:href="pone.0226877.e036.jpg" id="pone.0226877.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:mo mathcolor="#1ab24d">?</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3.Name)</monospace></p><p><bold>Listing 2</bold>. Example activity written in DRL.</p><p><monospace>1 EditingOperation(</monospace>
<inline-formula id="pone.0226877.e037"><alternatives><graphic xlink:href="pone.0226877.e037.jpg" id="pone.0226877.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3</monospace>
<inline-formula id="pone.0226877.e038"><alternatives><graphic xlink:href="pone.0226877.e038.jpg" id="pone.0226877.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>Element_Version,</monospace>
<inline-formula id="pone.0226877.e039"><alternatives><graphic xlink:href="pone.0226877.e039.jpg" id="pone.0226877.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3.Type</monospace>
<inline-formula id="pone.0226877.e040"><alternatives><graphic xlink:href="pone.0226877.e040.jpg" id="pone.0226877.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;attribute&#x0201d;)</monospace></p><p><monospace>2</monospace>
<inline-formula id="pone.0226877.e041"><alternatives><graphic xlink:href="pone.0226877.e041.jpg" id="pone.0226877.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>01</monospace>
<inline-formula id="pone.0226877.e042"><alternatives><graphic xlink:href="pone.0226877.e042.jpg" id="pone.0226877.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation(</monospace>
<inline-formula id="pone.0226877.e043"><alternatives><graphic xlink:href="pone.0226877.e043.jpg" id="pone.0226877.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V4</monospace>
<inline-formula id="pone.0226877.e044"><alternatives><graphic xlink:href="pone.0226877.e044.jpg" id="pone.0226877.e044g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M44"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>Element_Version,</monospace></p><p><monospace>3</monospace> &#x02003;<monospace>Operation_Type</monospace>
<inline-formula id="pone.0226877.e045"><alternatives><graphic xlink:href="pone.0226877.e045.jpg" id="pone.0226877.e045g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M45"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;delete&#x0201d;,</monospace>
<inline-formula id="pone.0226877.e046"><alternatives><graphic xlink:href="pone.0226877.e046.jpg" id="pone.0226877.e046g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M46"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V4.ID</monospace>
<inline-formula id="pone.0226877.e047"><alternatives><graphic xlink:href="pone.0226877.e047.jpg" id="pone.0226877.e047g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M47"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e048"><alternatives><graphic xlink:href="pone.0226877.e048.jpg" id="pone.0226877.e048g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M48"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3.ID)</monospace></p><p><monospace>4</monospace>
<inline-formula id="pone.0226877.e049"><alternatives><graphic xlink:href="pone.0226877.e049.jpg" id="pone.0226877.e049g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M49"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>02</monospace>
<inline-formula id="pone.0226877.e050"><alternatives><graphic xlink:href="pone.0226877.e050.jpg" id="pone.0226877.e050g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M50"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation(</monospace>
<inline-formula id="pone.0226877.e051"><alternatives><graphic xlink:href="pone.0226877.e051.jpg" id="pone.0226877.e051g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M51"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V5</monospace>
<inline-formula id="pone.0226877.e052"><alternatives><graphic xlink:href="pone.0226877.e052.jpg" id="pone.0226877.e052g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M52"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>Element_Version,</monospace></p><p><monospace>5</monospace> &#x02003;<monospace>Operation_Type</monospace>
<inline-formula id="pone.0226877.e053"><alternatives><graphic xlink:href="pone.0226877.e053.jpg" id="pone.0226877.e053g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M53"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;add&#x0201d;,</monospace>
<inline-formula id="pone.0226877.e054"><alternatives><graphic xlink:href="pone.0226877.e054.jpg" id="pone.0226877.e054g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M54"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V5.Type</monospace>
<inline-formula id="pone.0226877.e055"><alternatives><graphic xlink:href="pone.0226877.e055.jpg" id="pone.0226877.e055g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M55"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;class&#x0201d;)</monospace></p><p><monospace>6</monospace>
<inline-formula id="pone.0226877.e056"><alternatives><graphic xlink:href="pone.0226877.e056.jpg" id="pone.0226877.e056g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M56"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>03</monospace>
<inline-formula id="pone.0226877.e057"><alternatives><graphic xlink:href="pone.0226877.e057.jpg" id="pone.0226877.e057g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M57"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation(V6</monospace>
<inline-formula id="pone.0226877.e058"><alternatives><graphic xlink:href="pone.0226877.e058.jpg" id="pone.0226877.e058g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M58"><mml:mo mathcolor="#3333cc">:</mml:mo></mml:math></alternatives></inline-formula>
<monospace>Element_Version,</monospace></p><p><monospace>7</monospace> &#x02003;<monospace>Operation_Type</monospace>
<inline-formula id="pone.0226877.e059"><alternatives><graphic xlink:href="pone.0226877.e059.jpg" id="pone.0226877.e059g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M59"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;modify&#x0201d;,</monospace>
<inline-formula id="pone.0226877.e060"><alternatives><graphic xlink:href="pone.0226877.e060.jpg" id="pone.0226877.e060g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M60"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V6.ID</monospace>
<inline-formula id="pone.0226877.e061"><alternatives><graphic xlink:href="pone.0226877.e061.jpg" id="pone.0226877.e061g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M61"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e062"><alternatives><graphic xlink:href="pone.0226877.e062.jpg" id="pone.0226877.e062g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M62"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V5.ID,</monospace></p><p><monospace>8</monospace> &#x02003;<inline-formula id="pone.0226877.e063"><alternatives><graphic xlink:href="pone.0226877.e063.jpg" id="pone.0226877.e063g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M63"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V6. Name</monospace>
<inline-formula id="pone.0226877.e064"><alternatives><graphic xlink:href="pone.0226877.e064.jpg" id="pone.0226877.e064g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M64"><mml:mo mathcolor="#e53332">==</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e065"><alternatives><graphic xlink:href="pone.0226877.e065.jpg" id="pone.0226877.e065g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M65"><mml:mo mathcolor="#1ab24d">$</mml:mo></mml:math></alternatives></inline-formula>
<monospace>V3. Name)</monospace></p><p><bold>Listing 3</bold>. Example activity written in Esper EPL.</p><p><monospace>1</monospace>
<inline-formula id="pone.0226877.e066"><alternatives><graphic xlink:href="pone.0226877.e066.jpg" id="pone.0226877.e066g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M66"><mml:mo mathcolor="#994d99">(</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EO3</monospace>
<inline-formula id="pone.0226877.e067"><alternatives><graphic xlink:href="pone.0226877.e067.jpg" id="pone.0226877.e067g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M67"><mml:mo mathcolor="#3333cc">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation (Element_Version.Type</monospace>
<inline-formula id="pone.0226877.e068"><alternatives><graphic xlink:href="pone.0226877.e068.jpg" id="pone.0226877.e068g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M68"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;attribute&#x0201d;)</monospace>
<inline-formula id="pone.0226877.e069"><alternatives><graphic xlink:href="pone.0226877.e069.jpg" id="pone.0226877.e069g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M69"><mml:mo mathcolor="#994d99">-</mml:mo><mml:mo mathcolor="#994d99">&#x0003e;</mml:mo></mml:math></alternatives></inline-formula></p><p><monospace>2 01</monospace>
<inline-formula id="pone.0226877.e070"><alternatives><graphic xlink:href="pone.0226877.e070.jpg" id="pone.0226877.e070g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M70"><mml:mo mathcolor="#3333cc">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation (Operation_Type</monospace>
<inline-formula id="pone.0226877.e071"><alternatives><graphic xlink:href="pone.0226877.e071.jpg" id="pone.0226877.e071g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M71"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;delete&#x0201d;,</monospace></p><p><monospace>3</monospace> &#x02003;<monospace>Element_Version.ID</monospace>
<inline-formula id="pone.0226877.e072"><alternatives><graphic xlink:href="pone.0226877.e072.jpg" id="pone.0226877.e072g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M72"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EO3.Element_Version.ID)</monospace>
<inline-formula id="pone.0226877.e073"><alternatives><graphic xlink:href="pone.0226877.e073.jpg" id="pone.0226877.e073g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M73"><mml:mo mathcolor="#994d99">)</mml:mo></mml:math></alternatives></inline-formula>
<inline-formula id="pone.0226877.e074"><alternatives><graphic xlink:href="pone.0226877.e074.jpg" id="pone.0226877.e074g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M74"><mml:mtext mathcolor="#994d99" mathvariant="monospace">and</mml:mtext></mml:math></alternatives></inline-formula></p><p><monospace>4</monospace>
<inline-formula id="pone.0226877.e075"><alternatives><graphic xlink:href="pone.0226877.e075.jpg" id="pone.0226877.e075g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M75"><mml:mo mathcolor="#994d99">(</mml:mo></mml:math></alternatives></inline-formula>
<monospace>02</monospace>
<inline-formula id="pone.0226877.e076"><alternatives><graphic xlink:href="pone.0226877.e076.jpg" id="pone.0226877.e076g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M76"><mml:mo mathcolor="#3333cc">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation (Operation_Type</monospace>
<inline-formula id="pone.0226877.e077"><alternatives><graphic xlink:href="pone.0226877.e077.jpg" id="pone.0226877.e077g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M77"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;add&#x0201d;,</monospace></p><p><monospace>5</monospace> &#x02003;<monospace>Element_Version.Type</monospace>
<inline-formula id="pone.0226877.e078"><alternatives><graphic xlink:href="pone.0226877.e078.jpg" id="pone.0226877.e078g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M78"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;class&#x0201d;)</monospace>
<inline-formula id="pone.0226877.e079"><alternatives><graphic xlink:href="pone.0226877.e079.jpg" id="pone.0226877.e079g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M79"><mml:mo mathcolor="#994d99">-</mml:mo><mml:mo mathcolor="#994d99">&#x0003e;</mml:mo></mml:math></alternatives></inline-formula></p><p><monospace>6 03</monospace>
<inline-formula id="pone.0226877.e080"><alternatives><graphic xlink:href="pone.0226877.e080.jpg" id="pone.0226877.e080g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M80"><mml:mo mathcolor="#3333cc">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>EditingOperation(Operation_Type</monospace>
<inline-formula id="pone.0226877.e081"><alternatives><graphic xlink:href="pone.0226877.e081.jpg" id="pone.0226877.e081g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M81"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>&#x0201c;modify&#x0201d;,</monospace></p><p><monospace>7</monospace> &#x02003;<monospace>03. ElementVersion.ID</monospace>
<inline-formula id="pone.0226877.e082"><alternatives><graphic xlink:href="pone.0226877.e082.jpg" id="pone.0226877.e082g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M82"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>02.ElementVersion.ID)</monospace>
<inline-formula id="pone.0226877.e083"><alternatives><graphic xlink:href="pone.0226877.e083.jpg" id="pone.0226877.e083g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M83"><mml:mo mathcolor="#994d99">)</mml:mo></mml:math></alternatives></inline-formula></p><p><monospace>8</monospace>
<inline-formula id="pone.0226877.e084"><alternatives><graphic xlink:href="pone.0226877.e084.jpg" id="pone.0226877.e084g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M84"><mml:mtext mathcolor="#b47cb4" mathvariant="monospace">where</mml:mtext></mml:math></alternatives></inline-formula>
<monospace>03.ElementVersion.Name</monospace>
<inline-formula id="pone.0226877.e085"><alternatives><graphic xlink:href="pone.0226877.e085.jpg" id="pone.0226877.e085g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M85"><mml:mo mathcolor="#e53332">=</mml:mo></mml:math></alternatives></inline-formula>
<monospace>01.ElementVersion.Name</monospace></p><p><italic>Assignments</italic>. In the Listings 1, 2 and 3, assignment operators are colored blue, while comparison operators are colored red. A comparison shows that the languages differ in how they mark assignments, how they express relations to constants and how they express relations to variable parts. Rapide uses the keyword &#x0201c;is&#x0201d; for variable assignments as well as comparisons with constants. It uses &#x0201c;=&#x0201d; for comparisons between variables. DRL uses &#x0201c;:&#x0201d; for all assignments, but &#x0201c;=&#x0201d; for both types of comparison. In Esper EPL, assignments as well as comparisons use &#x0201c;=&#x0201d;. All three ways of specification are reasonable, as the separation of syntactically different operators is important but it also is valuable to keep the number of syntactical elements of a language manageable. Furthermore, Esper EPL is missing a syntax construct that allows assignments of attributes to variables. While the syntax for this can be seen in line 1 for Rapide and DRL, Esper EPL needs to refer to the attribute using the object every time. This can be rather clunky when using a sub-object often, or when referring to an attribute of a sub-object.</p><p><italic>Variables</italic>. All variables are colored green in the examples. The type of editing operations like <italic>O</italic>1 and <italic>O</italic>2 must be declared on every use in DRL and Esper EPL, while Rapide declares all variables at the start of the file. Rapide, therefore, is very compact in specifications where object types are often reused. Variables are typically marked with the prefix &#x0201c;?&#x0201d; in Rapide and &#x0201c;$&#x0201d; in DRL, while Esper EPL usually does not use such a prefix. Although a prefix adds an extra character that may look confusing at first, it helps differentiating variables from constant expressions. The prefix &#x0201c;?&#x0201d; stresses the variable nature and thus has a somewhat plausible association with a variable. Anyway those are merely conventions.</p><p><italic>Sequencing</italic>. All sequencing related language elements are colored purple in the examples. In Esper EPL, the sequencing of events is specified through the &#x0201c;&#x02212; &#x0003e;&#x0201d; operator, which is used whenever the left hand side event happens before the right hand side event. It binds weaker than the &#x0201c;and&#x0201d; operator. The keyword &#x0201c;where&#x0201d; is used to filter the matches of a pattern after it is completed. This is necessary because the example activity has two concurrent streams of events that must be connected by the constraint of identical names. While Esper EPL&#x02019;s syntax allows the user to specify the sequence of events in a very compact way, the user must explicitly specify every detail of the sequence. On the one hand, this makes the user more aware of the event flow than the syntax of Rapide or DRL, on the other hand, we found it surprisingly hard to get the sequencing right for examples within our application. The other two languages formulate sequencing constraints just like any other property constraint, while the internal matching order is determined by the order of the statements from top to bottom.</p><p>In conclusion, all three textual languages were able to express the example within a similar amount of space. We discuss their applicability in regards to modeling activity patterns within the context of our evaluation in Section 6.1.</p></sec></sec></sec><sec id="sec022"><title>5 Defining modeling activities by example</title><p>We now propose a semi-automated definition process that comprises three steps: (1) demonstrating the modeling activity and deriving an initial activity definition, (2) manually refining the activity definition, and (3) generating platform-specific event-processing rules from the activity definition. The following subsections describe these three processing steps in detail.</p><sec id="sec023"><title>5.1 Step 1: Demonstrating the modeling activity</title><p>The first step is often the hardest. Therefore, providing an intuitive way for creating an activity definition rather than starting to construct it from scratch is highly desired. A state-of-the-art way to address this goal is the definition &#x0201c;by-demonstration&#x0201d;, which allows a user to simply execute a desired behavior within a familiar working environment and to automatically derive an initial description based on that demonstration. This demonstration step starts on an empty diagram of a supported model type, e.g., a UML class diagram, and comprises two phases: (1a) modeling the activity preconditions and (1b) performing the editing operations. The following paragraphs describe these two phases and the transformation rules that are applied to create an activity definition that conforms to the meta-model depicted in <xref ref-type="fig" rid="pone.0226877.g002">Fig 2</xref>.</p><sec id="sec024"><title>Step 1a: Modeling the activity preconditions</title><p>The preconditions of a modeling activity comprise model elements that have to be present before the modeling activity may be performed. In order to demonstrate the preconditions, the user adds the model elements to an empty diagram and defines their important properties. The preconditions for our example activity can be seen in <xref ref-type="fig" rid="pone.0226877.g001">Fig 1</xref>. Before starting the activity, a class must exist containing an attribute to be extracted. While the user is modeling the activity preconditions, <italic>Rule 1</italic> to <italic>Rule 4</italic> are applied. This step leads to at least one element version for each modeled element, specifying all relevant property constraints. Once all activity preconditions have been modeled, the user approves them and thereby enters phase (1b): the demonstration of the editing operations.</p><p><bold>Rule 1</bold>: Add new model element</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>editing operation</italic>
<italic>o</italic> of type add for a <italic>model element e</italic> (<italic>o</italic> &#x02208; <italic>O</italic>, <inline-formula id="pone.0226877.e086"><alternatives><graphic xlink:href="pone.0226877.e086.jpg" id="pone.0226877.e086g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M86"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>|</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>d</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>)</p><p specific-use="line"><bold>2</bold> &#x02003;<bold>create</bold> an <italic>element version</italic>
<italic>v</italic><sub><bold>0</bold></sub>, where <italic>v</italic><sub>0</sub> specifies the state before <italic>o</italic>: <italic>v</italic><sub>0</sub> = <italic>pre</italic>(<italic>o</italic>)</p><p specific-use="line"><bold>3</bold> &#x02003;&#x02003;<bold>define</bold> the non-existence of <italic>e</italic> by setting <italic>v</italic><sub>0</sub> to type <italic>Non-Existent</italic></p><p specific-use="line"><bold>4</bold> &#x02003;<bold>create</bold> an <italic>element version</italic>
<italic>v</italic><sub><bold>1</bold></sub>, where <italic>v</italic><sub>1</sub> specifies the resulting state of <italic>o</italic>: <italic>v</italic><sub>1</sub> = <italic>result</italic>(<italic>o</italic>)</p><p specific-use="line"><bold>5</bold> &#x02003;&#x02003;<bold>forall</bold> non-empty properties <italic>x</italic> of <italic>v</italic><sub>1</sub>, except <italic>ID</italic> and <italic>Name</italic>
<bold>do</bold></p><p specific-use="line"><bold>6</bold> &#x02003;&#x02003;&#x02003;<bold>define</bold> a <italic>property constraint</italic> of the type (<italic>identifier</italic>(<italic>x</italic><sub><italic>i</italic></sub>) = <italic>value</italic>(<italic>x</italic><sub><italic>i</italic></sub>))</p><p><bold>Rule 2</bold>: Modify existing model element</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>editing operation</italic>
<italic>o</italic> of type modify for a <italic>model element e</italic> (<italic>o</italic> &#x02208; <italic>O</italic>, <inline-formula id="pone.0226877.e087"><alternatives><graphic xlink:href="pone.0226877.e087.jpg" id="pone.0226877.e087g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M87"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>|</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>)</p><p specific-use="line"><bold>2</bold> &#x02003;<bold>retrieve</bold> an <italic>element version</italic>
<italic>v</italic><sub><italic>n</italic></sub>, where <italic>v</italic><sub><italic>n</italic></sub> is the last version of <italic>e</italic> preliminary to <italic>o</italic> (<italic>v</italic><sub><italic>n</italic></sub> = <italic>last</italic>(<italic>e</italic>))</p><p specific-use="line"><bold>3</bold> &#x02003;<bold>create</bold> an <italic>element version</italic>
<bold><italic>v</italic><sub><italic>n</italic>+1</sub></bold>, where <italic>v</italic><sub><italic>n</italic>+1</sub> specifies the state of <italic>e</italic> subsequent to <italic>o</italic> (<italic>v</italic><sub><italic>n</italic>+1</sub> = <italic>result</italic>(<italic>o</italic>))</p><p specific-use="line"><bold>4</bold> &#x02003;&#x02003;<bold>forall</bold> properties <italic>x</italic> of <italic>v</italic><sub><italic>n</italic>+1</sub>
<bold>do</bold></p><p specific-use="line"><bold>5</bold> &#x02003;&#x02003;&#x02003;<bold>if</bold> value(<italic>x</italic>(<italic>v</italic><sub><italic>n</italic></sub>)) &#x02260; value(<italic>x</italic>(<italic>v</italic><sub><italic>n</italic>+1</sub>)) <bold>then</bold></p><p specific-use="line"><bold>6</bold> &#x02003;&#x02003;&#x02003;&#x02003;<bold>define</bold> a <italic>property constraint</italic> of the type (<italic>identifier</italic>(<italic>x</italic>) = <italic>value</italic>(<italic>x</italic>))</p><p><bold>Rule 3</bold>: Delete existing model element</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>editing operation</italic>
<bold><italic>o</italic></bold> of type delete for a <italic>model element</italic>
<italic><bold>e</bold></italic> (<italic>o</italic> &#x02208; <italic>O</italic>, <inline-formula id="pone.0226877.e088"><alternatives><graphic xlink:href="pone.0226877.e088.jpg" id="pone.0226877.e088g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M88"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>|</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>)</p><p specific-use="line"><bold>2</bold> &#x02003;<bold>retrieve</bold> an <italic>element version</italic>
<bold><italic>v</italic><sub><italic>n</italic></sub></bold>, where <italic>v</italic><sub><italic>n</italic></sub> is the last version of <italic>e</italic> preliminary to the model element deletion operation <italic>o</italic>: <italic>v</italic><sub><italic>n</italic></sub> = <italic>last</italic>(<italic>e</italic>)</p><p specific-use="line"><bold>3</bold> &#x02003;<bold>create</bold> an <italic>element version</italic>
<bold><italic>v</italic><sub><italic>n</italic>+1</sub></bold>, where <italic>v</italic><sub><italic>n</italic>+1</sub> specifies the state of <italic>e</italic> subsequent to the model element deletion operation <italic>o</italic>: <italic>v</italic><sub><italic>n</italic>+1</sub> = <italic>result</italic>(<italic>o</italic>)</p><p specific-use="line"><bold>4</bold> &#x02003;&#x02003;<bold>define</bold> the non-existence of <italic>e</italic> by setting <italic>v</italic><sub><italic>n</italic>+1</sub> to type <italic>Non-Existent</italic></p></sec><sec id="sec025"><title>Step 1b: Performing the editing operations</title><p>Upon approving the preconditions, <italic>Rule 5</italic> is applied. This removes obsolete element versions and editing operations and leads to exactly one element version of type <italic>Existent</italic> for each preexisting model element. The user then performs the editing operations of the modeling activity involving preexisting and newly created model elements. Again, <italic>Rule 1</italic> to <italic>4</italic> are applied in order to create the corresponding objects in the activity definition. To demonstrate a delete operation, a preexisting model element is deleted from the diagram. For demonstrating an add operation, a new model element can be added from the toolbox without the need to change any property. The user only needs to edit those element properties that shall be transformed into property constraints of the activity definition (<italic>Rule 2</italic>). Our activity recognition approach handles the undo of editing operations within the modeling tool, i.e., a user may use this functionality upon mistakes in performing editing operations and modeling preconditions without impact on the resulting activity definition. <xref ref-type="fig" rid="pone.0226877.g001">Fig 1</xref> shows that <italic>Class2</italic> has been modified to express a property constraint: the name of <italic>Class2</italic> must be set to the name of the extracted attribute. Most of these property constraints can be derived automatically during the demonstration step by applying <italic>Rule 6</italic>. <italic>Rule 6</italic> replaces identical constant property values with references to the corresponding model elements, making the static property constraints dynamic. <xref ref-type="fig" rid="pone.0226877.g012">Fig 12</xref> illustrates such an initial definition that was obtained by demonstrating the example activity shown in <xref ref-type="fig" rid="pone.0226877.g001">Fig 1</xref>.</p><p>The presented set of transformation rules is independent of the model type that an activity is applied to. The set is meant as a basic rule set for creating initial activity definitions according to the specified meta-model. However, the set may be adjusted or enhanced for other types of models.</p></sec></sec><sec id="sec026"><title>5.2 Limitations of rule definition by example</title><p>Rule definition by example essentially uses a bit of event data, in our case a stream of editing operations, to infer matching rules. A rule can therefore be abstracted as one way to interpret correlations contained in the given bit of data. Unfortunately, the derivation process is inherently ambiguous, no matter how many demonstrations are given. As an illustrating example, two different element versions <italic>a</italic> and <italic>b</italic> may have the name &#x0201c;Factory&#x0201d;. The property constraints shown in Listing 4, as well as infinitely many other ones, would fit that state of data.</p><p><bold>Rule 4</bold>: Create version for preexisting model elements</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>model element e</italic> that have not assigned any element version (<inline-formula id="pone.0226877.e089"><alternatives><graphic xlink:href="pone.0226877.e089.jpg" id="pone.0226877.e089g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M89"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>|</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02205;</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>)</p><p specific-use="line"><bold>2</bold> &#x02003;<bold>create</bold> an <italic>element version</italic>
<bold><italic>v</italic><sub>0</sub></bold>, where <italic>v</italic><sub>0</sub> specifies the initial state of <italic>e</italic></p><p specific-use="line"><bold>3</bold> &#x02003;&#x02003;<bold>define</bold> the existence of <italic>e</italic> by setting <italic>v</italic><sub>0</sub> to type <italic>Existent</italic></p><p><bold>Rule 5</bold>: Remove obsolete versions and operations of model elements</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>model element e</italic></p><p specific-use="line"><bold>2</bold> &#x02003;<bold>if</bold> the model element <italic>e</italic> has been deleted already <inline-formula id="pone.0226877.e090"><alternatives><graphic xlink:href="pone.0226877.e090.jpg" id="pone.0226877.e090g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M90"><mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x02203;</mml:mo><mml:mi>v</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>:</mml:mo><mml:mo>&#x02227;</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02227;</mml:mo><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02209;</mml:mo><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
<bold>then</bold></p><p specific-use="line"><bold>3</bold> &#x02003;&#x02003;<bold>delete</bold> all editing operations: <italic>operation</italic>(<italic>e</italic>) and all element versions: <italic>version</italic>(<italic>e</italic>) of the deleted model element <italic>e</italic></p><p specific-use="line"><bold>4</bold> &#x02003;<bold>else</bold></p><p specific-use="line"><bold>5</bold> &#x02003;&#x02003;<bold>delete</bold> all editing operations: <italic>operation</italic>(<italic>e</italic>) and all element versions: <italic>version</italic>(<italic>e</italic>) of the model element <italic>e</italic> except the last version <italic>v</italic><sub><italic>n</italic></sub>: <italic>v</italic><sub><italic>n</italic></sub> = <italic>last</italic>(<italic>e</italic>)</p><p specific-use="line"><bold>6</bold> &#x02003;&#x02003;<bold>define</bold> the existence of <italic>e</italic> by setting <italic>v</italic><sub><italic>n</italic></sub> to type <italic>Existent</italic></p><p><bold>Rule 6</bold>: Create property constraint reference by identifier</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>element version v</italic></p><p specific-use="line"><bold>2</bold> &#x02003;<bold>forall</bold> property constraints <italic>p</italic> of <italic>v</italic>
<bold>do</bold></p><p specific-use="line"><bold>3</bold> &#x02003;&#x02003;<bold>if</bold>
<italic>value</italic>(<italic>p</italic>) contains the identifier of a model element <italic>e</italic>, where <italic>element</italic>(<italic>v</italic>) &#x02260; <italic>e</italic>
<bold>then</bold></p><p specific-use="line"><bold>4</bold> &#x02003;&#x02003;&#x02003;<bold>create</bold> a property constraint reference <italic>p</italic><sub><italic>r</italic></sub> pointing from <italic>v</italic> to the first existing version of <italic>e</italic>: <italic>exist</italic>(<italic>e</italic>)</p><p specific-use="line"><bold>5</bold> &#x02003;&#x02003;&#x02003;&#x02003;<bold>define</bold> a logical expression of the type (<italic>identifier</italic>(<italic>p</italic><sub><italic>r</italic></sub>) = <italic>ID</italic>) where <italic>ID</italic> references the identifier of <italic>e</italic></p><p specific-use="line"><bold>6</bold> &#x02003;&#x02003;&#x02003;<bold>delete</bold>
<italic>p</italic></p><p><bold>Listing 4</bold>. Possible Constraints based on the same demonstration</p><p><monospace>1 a.name == b.name</monospace></p><p><monospace>2 a.name == &#x0201c;Factory&#x0201d; &#x00026;&#x00026; b.name == &#x0201c;Factory&#x0201d;</monospace></p><p><monospace>3 a.name.startsWith(&#x0201c;Fac&#x0201d;) &#x00026;&#x00026; b.name.endsWith(&#x0201c;tory&#x0201d;)</monospace></p><p><monospace>4 a.name.startsWith(&#x0201c;Fac&#x0201d;) &#x00026;&#x00026; b.name == &#x0201c;Factory&#x0201d;</monospace></p><p>An example based rule definition must therefore aim to find rules that are simple and likely. As there can always be cases where the simple and likely interpretation is not the correct one, manual refinement of rules can be necessary. For example, the rule definer might have wanted to demonstrate rule number 3 of Listing 4, but since rule number 1 is simpler it will generally be preferred. Furthermore, a single example defines a very specific chronological order between all editing operations. As a large number of highly different demonstrations would be necessary to determine relevant sequence constraints, those must be excluded from our automatic detection. For the activity &#x0201c;Extracting attribute as class&#x0201d;, all of the relevant ID equivalencies and name equivalencies will be detected. But there is no way to know from a single example if any of the detected equivalencies are false positives. An interesting extension would be keeping some of the demonstrations to check whether a refinement done in the next step would lead to a contradiction.</p></sec><sec id="sec027"><title>5.3 Step 2: Manually refining the activity definition</title><p>In the second step of the process, the user manually refines the initial activity definition generated in <italic>Step 1</italic>. This step is required to generalize the activity definition and to add information that cannot be derived automatically. Refinements that need to be applied are of three generic types discussed below.</p><sec id="sec028"><title>Edit constraints</title><p>Refinements can be done in order to (1) add additional property constraints that have not been captured during demonstration, to (2) relax or extend constraints that have been captured already, and to (3) add sequence constraints that restrict the order of editing operations for performing an activity if necessary. For example, during the demonstration of the activity in <xref ref-type="fig" rid="pone.0226877.g001">Fig 1</xref>, an editing operation referred to the modification of the associations&#x02019; subtype into aggregation, but the intention of the user is to also allow the subtype composition for this activity. To do this refinement, the user needs to extend the existing constraint <italic>SubType</italic> = <italic>aggregation</italic> into <italic>SubType</italic> = <italic>aggregation</italic>, <italic>composition</italic> (see <xref ref-type="fig" rid="pone.0226877.g012">Fig 12</xref>, <italic>R</italic><sub><italic>I</italic></sub>).</p></sec><sec id="sec029"><title>Define completion defaults</title><p>Completion actions are automatically retrieved from specified editing operations and the property constraints of their resulting element versions (see Section 4). Additionally, the user can define completion defaults that ensure desired values of element properties after the auto-completion of a modeling activity. Referring to the previous example, when allowing two options for the association subtype, a completion default could define which subtype is used when auto-completing the activity (<xref ref-type="fig" rid="pone.0226877.g012">Fig 12</xref>, <italic>R</italic><sub><italic>II</italic></sub>).</p></sec><sec id="sec030"><title>Merge captured editing operations</title><p>In the demonstration phase, an editing operation is captured for each performed and accepted modification of a model element. If a user edits the properties of an element in a chain of subsequent edits, multiple element versions are created for a model element. For recognizing and auto-completing the modeling activity, often not all captured editing operations and element versions are required. Multiple sequentially performed modify operations on the same model element can be merged into a single editing operation and resulting element version, defining all required constraints in one place. For example, if the user demonstrates the modification of the association by two editing operations, modifying the subtype and modifying the navigability, these can be merged into a single operation as shown in <xref ref-type="fig" rid="pone.0226877.g012">Fig 12</xref>.</p></sec></sec><sec id="sec031"><title>5.4 Step 3: Generating event-processing rules</title><p>In the third processing step, a refined activity definition is transformed into event-processing rules that can be evaluated by a rule engine. This is necessary because our visual language cannot be understood by a CEP engine like Drools or Esper directly. The transformation is done in two stages. The first stage can be regarded as a preprocessing where implicit information is defined explicitly which is required for correctly working event patterns. This preprocessing is done automatically as follows.</p><sec id="sec032"><title>Type constraints</title><p>In the visual language, information about element types is captured in the label of a swim lane. In the textual representation, these type restrictions have to be specified explicitly to ensure a correct recognition of model elements. <italic>Rule 7</italic> creates a type constraint for the first existing version of each model element.</p><p><bold>Rule 7</bold>: Create model element type constraints</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>model element</italic>
<italic>e</italic></p><p specific-use="line"><bold>2</bold> &#x02003;<bold>retrieve</bold> an <italic>element version</italic>
<bold><italic>v</italic></bold>, where <italic>v</italic> is the first existing version of <italic>e</italic> (<italic>v</italic> = <italic>exist</italic>(<italic>e</italic>))</p><p specific-use="line"><bold>3</bold> &#x02003;<bold>define</bold>
<italic>a property constraint</italic> of the type (<italic>Type</italic> = <italic>type</italic>(<italic>e</italic>)) for <italic>v</italic></p></sec><sec id="sec033"><title>Connecting element versions</title><p>Element versions that refer to the same model element are grouped into a swim lane in the visual representation. This grouping requires extra effort in the textual notation. Therefore, <italic>Rule 8</italic> adds ID-equality constraints to all versions of a model element.</p><p><bold>Rule 8</bold>: Bind element versions of a model element</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>element versions</italic>
<bold><italic>v</italic></bold> of a <italic>model element</italic>
<bold><italic>e</italic></bold>
<inline-formula id="pone.0226877.e091"><alternatives><graphic xlink:href="pone.0226877.e091.jpg" id="pone.0226877.e091g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M91"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula></p><p specific-use="line"><bold>2</bold> &#x02003;<bold>retrieve</bold> an <italic>element version</italic>
<bold><italic>v</italic><sub>0</sub></bold>, where <italic>v</italic><sub>0</sub> is the first existing version of <italic>e</italic> (<italic>v</italic><sub>0</sub> = <italic>exist</italic>(<italic>e</italic>))</p><p specific-use="line"><bold>3</bold> &#x02003;<bold>forall</bold>
<italic>previous</italic> element versions <italic>w</italic> &#x02260; <italic>v</italic><sub>0</sub> of <italic>v</italic>
<bold>do</bold></p><p specific-use="line"><bold>4</bold> &#x02003;&#x02003;<bold>cretae</bold> a property constraint reference pointing from <italic>w</italic> to <italic>v</italic><sub>0</sub></p><p specific-use="line"><bold>5</bold> &#x02003;&#x02003;&#x02003;<bold>define</bold> a logical expression of the type (<italic>ID</italic> = <italic>ID</italic>) expressing the equality of the model elements: <italic>element</italic>(<italic>v</italic><sub>0</sub>) = <italic>element</italic>(<italic>w</italic>)</p></sec><sec id="sec034"><title>Preventing multi-matching</title><p>An activity may contain multiple add operations for elements of the same type, e.g., creating new classes. It is essential to ensure that the first editing operation cannot match multiple times. <italic>Rule 9</italic> adds an ID-inequality constraint requesting that the identifiers of such model elements are different.</p><p><bold>Rule 9</bold>: Differentiate model elements of the same type</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>element version</italic>
<bold><italic>v</italic></bold> resulting from <italic>editing operation</italic>
<bold><italic>o</italic></bold> on an <italic>model element</italic>
<bold><italic>e</italic></bold> of the type add: <inline-formula id="pone.0226877.e092"><alternatives><graphic xlink:href="pone.0226877.e092.jpg" id="pone.0226877.e092g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M92"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi>O</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>|</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>d</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02227;</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>e</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula></p><p specific-use="line"><bold>2</bold> &#x02003;<bold>if</bold> the value of the property constraint <italic>Type</italic> of <italic>v</italic> is equal to the value of an element version <italic>v</italic><sub><italic>j</italic></sub>: <italic>value</italic>(<italic>type</italic>(<italic>v</italic>)) = <italic>value</italic>(<italic>type</italic>(<italic>v</italic><sub><italic>j</italic></sub>)), where <italic>element</italic>(<italic>v</italic>) &#x02260; <italic>element</italic>(<italic>v</italic><sub><italic>j</italic></sub>) <bold>then</bold></p><p specific-use="line"><bold>3</bold> &#x02003;&#x02003;<bold>create</bold> a property constraint reference pointing from <italic>v</italic> to <italic>v</italic><sub><italic>j</italic></sub></p><p specific-use="line"><bold>4</bold> &#x02003;&#x02003;&#x02003;<bold>define</bold> a logical term of the type (<italic>ID</italic> &#x02260; <italic>ID</italic>) expressing the inequality of the model elements: <italic>element</italic>(<italic>v</italic>) &#x02260; <italic>element</italic>(<italic>v</italic><sub><italic>j</italic></sub>)</p><p><bold>Rule 10</bold>: Create sequence constraints to add-operations</p><p specific-use="line"><bold>1</bold>
<bold>Trigger</bold>: <italic>editing operation</italic>
<bold><italic>o</italic></bold></p><p specific-use="line"><bold>2</bold> &#x02003;<bold>retrieve</bold> all <italic>element versions</italic>
<bold><italic>v</italic></bold> of <inline-formula id="pone.0226877.e093"><alternatives><graphic xlink:href="pone.0226877.e093.jpg" id="pone.0226877.e093g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M93"><mml:mi mathvariant="script">V</mml:mi></mml:math></alternatives></inline-formula>, where type of <italic>v</italic> is <italic>Existent</italic> (<italic>type</italic>(<italic>v</italic>) = <italic>Existent</italic>)</p><p specific-use="line"><bold>3</bold> &#x02003;<bold>if</bold> the operation type of <italic>o</italic> is add <italic>type</italic>(<italic>o</italic><sub><italic>i</italic></sub>)) = <italic>add</italic>
<bold>then</bold></p><p specific-use="line"><bold>4</bold> &#x02003;&#x02003;<bold>forall</bold> element versions <italic>v</italic><sub><italic>j</italic></sub> of <italic>v</italic>
<bold>do</bold></p><p specific-use="line"><bold>5</bold> &#x02003;&#x02003;&#x02003;<bold>create</bold> a property constraint reference pointing from <italic>o</italic> to <italic>v</italic><sub><italic>j</italic></sub></p><p specific-use="line"><bold>6</bold> &#x02003;&#x02003;&#x02003;&#x02003;<bold>define</bold> a logical expression of the type (<italic>TimeStamp</italic> &#x0003e; <italic>Created</italic>) expressing that <italic>o</italic> must be performed after <italic>v</italic><sub><italic>j</italic></sub> was created</p></sec><sec id="sec035"><title>Sequence constraints</title><p>Sequence constraints are required to ensure that preexisting model elements were not created after editing operations of the activity already took place. <italic>Rule 10</italic> adds a sequence constraint between all add-operations and the preexisting elements of a modeling activity.</p><p>In the second stage, a model-to-text transformation uses the preprocessed activity definition as input for generating event-processing rules. This transformation is platform-specific and will not be discussed here. A variety of event-processing rule engines may be utilized for recognizing modeling activities.</p></sec></sec></sec><sec id="sec036"><title>6 Evaluation</title><p>We decided to perform a comparative user study of VisPaRec. As a baseline for comparison, we selected the textual language Rapide. As the benefit of by-demonstration approaches in general has been already studied by other authors [<xref rid="pone.0226877.ref025" ref-type="bibr">25</xref>], we decided to restrict our study to the evaluation of VisPaRec in comparison to Rapide.</p><p>In this user experiment, we aim to answer the following research questions:
<list list-type="simple"><list-item><label>RQ1</label><p>How well can a user comprehend VisPaRec&#x02019;s visual activity definitions in contrast to Rapide&#x02019;s textual definitions? (Comprehensibility)</p></list-item><list-item><label>RQ2</label><p>Does the use of VisPaRec result in a faster and more correct definition of modeling activities compared to Rapide&#x02019;s textual definitions? (Applicability)</p></list-item><list-item><label>RQ3</label><p>How do users judge the usability of VisPaRec in contrast to textual Rapide definitions? (Usability)</p></list-item></list></p><sec id="sec037"><title>6.1 Choice of a baseline event processing language</title><p>All above discussed event processing languages are suitable for defining modeling activities (cp. Section 2 and 4.3). Both Strelka, as well as MEdit4CEP, display a large number of model elements, even for the reduced example. This is problematic because we intend to use practically relevant refactorings for the study, which are much more extensive. Based on that we doubt that the activity definition in any of the two languages scales well in space and visual complexity. We settled for a textual language as baseline for the following reasons: First, textual languages are the more standard way to work with CEP, given that many tools like Drools and Esper do not support visual languages. Second, tasks of a moderate complexity level still fit into a manageable amount of space being roughly a standard letter size.</p><p>Considering the three presented textual languages, we found that pattern definitions are rather similar syntactically (cp. Listing 1,2, and 3). We found the most noticeable syntactical difference within the event sequencing of Esper EPL. For our presented auto-completion application, the very explicit sequencing quickly resulted in complicated nested sequencing constructs. Based on that, we argue that Esper EPL will be more difficult to deal with than the sequencing syntax of Rapide and DRL.</p><p>Besides this, their largest syntactical differences lying within language parts that are not relevant to our modeling approach. Especially DRL and Rapide were very close for the given example. As Rapide is somewhat closer to natural language than the other discussed EPLs, we considered it the easier language to explain to a user who is not a CEP expert. It is also not bound to a certain rule engine or project. We do have substantial experience in writing readable Rapide code, as we used it to formulate patterns for our auto-completion prototype, which was implemented before we designed VisPaRec. We therefore decided to compare VisPaRec with Rapide.</p></sec><sec id="sec038"><title>6.2 Experimental set-up</title><sec id="sec039"><title>Subjects</title><p>The participants comprised 16 researchers, PhD students, and masters students experienced in software engineering and knowledgeable in model-based development with UML. All of them were studying or working at the TU Ilmenau and had a computer science background. We recruited them through an email to university-wide mailing lists. Participants had 4 years of software and system development experience on average. Their self-proclaimed skill level ranged from low to very high, with an average of 2.4 on a scale from 0 to 4. The participants had much less experience with complex event processing, averaging at 0.75 years. No participant answered to have a very high skill level, and only a single participant had a high skill level in complex event processing. The study took place from April 21 to May 5, 2015. We recruited researchers and PhD students through an open call at the faculty of computer science. We also invited students attending our software engineering classes. In this way, we approached about 100 researchers and about 50 students. We required the participants to have experience in software development or complex event processing. There were no dropouts during the study. Verbal informed consent was obtained from all participants. Ethics approval was waived by the Vice President for Research of the Technical University of Ilmenau as the responsible department.</p></sec><sec id="sec040"><title>Procedure</title><p>The experiment was controlled using a computer that presented instructions and recorded times for completing tasks. The computer was configured into a kiosk mode preventing participants from leaving the experimental software. Participants&#x02019; answers were gathered on a paper-based questionnaire and in a structured debriefing interview where the interviewer recorded participants&#x02019; answers. First, participants filled-in an initial part on the questionnaire that inquired about a subject&#x02019;s experience and skill level in system and software development, model-based development, UML modeling and complex event processing. Second, each participant was asked to study the extensive tutorial on defining modeling activities textually and visually in Rapide and VisPaRec. Third, participants were given two different activity specifications, one in Rapide and one in VisPaRec, and had to answer six questions that required understanding these specifications. Fourth, each participant had to specify an activity pattern from scratch and had to refine another one. Fifth, in a structured interview we asked subjects to rate the usability of VisPaRec&#x02019;s seven definition concepts (cp. Section 4.1) in contrast to their representation in Rapide. Sixth, subjects were structurally interviewed by the experimenter about their impressions and comments regarding the visual definition language and the experiment in general. Each interview sequentially inquired about the seven concepts C1&#x02013;C7 (cp. Section 4.1) and how difficult a participant perceived their comprehension and application in both notations. We used the interview guide contained in the supplementary material. Seventh, we asked participants for general feedback and improvement ideas.</p></sec><sec id="sec041"><title>Tasks</title><p>The experiment comprised VisPaRec and Rapide definitions of four common modeling activities: &#x0201c;Extracting attribute into class&#x0201d; (also seen in <xref ref-type="fig" rid="pone.0226877.g012">Fig 12</xref>), &#x0201c;Resolving many-to-many association&#x0201d;, &#x0201c;Replacing association by interface&#x0201d;, and &#x0201c;Resolving association class&#x0201d;. These patterns describe typical model refactorings, using five up to eight different model elements to be edited zero to two times. Therefore, they generate multiple element versions related to the same model element. Participants were given seven questions and four corresponding multiple-choice statements per question and asked to check the correct statements. The questions R1&#x02013;R6 dealt with deriving the number of model elements, identifying the number of model elements existing at the start and end of the pattern, identifying and classifying the editing operations, detailing whether specific elements had certain completion actions, recognizing connections between model elements as well as understanding property constraints. These tasks aimed to establish an appropriate background knowledge of the textual as well as the visual representation before applying these notations in two tasks W1 and W2. While W1 required to construct an activity definition, W2 asked for the modification of an existing definition.</p><p>Participant&#x02019;s tasks and VisPaRec&#x02019;s main design decisions (see Section 4.1) are related as follows:
<list list-type="simple"><list-item><label>R1</label><p>is directly influenced by the swim lane concept, so is R2.</p></list-item><list-item><label>R3</label><p>asks for the type of editing operations and therefore interacts with the decision to encode the types visually.</p></list-item><list-item><label>R4</label><p>interacts with properties, sequencing, swim lanes and editing operation types.</p></list-item><list-item><label>R5</label><p>asks participants about property constraints, editing operations (default values) and swim lanes.</p></list-item><list-item><label>R6</label><p>interacts with all of the design choices, as it requires the participants to understand editing types, properties, sequencing and their life cycle.</p></list-item></list></p><p>In the same manner, the writing tasks W1 and W2 require interaction with all of the presented decisions.</p><p>In all tasks, the duration was dominated by the effort to understand and solve the problem, not by the physical actions made. This is due to the tasks being difficult but not requiring a lot of actions to complete: R1&#x02013;R4 each required the ticking of a box, R5 and R6 required to tick two boxes. W1 is the task with the most physical effort by far, requiring the participants to finish a started activity definition. One group was required to write up to 600 characters while the other group drew a small diagram of less than 20 elements as well as less than 15 connections between them. The task W2 only required correcting a given activity definition by striking and correcting the parts participants saw as incorrect. Therefore, the amount of writing work does not have a substantial influence on the duration of tasks.</p></sec><sec id="sec042"><title>Treatments and measures</title><p>The experiment had one independent variable, the definition language, and two treatments, the visual and the textual representation of an activity definition in VisPaRec and Rapide, respectively. Subjects were randomly assigned to one of two groups. The comprehension tasks (R1&#x02013;R6) always were related to a visual or a textual pattern definition. One group answered questions R1, R3 and R5 for the visual definition in VisPaRec and the other questions regarding the definition in Rapide, while the second group answered R1, R3 and R5 for the definition in Rapide and the remaining for the visual definition in VisPaRec. For the application tasks, the first group performed W1 using Rapide and W2 using VisPaRec, while the other group did W2 using VisPaRec and W1 using Rapide. The comprehensibility and applicability were measured quantitatively in terms of time to solve a task and correctness of the result. We assessed usability qualitatively within structured interviews, where participants were asked for a comparative rating of activity definition concepts on a Likert scale from 1 (very hard) to 4 (very easy).</p></sec></sec><sec id="sec043"><title>6.3 Results and discussion</title><sec id="sec044"><title>Comprehensibility (RQ1)</title><p><xref rid="pone.0226877.t002" ref-type="table">Table 2</xref> shows the results that participants achieved in the six comprehension tasks for the textual as well as the visual language. The results of a two-tailed t-test with independent samples and unequal variances are shown on the right. The upper part of the table shows the average time needed to perform the tasks, while the lower part shows the achieved correctness. The average correctness for participants working with VisPaRec was 72.0% and 60.8% for those working with Rapide. The time needed varied greatly between questions and methods. On average, comprehending VisPaRec activity patterns was 22.5% faster than comprehending their Rapide equivalent. However, there are two questions that were answered wrong more often by participants using VisPaRec than by those using Rapide (R1 and R3). These were also the questions where participants had the highest time saving using VisPaRec. We hypothesize that there is in fact a time-correctness trade off. R1 and R3 simply ask the participants to count model elements/editing operations, therefore they might have seemed misleadingly easy and participants may have jumped to a conclusion too fast. The textual description of Rapide may have forced participants to examine the activity patterns more closely, giving them more time to think about the question as a side effect. Overall, participants working with VisPaRec worked faster and more accurate on average. We suppose that the main reason for improvement is the lifeline concept, because it displays clearly which element versions belong to the same model element. This information is rather hard to grasp without lifelines, because the user must follow a chain of ID-equivalencies to group the different element versions together.</p><table-wrap id="pone.0226877.t002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.t002</object-id><label>Table 2</label><caption><title>Average time spent and correctness achieved in performing the comprehension tasks R1&#x02013;R6.</title></caption><alternatives><graphic id="pone.0226877.t002g" xlink:href="pone.0226877.t002"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="right" rowspan="1" colspan="1">Task</th><th align="center" rowspan="1" colspan="1">VisPaRec<break/>mean (&#x000b1;sd)</th><th align="center" rowspan="1" colspan="1">Rapide<break/>mean (&#x000b1;sd)</th><th align="center" rowspan="1" colspan="1">Difference Visual</th><th align="center" colspan="2" rowspan="1">Statistical test</th></tr></thead><tbody><tr><td align="left" colspan="6" rowspan="1"><bold>Time [s]</bold></td></tr><tr><td align="right" rowspan="1" colspan="1">R1</td><td align="center" rowspan="1" colspan="1">99.9 (&#x000b1; 40.3)</td><td align="center" rowspan="1" colspan="1">338.3 (&#x000b1;170.9)</td><td align="char" char="." rowspan="1" colspan="1">-70.5%</td><td align="char" char="." rowspan="1" colspan="1">0.007</td><td align="left" rowspan="1" colspan="1">**</td></tr><tr><td align="right" rowspan="1" colspan="1">R2</td><td align="center" rowspan="1" colspan="1">151.5 (&#x000b1; 95.9)</td><td align="center" rowspan="1" colspan="1">218.4 (&#x000b1;102.7)</td><td align="char" char="." rowspan="1" colspan="1">-30.6%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R3</td><td align="center" rowspan="1" colspan="1">92.6 (&#x000b1; 85.3)</td><td align="center" rowspan="1" colspan="1">213.5 (&#x000b1; 92.7)</td><td align="char" char="." rowspan="1" colspan="1">-56.6%</td><td align="char" char="." rowspan="1" colspan="1">0.023</td><td align="left" rowspan="1" colspan="1">*</td></tr><tr><td align="right" rowspan="1" colspan="1">R4</td><td align="center" rowspan="1" colspan="1">402.6 (&#x000b1;289.0)</td><td align="center" rowspan="1" colspan="1">247.1 (&#x000b1;142.9)</td><td align="char" char="." rowspan="1" colspan="1">62.9%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R5</td><td align="center" rowspan="1" colspan="1">142.8 (&#x000b1;57.8)</td><td align="center" rowspan="1" colspan="1">311.2 (&#x000b1;154.4)</td><td align="char" char="." rowspan="1" colspan="1">-54.1%</td><td align="char" char="." rowspan="1" colspan="1">0.024</td><td align="left" rowspan="1" colspan="1">*</td></tr><tr><td align="right" rowspan="1" colspan="1">R6</td><td align="center" rowspan="1" colspan="1">319.0 (&#x000b1;176.5)</td><td align="center" rowspan="1" colspan="1">229.8 (&#x000b1; 72.3)</td><td align="char" char="." rowspan="1" colspan="1">38.8%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">&#x02211;</td><td align="center" rowspan="1" colspan="1">1,208.4</td><td align="center" rowspan="1" colspan="1">1,558.3</td><td align="char" char="." rowspan="1" colspan="1">-22.5%</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" colspan="6" rowspan="1"><bold>Correctness [%]</bold></td></tr><tr><td align="right" rowspan="1" colspan="1">R1</td><td align="center" rowspan="1" colspan="1">50.0 (&#x000b1;0.50)</td><td align="center" rowspan="1" colspan="1">62.5 (&#x000b1;0.48)</td><td align="char" char="." rowspan="1" colspan="1">&#x02212;12.5%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R2</td><td align="center" rowspan="1" colspan="1">87.5 (&#x000b1;0.33)</td><td align="center" rowspan="1" colspan="1">50.0 (&#x000b1;0.50)</td><td align="char" char="." rowspan="1" colspan="1">37.5%</td><td align="char" char="." rowspan="1" colspan="1">0.124</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R3</td><td align="center" rowspan="1" colspan="1">75.0 (&#x000b1;0.43)</td><td align="center" rowspan="1" colspan="1">87.5 (&#x000b1;0.33)</td><td align="char" char="." rowspan="1" colspan="1">&#x02212;12.5%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R4</td><td align="center" rowspan="1" colspan="1">50.0 (&#x000b1;0.50)</td><td align="center" rowspan="1" colspan="1">37.5 (&#x000b1;0.48)</td><td align="char" char="." rowspan="1" colspan="1">12.5%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R5</td><td align="center" rowspan="1" colspan="1">93.8 (&#x000b1;0.17)</td><td align="center" rowspan="1" colspan="1">81.3 (&#x000b1;0.24)</td><td align="char" char="." rowspan="1" colspan="1">12.5%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="right" rowspan="1" colspan="1">R6</td><td align="center" rowspan="1" colspan="1">75.0 (&#x000b1;0.35)</td><td align="center" rowspan="1" colspan="1">45.8 (&#x000b1;0.18)</td><td align="char" char="." rowspan="1" colspan="1">29.2%</td><td align="char" char="." rowspan="1" colspan="1">0.08</td><td align="left" rowspan="1" colspan="1">*</td></tr><tr><td align="right" rowspan="1" colspan="1">Avg.</td><td align="center" rowspan="1" colspan="1">72.0</td><td align="center" rowspan="1" colspan="1">60.8</td><td align="char" char="." rowspan="1" colspan="1">11.1%</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr></tbody></table></alternatives></table-wrap></sec><sec id="sec045"><title>Applicability (RQ2)</title><p><xref rid="pone.0226877.t003" ref-type="table">Table 3</xref> shows mean, standard deviation, difference in percent, effect significance and the results of a two-tailed t-test with independent samples and unequal variances for both application tasks and notations. The upper part of the table shows the average time that participants spent on solving the task, while the lower part shows the achieved correctness. Constructing activity definitions fully manually (task W1) is not the intended use case of our visual definition language, as the demonstration step can create an initial definition (see Section 5.1). However, W1 was intended to allow for a direct comparison with the writing of definitions in Rapide. Defining the described modeling activity in VisPaRec reduced the required time significantly, on average by 43% (cp. <xref rid="pone.0226877.t003" ref-type="table">Table 3</xref>). Task W2 required participants to understand a given activity definition and to modify certain editing operations and related information. This understanding and adjusting is a common use case especially when creating definitions by example. In this task, subjects working with VisPaRec were on average 47% faster than subjects working with Rapide. These results show that the use of VisPaRec can reduce the time for defining and editing modeling activities significantly. Concerning the correctness, no significant effect could be determined. <xref rid="pone.0226877.t003" ref-type="table">Table 3</xref> shows that subjects achieved on average almost equal correctness results with both methods. A possible reason could be that all subjects where new to the definition of event patterns for recognizing modeling activities. The measured incorrectness may rather reflect a missing familiarity with the topic than a difference in the two representations. This part of the research question can only be answered properly in a more extensive long-term study.</p><table-wrap id="pone.0226877.t003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.t003</object-id><label>Table 3</label><caption><title>Average time spent and correctness achieved in performing the application tasks W1 and W2.</title></caption><alternatives><graphic id="pone.0226877.t003g" xlink:href="pone.0226877.t003"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1">Task</th><th align="center" rowspan="1" colspan="1">VisPaRec<break/>Mean (&#x000b1;sd)</th><th align="center" rowspan="1" colspan="1">Rapide<break/>Mean (&#x000b1;sd)</th><th align="center" rowspan="1" colspan="1">Difference Visual</th><th align="center" colspan="2" rowspan="1">Statistical test</th></tr></thead><tbody><tr><td align="left" colspan="6" rowspan="1"><bold>Time [s]</bold></td></tr><tr><td align="left" rowspan="1" colspan="1">W1</td><td align="center" rowspan="1" colspan="1">716.6 (&#x000b1;114.7)</td><td align="center" rowspan="1" colspan="1">1,170.9 (&#x000b1;284.7)</td><td align="center" rowspan="1" colspan="1">-43%</td><td align="char" char="." rowspan="1" colspan="1">0.0034</td><td align="left" rowspan="1" colspan="1">**</td></tr><tr><td align="left" rowspan="1" colspan="1">W2</td><td align="center" rowspan="1" colspan="1">772.7 (&#x000b1;256.7)</td><td align="center" rowspan="1" colspan="1">1,483.6 (&#x000b1;336.4)</td><td align="center" rowspan="1" colspan="1">-47%</td><td align="char" char="." rowspan="1" colspan="1">0.0015</td><td align="left" rowspan="1" colspan="1">**</td></tr><tr><td align="left" colspan="6" rowspan="1"><bold>Correctness [%]</bold></td></tr><tr><td align="left" rowspan="1" colspan="1">W1</td><td align="center" rowspan="1" colspan="1">78 (&#x000b1;0.15)</td><td align="center" rowspan="1" colspan="1">77 (&#x000b1;0.20)</td><td align="center" rowspan="1" colspan="1">1%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="left" rowspan="1" colspan="1">W2</td><td align="center" rowspan="1" colspan="1">72 (&#x000b1;0.25)</td><td align="center" rowspan="1" colspan="1">72 (&#x000b1;0.19)</td><td align="center" rowspan="1" colspan="1">0%</td><td align="char" char="." rowspan="1" colspan="1">&#x0003e;0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr></tbody></table></alternatives></table-wrap></sec><sec id="sec046"><title>Usability (RQ3)</title><p><xref rid="pone.0226877.t004" ref-type="table">Table 4</xref> aggregates users&#x02019; qualitative ratings of VisPaRec&#x02019;s seven core concepts in contrast to their representation in Rapide in terms of usability (cp. Section 4.1). The results of a two-tailed t-test with independent samples and unequal variances are shown on the right. Participants rated each concept on a Likert scale from 1 (very hard) to 4 (very easy). The visual representation of model elements (C1) significantly effects the comprehensibility (cp. <xref rid="pone.0226877.t004" ref-type="table">Table 4</xref>). Finding out what elements are comprised in a modeling activity using VisPaRec&#x02019;s representation was rated as very easy. In contrast, subjects reported that performing this task in Rapide is very hard because information about model elements must be retrieved by understanding textual constraint statements. A similar effect is visible for element versions (C2). This is understandable because comprehending the Rapide representation requires resolving references in mind to find out which versions elements undergo throughout an activity. Especially the visual grouping of evolving element versions into one element swim lane was reported as highly beneficial by most subjects. The comprehension of (C3) was reported as very easy in VisPaRec, but also as easy in Rapide. This is much less of a difference than regarding C1 und C2. We hypothesize that the reason for this finding may be that a well structured textual definition makes it easy to find the operation types &#x0201c;add&#x0201d;,&#x0201c;modify&#x0201d; and &#x0201c;delete&#x0201d;.</p><table-wrap id="pone.0226877.t004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226877.t004</object-id><label>Table 4</label><caption><title>Usability of activity definition concepts (cp. Section 4).</title></caption><alternatives><graphic id="pone.0226877.t004g" xlink:href="pone.0226877.t004"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" colspan="2" rowspan="1">Concept</th><th align="left" rowspan="1" colspan="1">VisPaRec mean<break/>(&#x000b1;sd)</th><th align="left" rowspan="1" colspan="1">Rapide mean<break/>(&#x000b1;sd)</th><th align="center" colspan="2" rowspan="1">Statistical test</th></tr></thead><tbody><tr><td align="left" rowspan="2" colspan="1">C1</td><td align="left" rowspan="2" colspan="1">Model Element</td><td align="left" rowspan="1" colspan="1"><bold>very easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>very hard</bold></td><td align="char" char="." rowspan="1" colspan="1">&#x0003c; 0.001</td><td align="left" rowspan="1" colspan="1">***</td></tr><tr><td align="left" rowspan="1" colspan="1">3.88 (&#x000b1;0.34)</td><td align="left" rowspan="1" colspan="1">1.56 (&#x000b1;0.73)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="2" colspan="1">C2</td><td align="left" rowspan="2" colspan="1">Element Version</td><td align="left" rowspan="1" colspan="1"><bold>very easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>very hard</bold></td><td align="char" char="." rowspan="1" colspan="1">&#x0003c; 0.001</td><td align="left" rowspan="1" colspan="1">***</td></tr><tr><td align="left" rowspan="1" colspan="1">3.69 (&#x000b1;0.48)</td><td align="left" rowspan="1" colspan="1">1.50 (&#x000b1;0.73)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="2" colspan="1">C3</td><td align="left" rowspan="2" colspan="1">Editing Operation</td><td align="left" rowspan="1" colspan="1"><bold>very easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>easy</bold></td><td align="char" char="." rowspan="1" colspan="1">&#x0003c; 0.001</td><td align="left" rowspan="1" colspan="1">***</td></tr><tr><td align="left" rowspan="1" colspan="1">3.88 (&#x000b1;0.34)</td><td align="left" rowspan="1" colspan="1">2.81 (&#x000b1;0.83)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="2" colspan="1">C4</td><td align="left" rowspan="2" colspan="1">Property Constraint</td><td align="left" rowspan="1" colspan="1"><bold>easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>easy</bold></td><td align="char" char="." rowspan="1" colspan="1">&#x0003e; 0.05</td><td align="left" rowspan="1" colspan="1">n.s.</td></tr><tr><td align="left" rowspan="1" colspan="1">2.97 (&#x000b1;0.78)</td><td align="left" rowspan="1" colspan="1">2.62 (&#x000b1;0.96)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="2" colspan="1">C5</td><td align="left" rowspan="2" colspan="1">Sequence Constraint</td><td align="left" rowspan="1" colspan="1"><bold>easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>hard</bold></td><td align="char" char="." rowspan="1" colspan="1">&#x0003c; 0.001</td><td align="left" rowspan="1" colspan="1">***</td></tr><tr><td align="left" rowspan="1" colspan="1">3.12 (&#x000b1;0.62)</td><td align="left" rowspan="1" colspan="1">1.81 (&#x000b1;1.05)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="2" colspan="1">C6</td><td align="left" rowspan="2" colspan="1">Completion Action</td><td align="left" rowspan="1" colspan="1"><bold>easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>hard</bold></td><td align="char" char="." rowspan="1" colspan="1">0.013</td><td align="left" rowspan="1" colspan="1">*</td></tr><tr><td align="left" rowspan="1" colspan="1">3.25 (&#x000b1;1.00)</td><td align="left" rowspan="1" colspan="1">2.31 (&#x000b1;1.01)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="2" colspan="1">C7</td><td align="left" rowspan="2" colspan="1">Completion Default</td><td align="left" rowspan="1" colspan="1"><bold>very easy</bold></td><td align="left" rowspan="1" colspan="1"><bold>hard</bold></td><td align="char" char="." rowspan="1" colspan="1">&#x0003c; 0.001</td><td align="left" rowspan="1" colspan="1">***</td></tr><tr><td align="left" rowspan="1" colspan="1">3.75 (&#x000b1;0.45)</td><td align="left" rowspan="1" colspan="1">1.94 (&#x000b1;1.06)</td><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr></tbody></table></alternatives></table-wrap><p>Nevertheless, subjects liked the clearly distinguishable visual representation of editing operations. Also not significant was the effect of VisPaRec&#x02019;s visual representation of property constraints (C4). One reason is that static property constraints are represented textually in both Rapide and VisPaRec, and thus the representations are rather similar. Another reason is the representation of dynamic constraints as connectors. Subjects liked to see what model elements are related instead of resolving textual references but struggled initially with tracing the connectors from source to target. This was reported as a question of familiarization. In addition, suggestions were made to support the usage of connectors in active editors through highlighting and out-fading on &#x0201c;mouse-over&#x0201d;. This was also mentioned for sequence constraints (C5). In contrast, subjects rated the Rapide representation of sequence constraints as hard to understand. On average, completion actions (C6) were rated to be easily comprehensible in VisPaRec, but hard to understand in Rapide. It can be seen in <xref rid="pone.0226877.t004" ref-type="table">Table 4</xref> that both ratings have a high standard deviation, meaning that subject had very different views on it. While some subjects liked to be able to automatically retrieve completion actions, reducing redundant information, the other part liked the clear overview of writing down completion actions explicitly. We believe that eliminating redundant information in an activity definition can reduce error-proneness in the long run. Completion defaults (C7) were understood very easily in VisPaRec. The visualization of completion defaults separated from property constraints was reported as very beneficial. In contrast, defining them textually within completion actions makes it hard to distinguish between conditional and default values. When we asked participants whether they prefer reading textual languages or visual languages in general, 94% of the participants preferred reading visual activity definitions, 84% of participants preferred writing visual activity definitions over textual ones. Participants also gave us valuable feedback for future iterations of the language. Most feedback referred to visual details, e.g., one participant found the orange color of time constraints rather close to the red we use for deletion operations, while another participant advised to make the arrow starting symbols more clear in favor of color blind users. Participants also envisioned VisPaRec to be supported by active editor features, like sorting swim lanes by type and collapsing swim lanes as well as element version stacks.</p></sec></sec><sec id="sec047"><title>6.4 Limitations</title><p>The experiment aimed to evaluate VisPaRec in comparison to the generic textual language Rapide for defining complex event-processing rules. We chose Rapide as a platform-independent textual definition language for the reasons elaborated in Section 6.1. While the fundamental concepts of CEP are represented across all event-processing languages, we cannot claim that our results are generalizable across all those languages, even though we do not expect substantially different results regarding different general purpose EPLs. Still, this can only be confirmed by further experiments to study other languages. Additionally, our visual language should be also compared to a textual domain specific language which is specialized for the definition of activity patterns. As we are not aware of any language specifically built for this domain, such a comparison is impossible at this time. We consider engineers, working in a model-driven software and systems development process as main audience for the proposed approach. Therefore, we requested that subjects participating in our experiment had to fit this role. All subjects had a mature level of education and at least some experience in model-driven development and UML modeling. The tasks used in the experiment were based on modeling activities commonly known from literature and often occurring in practice. However, the low number of data points does not allow to draw general conclusions. To ensure that subjects had a consistent fundamental knowledge in concepts of the experiment, we asked all subjects to work through an extensive tutorial that also included different comprehension tasks. We expect that replications of the experiment under the described conditions will offer similar results, leading to similar findings. For that purpose, we provide our material in a replication package (accessible at <ext-link ext-link-type="uri" xlink:href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z">https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi%3A10.7910%2FDVN%2FFTPF3Z</ext-link>).</p></sec></sec><sec id="sec048"><title>7 Conclusions and future work</title><p>This paper proposed a novel way to define event-processing rules for recognizing and auto-completing modeling activities during model-driven software and systems development. By using VisPaRec, event-patterns and corresponding completion actions can be graphically modeled instead of written as textual patterns. Along with this visual language, we proposed a three-step semi-automated activity definition process. This process builds upon a by-example step that provides the user with an initial activity definition to be refined. After manual refinement, required event-processing rules can then be automatically generated. A user experiment showed that participants achieved on average higher correctness in less time when asked to understand visual activity definitions and were able to define and edit activities in significantly less time (-43%, -47%) at comparable correctness. When asked about the usability of the approach, participants rated the visual activity definitions as easy to very easy to understand in contrast to the textual baseline definition language Rapide. Almost every participant (94%) preferred reading visual activity definitions over textual. Although we embed the language into a by-example approach, 81% of the participants would also prefer writing visual definitions in a solely manual manner. The approach has been implemented as an add-in to the Sparx Enterprise Architect modeling tool [<xref rid="pone.0226877.ref034" ref-type="bibr">34</xref>]. Screenshots of the definition process are part of the supplementary material. Interviews with study participants provided various ideas for additional supporting functionality in this process.</p><p>Future work will comprise the evaluation of the prototype in a larger industrial study to gain more results, especially concerning the capability of reducing error-proneness. Another interesting extension point would be an evaluation of the applicability of VisPaRec&#x02019;s main design choices to general-purpose CEP languages. The concept of special time and ordering constraints may be applicable as-is. However, the concept of swim lanes most likely needs to be generalized in order to support other attributes than object identification and to be useful in different scenarios. Regarding the activity definition by example, presumably higher accuracy can be achieved through the use of multiple demonstrations. We currently evaluate graph-based methods in order to support an arbitrarily amount of definitions and make the method more flexible. Another possibility is to implement VisPaRec as an interactive editor that could supply dynamic features, such as those desired by some participants of our study.</p></sec></body><back><ack><p>We acknowledge support for the Article Processing Charge by the German Research Foundation (DFG) and the Open Access Publication Fund of the Technische Universit&#x000e4;t Ilmenau.</p></ack><ref-list><title>References</title><ref id="pone.0226877.ref001"><label>1</label><mixed-citation publication-type="other">Foster SR, Griswold WG, Lerner S. WitchDoctor: IDE support for real-time auto-completion of refactorings. In: Software Engineering (ICSE), 2012 34th International Conference on. ICSE 2012. Piscataway, NJ, USA: IEEE Press; 2012. p. 222&#x02013;232.</mixed-citation></ref><ref id="pone.0226877.ref002"><label>2</label><mixed-citation publication-type="journal">
<name><surname>Sen</surname><given-names>S</given-names></name>, <name><surname>Baudry</surname><given-names>B</given-names></name>, <name><surname>Vangheluwe</surname><given-names>H</given-names></name>. <article-title>Towards domain-specific model editors with automatic model completion</article-title>. <source>Simulation</source>. <year>2010</year>;<volume>86</volume>(<issue>2</issue>):<fpage>109</fpage>&#x02013;<lpage>126</lpage>. <pub-id pub-id-type="doi">10.1177/0037549709340530</pub-id></mixed-citation></ref><ref id="pone.0226877.ref003"><label>3</label><mixed-citation publication-type="other">Born M, Brelage C, Markovic I, Pfeiffer D, Weber I. Auto-completion for Executable Business Process Models. In: Ardagna D, Mecella M, Yang J, editors. Business Process Management Workshops. vol. 17 of Lecture Notes in Business Information Processing. Springer Berlin Heidelberg; 2009. p. 510&#x02013;515.</mixed-citation></ref><ref id="pone.0226877.ref004"><label>4</label><mixed-citation publication-type="other">Mazanek S, Minas M. Business Process Models as a Showcase for Syntax-Based Assistance in Diagram Editors. In: Sch&#x000fc;rr A, Selic B, editors. Model Driven Engineering Languages and Systems. vol. 5795 of Lecture Notes in Computer Science. Springer; 2009. p. 322&#x02013;336.</mixed-citation></ref><ref id="pone.0226877.ref005"><label>5</label><mixed-citation publication-type="journal">
<name><surname>Koschmider</surname><given-names>A</given-names></name>, <name><surname>Hornung</surname><given-names>T</given-names></name>, <name><surname>Oberweis</surname><given-names>A</given-names></name>. <article-title>Recommendation-based editor for business process modeling</article-title>. <source>Data &#x00026; Knowledge Engineering</source>. <year>2011</year>;<volume>70</volume>(<issue>6</issue>):<fpage>483</fpage>&#x02013;<lpage>503</lpage>. <pub-id pub-id-type="doi">10.1016/j.datak.2011.02.002</pub-id></mixed-citation></ref><ref id="pone.0226877.ref006"><label>6</label><mixed-citation publication-type="book">
<name><surname>Luckham</surname><given-names>DC</given-names></name>. <source>The power of events: an introduction to complex event processing in distributed enterprise systems</source>. <publisher-name>Addison-Wesley</publisher-name>; <year>2002</year>.</mixed-citation></ref><ref id="pone.0226877.ref007"><label>7</label><mixed-citation publication-type="journal">
<name><surname>M&#x000e4;der</surname><given-names>P</given-names></name>, <name><surname>Gotel</surname><given-names>O</given-names></name>. <article-title>Towards automated traceability maintenance</article-title>. <source>Journal of Systems and Software</source>. <year>2012</year>;<volume>85</volume>(<issue>10</issue>):<fpage>2205</fpage>&#x02013;<lpage>2227</lpage>. <pub-id pub-id-type="doi">10.1016/j.jss.2011.10.023</pub-id>
<pub-id pub-id-type="pmid">23471308</pub-id></mixed-citation></ref><ref id="pone.0226877.ref008"><label>8</label><mixed-citation publication-type="other">M&#x000e4;der P, Cleland-Huang J. A visual traceability modeling language. In: International Conference on Model Driven Engineering Languages and Systems. Springer; 2010. p. 226&#x02013;240.</mixed-citation></ref><ref id="pone.0226877.ref009"><label>9</label><mixed-citation publication-type="journal">
<name><surname>M&#x000e4;der</surname><given-names>P</given-names></name>, <name><surname>Cleland-Huang</surname><given-names>J</given-names></name>. <article-title>A visual language for modeling and executing traceability queries</article-title>. <source>Software &#x00026; Systems Modeling</source>. <year>2013</year>;<volume>12</volume>(<issue>3</issue>):<fpage>537</fpage>&#x02013;<lpage>553</lpage>. <pub-id pub-id-type="doi">10.1007/s10270-012-0237-0</pub-id></mixed-citation></ref><ref id="pone.0226877.ref010"><label>10</label><mixed-citation publication-type="other">Rath M, Akehurst D, Borowski C, M&#x000e4;der P. Are graph query languages applicable for requirements traceability analysis? In: REFSQ Workshops; 2017.</mixed-citation></ref><ref id="pone.0226877.ref011"><label>11</label><mixed-citation publication-type="other">Kuschke T, M&#x000e4;der P, Rempel P. Recommending Auto-completions for Software Modeling Activities. In: Moreira A, Sch&#x000e4;tz B, Gray J, Vallecillo A, Clarke P, editors. Model-Driven Engineering Languages and Systems. vol. 8107 of Lecture Notes in Computer Science. Springer Berlin Heidelberg; 2013. p. 170&#x02013;186.</mixed-citation></ref><ref id="pone.0226877.ref012"><label>12</label><mixed-citation publication-type="other">Kuschke T, M&#x000e4;der P. Pattern-based auto-completion of UML modeling activities. In: ACM/IEEE International Conference on Automated Software Engineering, ASE '14, Vasteras, Sweden&#x02014;September 15&#x02014;19, 2014; 2014. p. 551&#x02013;556.</mixed-citation></ref><ref id="pone.0226877.ref013"><label>13</label><mixed-citation publication-type="book">
<name><surname>Kuschke</surname><given-names>T</given-names></name>. <source>Auto-completion Assistance for UML Modeling Activities</source>. <publisher-name>Technical University of Ilmenau</publisher-name>; <year>2015</year>.</mixed-citation></ref><ref id="pone.0226877.ref014"><label>14</label><mixed-citation publication-type="other">M&#x000e4;der P, Kuschke T, Janke M. Reactive Auto-completion of Modeling Activities. IEEE Transactions on Software Engineering. 2019.</mixed-citation></ref><ref id="pone.0226877.ref015"><label>15</label><mixed-citation publication-type="book">
<name><surname>Eckert</surname><given-names>M</given-names></name>, <name><surname>Bry</surname><given-names>F</given-names></name>, <name><surname>Brodt</surname><given-names>S</given-names></name>, <name><surname>Poppe</surname><given-names>O</given-names></name>, <name><surname>Hausmann</surname><given-names>S</given-names></name>. <chapter-title>A CEP babelfish: languages for Complex Event Processing and querying surveyed</chapter-title> In: <source>Reasoning in Event-Based Distributed Systems</source>. <publisher-name>Springer</publisher-name>; <year>2011</year> p. <fpage>47</fpage>&#x02013;<lpage>70</lpage>.</mixed-citation></ref><ref id="pone.0226877.ref016"><label>16</label><mixed-citation publication-type="journal">
<name><surname>Luckham</surname><given-names>DC</given-names></name>, <name><surname>Vera</surname><given-names>J</given-names></name>. <article-title>An event-based architecture definition language</article-title>. <source>IEEE transactions on Software Engineering</source>. <year>1995</year>;<volume>21</volume>(<issue>9</issue>):<fpage>717</fpage>&#x02013;<lpage>734</lpage>. <pub-id pub-id-type="doi">10.1109/32.464548</pub-id></mixed-citation></ref><ref id="pone.0226877.ref017"><label>17</label><mixed-citation publication-type="other">Luckham DC. Rapide: A Language and Toolset for Simulation of Distributed Systems by Partial Orderings of Events. 1996.</mixed-citation></ref><ref id="pone.0226877.ref018"><label>18</label><mixed-citation publication-type="other">Proctor M. Drools: a rule engine for complex event processing. In: Proceedings of the 4th international conference on Applications of Graph Transformations with Industrial Relevance. Springer-Verlag; 2011. p. 2&#x02013;2.</mixed-citation></ref><ref id="pone.0226877.ref019"><label>19</label><mixed-citation publication-type="other">Red Hat. Drools Fusion for complex event processing; 2015. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.jboss.org/drools">http://www.jboss.org/drools</ext-link>.</mixed-citation></ref><ref id="pone.0226877.ref020"><label>20</label><mixed-citation publication-type="other">EsperTech Inc. Drools Fusion for complex event processing; 2019. Available from: <ext-link ext-link-type="uri" xlink:href="http://esper.espertech.com/">http://esper.espertech.com/</ext-link>.</mixed-citation></ref><ref id="pone.0226877.ref021"><label>21</label><mixed-citation publication-type="other">NRA France. SocEDA&#x02014;CEP Editor;. Available from: <ext-link ext-link-type="uri" xlink:href="https://www.soceda.org/display/soceda/CEP+Editor">https://www.soceda.org/display/soceda/CEP+Editor</ext-link>.</mixed-citation></ref><ref id="pone.0226877.ref022"><label>22</label><mixed-citation publication-type="other">Nowak M, Bak J, Jedrzejek C. Graph-based Rule Editor. RuleML2012@ ECAI Challenge and Doctoral Consortium at the 6th International Symposium on Rules, Montpellier, France; 2012.</mixed-citation></ref><ref id="pone.0226877.ref023"><label>23</label><mixed-citation publication-type="other">REWERSE Working Group I1. Strelka&#x02014;An URML-Based Visual Rule Modeling Tool; 2008. Available from: <ext-link ext-link-type="uri" xlink:href="http://oxygen.informatik.tu-cottbus.de/rewerse-i1/?q=Strelka">http://oxygen.informatik.tu-cottbus.de/rewerse-i1/?q=Strelka</ext-link>.</mixed-citation></ref><ref id="pone.0226877.ref024"><label>24</label><mixed-citation publication-type="journal">
<name><surname>Boubeta-Puig</surname><given-names>J</given-names></name>, <name><surname>Ortiz</surname><given-names>G</given-names></name>, <name><surname>Medina-Bulo</surname><given-names>I</given-names></name>. <article-title>A model-driven approach for facilitating user-friendly design of complex event patterns</article-title>. <source>Expert Systems with Applications</source>. <year>2014</year>;<volume>41</volume>(<issue>2</issue>):<fpage>445</fpage>&#x02013;<lpage>456</lpage>. <pub-id pub-id-type="doi">10.1016/j.eswa.2013.07.070</pub-id></mixed-citation></ref><ref id="pone.0226877.ref025"><label>25</label><mixed-citation publication-type="journal">
<name><surname>Sun</surname><given-names>Y</given-names></name>, <name><surname>Gray</surname><given-names>J</given-names></name>, <name><surname>White</surname><given-names>J</given-names></name>. <article-title>A demonstration-based model transformation approach to automate model scalability</article-title>. <source>Software &#x00026; Systems Modeling</source>. <year>2013</year>; p. <fpage>1</fpage>&#x02013;<lpage>27</lpage>.</mixed-citation></ref><ref id="pone.0226877.ref026"><label>26</label><mixed-citation publication-type="journal">
<name><surname>Sun</surname><given-names>Y</given-names></name>, <name><surname>Gray</surname><given-names>J</given-names></name>, <name><surname>Langer</surname><given-names>P</given-names></name>, <name><surname>Kappel</surname><given-names>G</given-names></name>, <name><surname>Wimmer</surname><given-names>M</given-names></name>, <name><surname>White</surname><given-names>J</given-names></name>. <article-title>A WYSIWYG Approach to Support Layout Configuration in Model Evolution</article-title>. <source>Emerging Technologies for the Evolution and Maintenance of Software Models</source>. <year>2012</year>; p. <fpage>92</fpage>&#x02013;<lpage>120</lpage>. <pub-id pub-id-type="doi">10.4018/978-1-61350-438-3.ch004</pub-id></mixed-citation></ref><ref id="pone.0226877.ref027"><label>27</label><mixed-citation publication-type="other">Biermann E, Ehrig K, K ohler C, Kuhns G, T antzer G, Weiss E. Graphical Definition of In-Place Transformations in the Eclipse Modeling Framework. In: Nierstrasz O, Whittle J, Harel D, Reggio G, editors. Model Driven Engineering Languages and Systems. vol. 4199 of LNCS. Springer; 2006. p. 425&#x02013;439.</mixed-citation></ref><ref id="pone.0226877.ref028"><label>28</label><mixed-citation publication-type="other">Arendt T, Biermann E, Jurack S, Krause C, Taentzer G. Henshin: Advanced Concepts and Tools for In-Place EMF Model Transformations. In: MoDELS (1); 2010. p. 121&#x02013;135.</mixed-citation></ref><ref id="pone.0226877.ref029"><label>29</label><mixed-citation publication-type="other">Fischer T, Niere J, Torunski L, Z&#x000fc;ndorf A. Story diagrams: A new graph rewrite language based on the unified modeling language and java. In: International Workshop on Theory and Application of Graph Transformations. Springer; 1998. p. 296&#x02013;309.</mixed-citation></ref><ref id="pone.0226877.ref030"><label>30</label><mixed-citation publication-type="other">Raza M, Gulwani S, Milic-Frayling N. Programming by Example Using Least General Generalizations. In: AAAI; 2014. p. 283&#x02013;290.</mixed-citation></ref><ref id="pone.0226877.ref031"><label>31</label><mixed-citation publication-type="book">
<name><surname>Fowler</surname><given-names>M</given-names></name>. <source>Refactoring: improving the design of existing code</source>. <edition>19th ed</edition> ISBN 0-201-48567-2. <publisher-name>Addison-Wesley</publisher-name>; <year>2006</year>.</mixed-citation></ref><ref id="pone.0226877.ref032"><label>32</label><mixed-citation publication-type="journal">
<name><surname>Moody</surname><given-names>DL</given-names></name>. <article-title>The &#x0201c;Physics&#x0201d; of Notations: Toward a Scientific Basis for Constructing Visual Notations in Software Engineering</article-title>. <source>Software Engineering, IEEE Transactions on</source>. <year>2009</year>;<volume>35</volume>(<issue>6</issue>):<fpage>756</fpage>&#x02013;<lpage>779</lpage>. <pub-id pub-id-type="doi">10.1109/TSE.2009.67</pub-id></mixed-citation></ref><ref id="pone.0226877.ref033"><label>33</label><mixed-citation publication-type="other">Group SUPAV. The Stanford Rapide Project;. Available from: <ext-link ext-link-type="uri" xlink:href="http://complexevents.com/stanford/rapide/">http://complexevents.com/stanford/rapide/</ext-link>.</mixed-citation></ref><ref id="pone.0226877.ref034"><label>34</label><mixed-citation publication-type="other">Sparx Systems. Enterprise Architect: A model driven UML tool suite; 2015. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.sparxsystems.com">http://www.sparxsystems.com</ext-link>.</mixed-citation></ref></ref-list></back></article>