<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.2 20190208//EN" "JATS-archivearticle1-mathml3.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">PLoS One</journal-id><journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">plosone</journal-id><journal-title-group><journal-title>PLoS ONE</journal-title></journal-title-group><issn pub-type="epub">1932-6203</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, CA USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">31923261</article-id><article-id pub-id-type="pmc">6953776</article-id><article-id pub-id-type="publisher-id">PONE-D-19-00472</article-id><article-id pub-id-type="doi">10.1371/journal.pone.0226943</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical Sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied Mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and Analysis Methods</subject><subj-group><subject>Simulation and Modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Data Management</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Plant Science</subject><subj-group><subject>Plant Anatomy</subject><subj-group><subject>Leaves</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive Science</subject><subj-group><subject>Cognition</subject><subj-group><subject>Memory</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Learning and Memory</subject><subj-group><subject>Memory</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Data Compression</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social Sciences</subject><subj-group><subject>Economics</subject><subj-group><subject>Economic Models</subject><subj-group><subject>Cost Models</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive Science</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Language</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Language</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Language</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive Science</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Decision Making</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Decision Making</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social Sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive Psychology</subject><subj-group><subject>Decision Making</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive Science</subject><subj-group><subject>Cognition</subject><subj-group><subject>Decision Making</subject></subj-group></subj-group></subj-group></subj-group></subj-group></article-categories><title-group><article-title>Efficient processing of raster and vector data</article-title><alt-title alt-title-type="running-head">Efficient processing of raster and vector data</alt-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-1341-3368</contrib-id><name><surname>Silva-Coira</surname><given-names>Fernando</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Software</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref><xref ref-type="corresp" rid="cor001">*</xref></contrib><contrib contrib-type="author"><name><surname>Param&#x000e1;</surname><given-names>Jos&#x000e9; R.</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Ladra</surname><given-names>Susana</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><role content-type="http://credit.casrai.org/">Investigation</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>L&#x000f3;pez</surname><given-names>Juan R.</given-names></name><role content-type="http://credit.casrai.org/">Software</role><role content-type="http://credit.casrai.org/">Writing &#x02013; original draft</role><role content-type="http://credit.casrai.org/">Writing &#x02013; review &#x00026; editing</role><xref ref-type="aff" rid="aff001"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Guti&#x000e9;rrez</surname><given-names>Gilberto</given-names></name><role content-type="http://credit.casrai.org/">Conceptualization</role><xref ref-type="aff" rid="aff002"><sup>2</sup></xref></contrib></contrib-group><aff id="aff001">
<label>1</label>
<addr-line>Universidade da Coru&#x000f1;a, Centro de investigaci&#x000f3;n CITIC, Facultade de Inform&#x000e1;tica, Campus de Elvi&#x000f1;a, s/n, A Coru&#x000f1;a, Spain</addr-line>
</aff><aff id="aff002">
<label>2</label>
<addr-line>Universidad del B&#x000ed;o-B&#x000ed;o, DCCTI, Chill&#x000e1;n, Chile</addr-line>
</aff><contrib-group><contrib contrib-type="editor"><name><surname>Rao</surname><given-names>Praveen</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">
<addr-line>University of Missouri Kansas City, UNITED STATES</addr-line>
</aff><author-notes><fn fn-type="COI-statement" id="coi001"><p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p></fn><corresp id="cor001">* E-mail: <email>fernando.silva@udc.es</email></corresp></author-notes><pub-date pub-type="collection"><year>2020</year></pub-date><pub-date pub-type="epub"><day>10</day><month>1</month><year>2020</year></pub-date><volume>15</volume><issue>1</issue><elocation-id>e0226943</elocation-id><history><date date-type="received"><day>7</day><month>1</month><year>2019</year></date><date date-type="accepted"><day>10</day><month>12</month><year>2019</year></date></history><permissions><copyright-statement>&#x000a9; 2020 Silva-Coira et al</copyright-statement><copyright-year>2020</copyright-year><copyright-holder>Silva-Coira et al</copyright-holder><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="pone.0226943.pdf"/><abstract><p>In this work, we propose a framework to store and manage spatial data, which includes new efficient algorithms to perform operations accepting as input a raster dataset and a vector dataset. More concretely, we present algorithms for solving a spatial join between a raster and a vector dataset imposing a restriction on the values of the cells of the raster; and an algorithm for retrieving <italic>K</italic> objects of a vector dataset that overlap cells of a raster dataset, such that the <italic>K</italic> objects are those overlapping the highest (or lowest) cell values among all objects. The raster data is stored using a compact data structure, which can directly manipulate compressed data without the need for prior decompression. This leads to better running times and lower memory consumption. In our experimental evaluation comparing our solution to other baselines, we obtain the best space/time trade-offs.</p></abstract><funding-group><award-group id="award001"><funding-source><institution-wrap><institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100010665</institution-id><institution>H2020 Marie Sk&#x00142;odowska-Curie Actions</institution></institution-wrap></funding-source><award-id>690941</award-id></award-group><award-group id="award002"><funding-source><institution>Ministerio de Ciencia, Innovaci&#x000f3;n y Universidades (ES)</institution></funding-source><award-id>TIN2016-77158-C4-3-R</award-id></award-group><award-group id="award003"><funding-source><institution>Ministerio de Ciencia, Innovaci&#x000f3;n y Universidades (ES)</institution></funding-source><award-id>TIN2016-78011-C4-1-R</award-id></award-group><award-group id="award004"><funding-source><institution>Ministerio de Ciencia, Innovaci&#x000f3;n y Universidades (ES)</institution></funding-source><award-id>RTC-2017-5908-7</award-id><principal-award-recipient><name><surname>Ladra</surname><given-names>Susana</given-names></name></principal-award-recipient></award-group><award-group id="award005"><funding-source><institution> Conseller&#x000ed;a de Econom&#x000ed;a e Industria of the Xunta de Galicia through the GAIN (Axencia Galega de Innovaci&#x000f3;n), co-funded with ERDF</institution></funding-source><award-id>IN852A 2018/14</award-id></award-group><award-group id="award006"><funding-source><institution-wrap><institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100010801</institution-id><institution>Xunta de Galicia</institution></institution-wrap></funding-source><award-id>ED431C 2017/58</award-id></award-group><award-group id="award007"><funding-source><institution-wrap><institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100010801</institution-id><institution>Xunta de Galicia</institution></institution-wrap></funding-source><award-id>ED431G/01</award-id></award-group><award-group id="award008"><funding-source><institution>University of B&#x000ed;o-B&#x000ed;o</institution></funding-source><award-id>192119 2/R</award-id><principal-award-recipient><name><surname>Guti&#x000e9;rrez</surname><given-names>Gilberto</given-names></name></principal-award-recipient></award-group><award-group id="award009"><funding-source><institution>University of B&#x000ed;o-B&#x000ed;o</institution></funding-source><award-id>195119 GI/VC</award-id><principal-award-recipient><name><surname>Guti&#x000e9;rrez</surname><given-names>Gilberto</given-names></name></principal-award-recipient></award-group><funding-statement>This work has received funding from the European Union&#x02019;s Horizon 2020 research and innovation programme under the Marie Sk&#x00142;odowska-Curie grant agreement No 690941; from the Ministerio de Ciencia, Innovaci&#x000f3;n y Universidades (PGE and ERDF) grant numbers TIN2016-78011-C4-1-R; TIN2016-77158 C4-3-R; RTC-2017-5908-7; from Xunta de Galicia (co-founded with ERDF) grant numbers ED431C 2017/58; ED431G/01; IN852A 2018/14; and University of B&#x000ed;o-B&#x000ed;o grant numbers 192119 2/R; 195119 GI/VC.</funding-statement></funding-group><counts><fig-count count="17"/><table-count count="5"/><page-count count="35"/></counts><custom-meta-group><custom-meta id="data-availability"><meta-name>Data Availability</meta-name><meta-value>All files will be available from the following URL: <ext-link ext-link-type="uri" xlink:href="http://lbd.udc.es/research/k2-raster/">http://lbd.udc.es/research/k2-raster/</ext-link>.</meta-value></custom-meta></custom-meta-group></article-meta><notes><title>Data Availability</title><p>All files will be available from the following URL: <ext-link ext-link-type="uri" xlink:href="http://lbd.udc.es/research/k2-raster/">http://lbd.udc.es/research/k2-raster/</ext-link>.</p></notes></front><body><sec sec-type="intro" id="sec001"><title>Introduction</title><p>When dealing with spatial data, depending on the particular characteristics of the type of information, it may be more appropriate to represent that information (at the logical level) using either a raster or a vector data model [<xref rid="pone.0226943.ref001" ref-type="bibr">1</xref>]. The advance of the digital society is providing a continuous growth of the amount of available vector data, but the appearance of cheap devices equipped with GPS, like smartphones, is responsible for a big data explosion, mainly of trajectories of moving objects. The same phenomenon can be found in raster datasets, where the advances in hardware are responsible for an important increment of the size and the amount of available data. Only taking into account the images acquired by satellites, several terabytes of data are generated each day [<xref rid="pone.0226943.ref002" ref-type="bibr">2</xref>], and it has been estimated that the archived amount of raster data will soon reach the zettabyte scale [<xref rid="pone.0226943.ref003" ref-type="bibr">3</xref>].</p><p>This big increase in the variety, richness, and amount of spatial data has also led to new information demands. Nowadays, many application areas require the combination of data stored in different formats [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>] to run complex analysis. Obviously, combining different data models becomes more difficult when dealing with large amounts of data.</p><p>Although there is a large body of research regarding the size, the analysis, and the heterogeneity of data, in the case of spatial data, in most cases, that research is focused either on the vector model or on the raster model separately. The two models are rarely handled together. For instance, the usual solution for queries that involve (together) raster and vector datasets is to transform the vector dataset into a raster dataset, and then to use a raster algorithm to solve the query. This is the solution for the zonal statistics operation of Map Algebra in, at least, ArcGIS and GRASS [<xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>, <xref rid="pone.0226943.ref006" ref-type="bibr">6</xref>].</p><p>However, some previous research has addressed the problem using a joint approach. In [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>], a single data model and language is proposed to represent and query both vector and raster data at the logical level. Even a <italic>Join</italic> operator is suggested, which allows combining, transparently and interchangeably, vector datasets, raster datasets, or both. As an example, the authors propose the query &#x0201c;return the coordinates of the trajectory of an aircraft when it was over a ground with altitude over 1,000&#x0201d;. Unfortunately, no implementation details are given.</p><p>Other previous contributions deal with the implementation of query operators that are explicitly defined for querying datasets in different formats [<xref rid="pone.0226943.ref007" ref-type="bibr">7</xref>&#x02013;<xref rid="pone.0226943.ref010" ref-type="bibr">10</xref>]. Some of them tackled the Join, or a close query, but in this case, these works suffer from limitations (data structures not functional enough, too restrictive join operations, size problems) that will be explained more in detail in the next section.</p><p>On the other hand, compression has been used traditionally with the aim of just reducing the size of the datasets in disk and during network transmissions. However, it has recently begun to be used as a way to obtain improvements in other dimensions, such as processing time or scalability [<xref rid="pone.0226943.ref011" ref-type="bibr">11</xref>]. In the last few years, several authors [<xref rid="pone.0226943.ref012" ref-type="bibr">12</xref>&#x02013;<xref rid="pone.0226943.ref015" ref-type="bibr">15</xref>] have proposed the use of modern compact data structures [<xref rid="pone.0226943.ref016" ref-type="bibr">16</xref>] to represent raster datasets. Compact data structures use compression to reduce the size of the stored dataset, but with the novelty that the compressed data structure can be managed directly in compressed form, even in main memory. By saving main memory, we obtain a more scalable system, but at the same time, we take advantage of a better usage of the memory hierarchy, and thus obtain better running times. This strategy is sometimes called &#x0201c;in-memory&#x0201d; data management [<xref rid="pone.0226943.ref017" ref-type="bibr">17</xref>]. In addition, many compact data structures are equipped with an index that, in the same compressed space, speeds up the queries. This feature is known as &#x0201c;self-indexation&#x0201d;. One example of these compact data structures designed for raster data, and the one achieving the best space/time trade-offs [<xref rid="pone.0226943.ref015" ref-type="bibr">15</xref>], is the <italic>k</italic><sup>2</sup>-raster [<xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>], which will be used in this work, thus extending its functionality.</p><p>In this work, we propose to use a new framework to store and manage raster and vector datasets. The vector dataset is stored and indexed in a traditional way, using an R-tree [<xref rid="pone.0226943.ref018" ref-type="bibr">18</xref>]. For the raster data, instead, we propose to use a modern compact data structure, the <italic>k</italic><sup>2</sup>-raster, which improves the performance of traditional methods.</p><p>The algorithms to manage independently each type of data and its corresponding data structure are well-known [<xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>, <xref rid="pone.0226943.ref019" ref-type="bibr">19</xref>]. However, as explained, the algorithms to process both types of data jointly have been much less studied. Therefore, our proposal requires the design of new algorithms. In this work, we present two new algorithms that are able to efficiently answer two operations having as input a vector dataset and a raster dataset. The first one is a spatial join between the two input datasets imposing a range restriction on the values of the raster dataset. The second algorithm obtains the top-<italic>K</italic> different objects of the vector dataset overlapping the highest (or lowest) values of the raster dataset.</p><p>Our proposal obtains important savings in disk space, which are mainly due to the use of a <italic>k</italic><sup>2</sup>-raster for representing the raster data. In our experiments, the compressed raster data occupied between 9% and 73% of the disk space needed by the original uncompressed raster data. However, the main contributions of this paper are the algorithms for solving the aforementioned operations, which obtain savings also in main memory consumption and processing time. Although the <italic>k</italic><sup>2</sup>-raster was designed to be used directly in compressed form, it is not trivial to save main memory while processing it. Thus, designing these algorithms becomes challenging, as the direct management of compressed data and indexes requires complex data structures and processes, which could negatively impact the results in main memory consumption and running time.</p></sec><sec id="sec002"><title>Related work</title><p>Spatial data can describe the space using two levels of abstraction. On the conceptual level, models describe the space using two different approaches: <italic>object-based spatial models</italic> and <italic>field-based spatial models</italic> [<xref rid="pone.0226943.ref020" ref-type="bibr">20</xref>]. It is in the logical level where spatial data models are divided into <italic>vector models</italic> and <italic>raster models</italic>.</p><p>Few data models consider the possibility of jointly using the object-based and the field-based spatial models. Even international standards separate both views [<xref rid="pone.0226943.ref021" ref-type="bibr">21</xref>, <xref rid="pone.0226943.ref022" ref-type="bibr">22</xref>]. The same situation can be found at the logical level, where international standards [<xref rid="pone.0226943.ref023" ref-type="bibr">23</xref>, <xref rid="pone.0226943.ref024" ref-type="bibr">24</xref>] separate again both views and do not provide languages, data structures, or algorithms to perform queries that use information from both data models simultaneously.</p><p>Those geographical information systems that are capable of managing raster data are usually equipped with the operators of Map Algebra [<xref rid="pone.0226943.ref025" ref-type="bibr">25</xref>, <xref rid="pone.0226943.ref026" ref-type="bibr">26</xref>]. Sometimes, as in the case of ArcGIS or GRASS, they support a variation of the zonal statistics operation that, instead of receiving two input rasters, admit one vector dataset and one raster dataset. However, the vector dataset is first internally transformed into a raster dataset, such that a usual zonal statistics operation is executed over two raster datasets [<xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>, <xref rid="pone.0226943.ref006" ref-type="bibr">6</xref>].</p><p>The works in [<xref rid="pone.0226943.ref027" ref-type="bibr">27</xref>&#x02013;<xref rid="pone.0226943.ref029" ref-type="bibr">29</xref>] provided the definition of data models and query languages to manage vector and raster data, but using a different set of query operators for each type of data.</p><p>Grumbach et al. [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>] proposed a data model to represent vector and raster data with the same data abstraction. It includes spatial versions of relational model operations like <italic>Projection</italic>, <italic>Selection</italic>, and <italic>Join</italic>. These operations can manipulate vector and raster information without having to separate or distinguish the type of operands.</p><p>Brown et al. [<xref rid="pone.0226943.ref030" ref-type="bibr">30</xref>] presented a data model that represents vector and raster data with a data abstraction based on multidimensional arrays. These works present data types, storage structures, and operators to query vector and raster data, sometimes jointly, but unfortunately no details of implementation issues are provided (neither about the data structures nor the algorithms needed to support the model and the queries).</p><p>Corral et al. [<xref rid="pone.0226943.ref007" ref-type="bibr">7</xref>] presented five algorithms for processing a join between a vector dataset, indexed with an R-tree, and a raster dataset, indexed with a linear region quadtree. In [<xref rid="pone.0226943.ref008" ref-type="bibr">8</xref>], it is shown an operation between regions and moving objects that obtains the predictive overlapping between them. A linear region quadtree is used again to index the raster dataset, whereas the predictive nature of the operation requires a different index for the vector data, namely a TPR*-tree. Unfortunately, these works tackled only binary rasters, cells contain only black or white colours, and therefore they have a very limited real application.</p><p>In [<xref rid="pone.0226943.ref010" ref-type="bibr">10</xref>], it was presented the <italic>scanline</italic> method, which is an algorithm to run the zonal statistics operation between a raster and a vector datasets without any previous transformation.</p><p>Brisaboa et al. [<xref rid="pone.0226943.ref009" ref-type="bibr">9</xref>] presented a framework to store and manage vector and compressed raster data, as well as an algorithm to solve a query that, given a vector and a raster dataset, returns the elements of the vector dataset overlapping regions of the raster dataset that fulfill a range constraint. For example, having a vector dataset representing the neighbourhoods of a city and a raster storing the amount of nitrogen oxides in the air, a query could be &#x0201c;return the neighbourhoods overlapping points where the concentration of nitrogen oxide is above 0.053 ppm&#x0201d;. However, their solution does not return the exact cells of the raster fulfilling the range constraint. The vector dataset is indexed with an R-tree. The raster dataset is represented and indexed with a compact data structure called <italic>k</italic><sup>2</sup>-acc [<xref rid="pone.0226943.ref012" ref-type="bibr">12</xref>], which needs a separate tree-based data structure for each distinct value in the raster. More concretely, they use a compact data structure called <italic>k</italic><sup>2</sup>-tree [<xref rid="pone.0226943.ref031" ref-type="bibr">31</xref>] for each value. The <italic>k</italic><sup>2</sup>-tree is a space- and time- efficient version of a region quadtree [<xref rid="pone.0226943.ref032" ref-type="bibr">32</xref>&#x02013;<xref rid="pone.0226943.ref034" ref-type="bibr">34</xref>], the typical index for binary raster data. To solve the query, the algorithm just requires the <italic>k</italic><sup>2</sup>-trees representing the values at the extremes of the range and the R-tree. The search starts at the root of the three trees and then proceeds in parallel a top-down traversal over all of them, pruning the branches of the trees when possible. The <italic>k</italic><sup>2</sup>-acc has two problems. First, it works well for range queries, that is, those specifying a range of values of the raster dataset (like the nitrogen oxide example just exposed); but obtains modest response times for other queries, such as obtaining the value of a given cell. The other problem of the <italic>k</italic><sup>2</sup>-acc concerns the size of the dataset. It is a compact data structure that gives good compression rates when the number of distinct values in the dataset is low. However, when the number of different values is large, the dataset occupies much more space than its uncompressed representation [<xref rid="pone.0226943.ref013" ref-type="bibr">13</xref>, <xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>], and scales really poorly when executing most queries.</p><p>The framework proposed in this paper does not have any of these two problems of [<xref rid="pone.0226943.ref009" ref-type="bibr">9</xref>], due to the use of a <italic>k</italic><sup>2</sup>-raster to represent raster datasets. Therefore, as the <italic>k</italic><sup>2</sup>-raster works well for all types of queries, and compresses the dataset even when the number of different values in the dataset is large, the framework achieves significant savings in query time, as well as, in space, in both disk and main memory. In addition, the join operation included in our proposal differs from the one presented by Brisaboa et al., as our join algorithm also returns the cells of the raster dataset fulfilling the query constraints, that is, it is a <italic>real</italic> join.</p></sec><sec sec-type="intro" id="sec003"><title>Background</title><p>In this section, we review the main techniques that will be used as basis of our proposal, and also some baselines that will be used to evaluate its performance.</p><p>Since it is a well-know data structure, we are not going to introduce here the R-tree [<xref rid="pone.0226943.ref018" ref-type="bibr">18</xref>], but we will include a brief explanation of the <italic>k</italic><sup>2</sup>-raster, the <italic>k</italic><sup>2</sup>-treap, and NetCDF to represent raster data.</p><sec id="sec004"><title><italic>k</italic><sup>2</sup>-raster</title><p>The <italic>k</italic><sup>2</sup>-raster [<xref rid="pone.0226943.ref013" ref-type="bibr">13</xref>, <xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>] is a compact data structure for storing an integer raster matrix in compressed form and, at the same time, indexing it. It consists in a compressed representation that allows fast queries over the raster data in little space. It efficiently supports queries such as retrieving the value of a specific cell or finding all cells containing values within a given range.</p><p>The <italic>k</italic><sup>2</sup>-raster exploits the uniformity of the integer matrix to obtain compression. Following an analogous strategy to that of the <italic>k</italic><sup>2</sup>-tree [<xref rid="pone.0226943.ref031" ref-type="bibr">31</xref>], given a raster matrix and a parameter <italic>k</italic>, the <italic>k</italic><sup>2</sup>-raster recursively subdivides the matrix into <italic>k</italic> &#x000d7; <italic>k</italic> submatrices and builds a conceptual tree representing these subdivisions and the minimum and maximum values of each submatrix. The subdivision stops in case that the minimum and maximum values contained in the submatrix are equal. This conceptual <italic>k</italic><sup>2</sup>-ary tree is then compactly represented using binary bitmaps and efficient encoding schemes for integer sequences. This leads to a compressed representation of the raster matrix with efficient indexing capabilities.</p><p>More concretely, let <italic>n</italic> &#x000d7; <italic>n</italic> be the size of the input matrix, being <italic>n</italic> a power of <italic>k</italic>. To build the <italic>k</italic><sup>2</sup>-raster, it is necessary, first, to compute the minimum and maximum values of the matrix. If these values are different, they are stored in the root of a tree, and the matrix is subdivided into <italic>k</italic><sup>2</sup> submatrices of size <italic>n</italic>/<italic>k</italic> &#x000d7; <italic>n</italic>/<italic>k</italic>. Each of these submatrices generates a child node in the tree, where its minimum and maximum values are also stored. In case that these values are the same, the corresponding submatrix is not further subdivided. In case that these values are different, then this procedure continues recursively until the subdivision stops due to finding a uniform submatrix, where all the values are the same, or until no further subdivision is possible due to submatrices of size 1 &#x000d7; 1.</p><p>In case that the raster matrix is not squared or <italic>n</italic> is not power of <italic>k</italic>, the matrix can be easily expanded to the squared matrix with size the following power of <italic>k</italic>, without imposing significant extra space.</p><p><xref ref-type="fig" rid="pone.0226943.g001">Fig 1</xref> shows an example of the recursive subdivision (top) and how the conceptual tree is built (centre-top), where the minimum and maximum values of each submatrix are stored at each node. The root node corresponds to the original raster matrix, nodes at level 1 of the tree correspond to submatrices of size 4 &#x000d7; 4, and so on. The last level of the tree corresponds to cells of the original matrix. Notice, for instance, that all values of the bottom-right 4 &#x000d7; 4 submatrix are equal; thus, its minimum and maximum values are equal, and it is not further subdivided. This is the reason why the last child of the root node has no children.</p><fig id="pone.0226943.g001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g001</object-id><label>Fig 1</label><caption><title><italic>k</italic><sup>2</sup>-raster example.</title><p>Example of integer raster matrix (top), conceptual tree of the <italic>k</italic><sup>2</sup>-raster (centre-top), conceptual tree using differential encoding (centre-bottom), and final representation of the raster matrix using compact data structures (bottom). <italic>rMax</italic> and <italic>rMin</italic> denote the maximum and minimum values of the root node. <italic>Lmax</italic> and <italic>Lmin</italic> contain the maximum and minimum values of each node, following a level-wise order and using differential encoding. This example uses <italic>k</italic> = 2.</p></caption><graphic xlink:href="pone.0226943.g001"/></fig><p>To obtain a compressed representation of this conceptual tree, the <italic>k</italic><sup>2</sup>-raster uses two different approaches, one for representing the topology of the tree, and another for the maximum and minimum values stored at its nodes. On one hand, the shape of the tree is encoded using a bitmap, indicating in level-wise order whether a node has children or not. This corresponds to a simplified variant of LOUDS (<italic>level-ordered unary degree sequence</italic>) tree representation [<xref rid="pone.0226943.ref035" ref-type="bibr">35</xref>], which is a compact representation for trees. On the other hand, the maximum and minimum values are compactly encoded as the difference with respect to the maximum/minimum value stored at the parent node. These non-negative differences are stored as arrays, following the same level-wise order of the tree. The fact that the differences tend to be small is exploited using <italic>Directly Addressable Codes</italic> (DACs) [<xref rid="pone.0226943.ref036" ref-type="bibr">36</xref>], an encoding scheme for integer sequences that provides good compression and direct access to any given position. At leaf nodes of the tree, only the maximum value is stored (as the minumum is the same).</p><p>We illustrate at <xref ref-type="fig" rid="pone.0226943.g001">Fig 1</xref> the final representation of the example matrix included at the top. In the centre-bottom part of the figure, we show the tree with the differences for the maximum and minimum values, whereas the data structures that compose the final representation of the <italic>k</italic><sup>2</sup>-raster are shown at the bottom part. Hence, the original raster matrix is compactly stored using just a bitmap <italic>T</italic>, which represents the tree topology, and a series of compressed integer arrays, which contain the minimum and maximum values stored at the tree. Notice that when the raster matrix contains uniform areas, with large areas of equal or similar values, this information can be very compactly stored using differential and DACs encodings.</p><p>The <italic>k</italic><sup>2</sup>-raster not only obtains a very compressed representation of the raster matrix, but it also self-indexes the data, enabling fast queries over the raster matrix. These queries can be efficiently computed by navigating the <italic>k</italic><sup>2</sup>-raster; it is possible to simulate a top-down traversal over the conceptual tree by accessing the bitmap and the compact integer sequences in a very efficient way. In fact, some queries, such as finding cells having values within a specific range, can be answered faster with a <italic>k</italic><sup>2</sup>-raster representation than having the raster matrix in plain form, even when the <italic>k</italic><sup>2</sup>-raster requires much less memory space.</p><p>It is possible to obtain better compression and navigation efficiency by using different <italic>k</italic> values for each level. In particular, using just two values of <italic>k</italic> works well in practice. This hybrid variant will be used in the experimental evaluation. It requires three parameters: <italic>n</italic><sub>1</sub>, <italic>k</italic><sub>1</sub>, and <italic>k</italic><sub>2</sub>, which indicate that <italic>k</italic> = <italic>k</italic><sub>1</sub> for the first <italic>n</italic><sub>1</sub> levels, and then <italic>k</italic> = <italic>k</italic><sub>2</sub> for the rest.</p><p>As a summary, the <italic>k</italic><sup>2</sup>-raster joins three interesting characteristics in just one data structure: <italic>i)</italic> it <italic>compactly stores the data</italic>; <italic>ii)</italic> the tree is <italic>a spatial index</italic>, in fact it is built with the same procedure used by quadtrees, the typical index for raster datasets; and <italic>iii)</italic> the minimum and maximum values stored at the nodes of the tree <italic>index the values stored at cells</italic>. This last indexation is usually known as lightweight indexing, as it is inexpensive to offer [<xref rid="pone.0226943.ref037" ref-type="bibr">37</xref>&#x02013;<xref rid="pone.0226943.ref039" ref-type="bibr">39</xref>].</p><p>Compared to <italic>k</italic><sup>2</sup>-acc, the technique used in [<xref rid="pone.0226943.ref009" ref-type="bibr">9</xref>], the <italic>k</italic><sup>2</sup>-raster not only obtains less space consumption and query performance, but it also scales better when increasing the size of the input data or when the raster matrix contains a large number of different values.</p></sec><sec id="sec005"><title><italic>k</italic><sup>2</sup>-treap</title><p>The <italic>k</italic><sup>2</sup>-treap [<xref rid="pone.0226943.ref040" ref-type="bibr">40</xref>] is a data structure designed for answering fast top-<italic>K</italic> queries over a grid of points, where the points have weights. It conceptually combines a <italic>k</italic><sup>2</sup>-tree with a treap data structure. Thus, thanks to the <italic>k</italic><sup>2</sup>-tree properties, it obtains compact spaces for representing the grid of points; and as it follows the ideas of a treap, it allows fast ranked queries.</p><p>The <italic>k</italic><sup>2</sup>-treap shares some common strategies with the <italic>k</italic><sup>2</sup>-raster. Conceptually, it is also a <italic>k</italic><sup>2</sup>-ary tree with some extra information in the nodes. Given a grid of points with weights (an integer matrix where some of the cells may contain no data), it locates the maximum value of the grid and stores this value along with its coordinates in the root node. Then, this maximum value is removed from its position, and the grid is subdivided into <italic>k</italic> &#x000d7; <italic>k</italic> submatrices. Each submatrix is represented in the tree as a child node, and the same procedure is repeated recursively. Leaf nodes in the <italic>k</italic><sup>2</sup>-treap represent submatrices where there are no more points with weights. This <italic>k</italic><sup>2</sup>-ary tree is also represented using compact data structures, including succinct bitmaps, differential encoding and DACs. Top-<italic>K</italic> queries over the grid are solved very fast, as the maximum values are indexed in the tree.</p><p>The <italic>k</italic><sup>2</sup>-raster and <italic>k</italic><sup>2</sup>-treap structures have not been compared before, as they have been designed for representing different types of data. The <italic>k</italic><sup>2</sup>-treap can also be used for representing raster data, where the grid is full of points with weights, and to solve access queries efficiently. However, the <italic>k</italic><sup>2</sup>-raster indexes the values of the raster better, as it stores not only the maximum, but also the minimum values, thus allowing us to search for cells with values in a specific range. Space requirements would depend on the uniformity of the raster matrix, as <italic>k</italic><sup>2</sup>-rasters can compact large areas of equal values, whereas <italic>k</italic><sup>2</sup>-treaps cannot exploit that property.</p></sec><sec id="sec006"><title>NetCDF</title><p>Network Common Data Form (NetCDF) [<xref rid="pone.0226943.ref041" ref-type="bibr">41</xref>] includes the data format and software libraries to compress, access and share array-oriented scientific data. More particularly, it can also be used for compressing raster matrices and allows accessing compressed datasets transparently without performing any explicit decompression procedure. Internally, NetCDF uses Deflate [<xref rid="pone.0226943.ref042" ref-type="bibr">42</xref>], which can be configured in ten compression levels. The compressed file is divided into blocks in such a way that when a portion of the raster is required, the library has to decompress one or more of those blocks.</p><p>NetCDF and <italic>k</italic><sup>2</sup>-raster have been compared recently [<xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>]. <italic>k</italic><sup>2</sup>-raster obtains compression ratios close to those achieved by NetCDF. NetCDF is faster than <italic>k</italic><sup>2</sup>-raster when accessing large portions of the data sequentially. On the other hand, <italic>k</italic><sup>2</sup>-raster obtains better access times to individual raster cells and when solving queries specifying conditions on the values of the raster. These queries are solved orders of magnitude faster, even compared with querying uncompressed NetCDF files, thanks to the indexing capabilities of the <italic>k</italic><sup>2</sup>-raster. Moreover, these two techniques follow different approaches, as NetCDF follows a classical disk-based approach, whereas <italic>k</italic><sup>2</sup>-raster is designed to operate completely in main memory.</p></sec></sec><sec id="sec007"><title>A framework to store and process vector and raster data</title><p>In our framework, the vector datasets are stored using a traditional setup indexed with R-trees, and the raster datasets are stored and indexed using <italic>k</italic><sup>2</sup>-rasters. Next, we present two operations over that framework, which admit as input a vector dataset and a raster dataset.</p><p>Throughout the article, we will use the example of <xref ref-type="fig" rid="pone.0226943.g002">Fig 2</xref> to illustrate our explanations. The left part of the figure shows a vector dataset, and the right part shows a raster dataset. Using solid lines, the vector objects (labeled with lowercase letters) are depicted surrounded by their Minimum Bounded Rectangles (MBRs) that, for our example, are also the MBRs at the leaves of the R-tree indexing them. The MBRs surrounded by rectangles with thick and very sparse lines (<italic>M</italic><sub>1</sub>, <italic>M</italic><sub>2</sub>, and <italic>M</italic><sub>3</sub>) are the MBRs of the children of the root of the R-tree.</p><fig id="pone.0226943.g002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g002</object-id><label>Fig 2</label><caption><title>A vector dataset (left) and a raster dataset (right).</title><p>A vector dataset (left), and its MBRs, and a raster dataset (right), with the regions (quadrants) delimited by the divisions of the <italic>k</italic><sup>2</sup>-raster. For clarity, the last level of the <italic>k</italic><sup>2</sup>-raster is omitted.</p></caption><graphic xlink:href="pone.0226943.g002"/></fig><p>Regarding the raster dataset at <xref ref-type="fig" rid="pone.0226943.g002">Fig 2</xref> (right), we show its cell values in light grey. The dotted lines are the regions of the space delimited by the splitting process of the <italic>k</italic><sup>2</sup>-raster (a hybrid one, <italic>n</italic><sub>1</sub> = 2, <italic>k</italic><sub>1</sub> = 2, and <italic>k</italic><sub>2</sub> = 4). We call these regions <italic>quadrants</italic>. The thicker and densely dotted lines delimit the first level quadrants, denoted as <italic>q</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, <italic>q</italic><sub>3</sub>, and <italic>q</italic><sub>4</sub>. The thinner and sparser dotted lines delimit the second level quadrants (<italic>q</italic><sub>11</sub>, <italic>q</italic><sub>12</sub>, &#x02026;, <italic>q</italic><sub>43</sub>, <italic>q</italic><sub>44</sub>). In the raster dataset, we also draw the MBRs of the vector objects, with solid lines too, in order to easily see the overlays between the two datasets. Under the raster, we also show the conceptual <italic>k</italic><sup>2</sup>-raster without the last level, since it just includes all the cells shown in the raster.</p><sec id="sec008"><title>Basic definitions</title><p>We will use the following notation during the next sections:</p><list list-type="bullet"><list-item><p><italic>p</italic><sub><italic>r</italic></sub> denotes a pointer to an R-tree node;</p></list-item><list-item><p><italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> denotes the MBR stored at node <italic>p</italic><sub><italic>r</italic></sub>;</p></list-item><list-item><p><italic>p</italic><sub><italic>r</italic></sub>.<italic>ref</italic> denotes the list of pointers to the children of an internal node <italic>p</italic><sub><italic>r</italic></sub>, or the list of objects identifiers of a leaf node <italic>p</italic><sub><italic>r</italic></sub>;</p></list-item><list-item><p><italic>p</italic><sub><italic>k</italic></sub> denotes a pointer to a <italic>k</italic><sup>2</sup>-raster node;</p></list-item><list-item><p><italic>p</italic><sub><italic>k</italic></sub>.<italic>quad</italic> denotes the quadrant corresponding to <italic>p</italic><sub><italic>k</italic></sub>;</p></list-item><list-item><p><italic>p</italic><sub><italic>k</italic></sub>.<italic>max</italic> denotes the maximum value stored at <italic>p</italic><sub><italic>k</italic></sub>; and</p></list-item><list-item><p><italic>p</italic><sub><italic>k</italic></sub>.<italic>min</italic> denotes the minimum value stored at <italic>p</italic><sub><italic>k</italic></sub>.</p></list-item></list></sec><sec id="sec009"><title>Efficient spatial join between raster and vector datasets</title><p>In this section, we present an algorithm to compute the join between a raster and a vector dataset, imposing a range constraint on the values of the raster. Therefore, the algorithm returns the elements of a vector dataset (polygons, lines, or points) and the position of the cells of the raster dataset that overlap each other, such that the cells have values in a given range [<italic>v</italic><sub><italic>b</italic></sub>, <italic>v</italic><sub><italic>e</italic></sub>]. Formally, the query can be defined as:</p><p><bold>Definition 1</bold>. <italic>Let V be a set of vector objects, R be the set of cells of a raster, and</italic> [<italic>v</italic><sub><italic>b</italic></sub>, <italic>v</italic><sub><italic>e</italic></sub>] <italic>a range of values. For any O</italic><sub><italic>u</italic></sub> &#x02208; <italic>V and C</italic><sub><italic>w</italic></sub> &#x02208; <italic>R, let</italic>
<inline-formula id="pone.0226943.e001"><alternatives><graphic xlink:href="pone.0226943.e001.jpg" id="pone.0226943.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:msubsup><mml:mi>O</mml:mi><mml:mi>u</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>
<italic>and</italic>
<inline-formula id="pone.0226943.e002"><alternatives><graphic xlink:href="pone.0226943.e002.jpg" id="pone.0226943.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:msubsup><mml:mi>C</mml:mi><mml:mi>w</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>
<italic>be the spatial components of those elements and</italic>
<inline-formula id="pone.0226943.e003"><alternatives><graphic xlink:href="pone.0226943.e003.jpg" id="pone.0226943.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:msubsup><mml:mi>C</mml:mi><mml:mi>w</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>
<italic>the value stored at that cell. The join between the raster and the vector datasets, V</italic> &#x022c8; <italic>R</italic><sub>[<italic>v</italic><sub><italic>b</italic></sub>, <italic>v</italic><sub><italic>e</italic></sub>]</sub>, <italic>returns the set of tuples</italic>
<inline-formula id="pone.0226943.e004"><alternatives><graphic xlink:href="pone.0226943.e004.jpg" id="pone.0226943.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo>&#x02329;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mi>l</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x0232a;</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo>&#x02329;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mn>2</mml:mn><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mn>2</mml:mn><mml:mrow><mml:mi>l</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x0232a;</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo>&#x02329;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x0232a;</mml:mo></mml:mrow><mml:mo>)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
<italic>such that</italic>
<inline-formula id="pone.0226943.e005"><alternatives><graphic xlink:href="pone.0226943.e005.jpg" id="pone.0226943.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mrow><mml:msubsup><mml:mi>O</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02229;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02260;</mml:mo><mml:mi>&#x02205;</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
<italic>and</italic>
<inline-formula id="pone.0226943.e006"><alternatives><graphic xlink:href="pone.0226943.e006.jpg" id="pone.0226943.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>&#x02264;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <italic>for</italic> 1 &#x02264; <italic>i</italic> &#x02264; <italic>n</italic>, 1 &#x02264; <italic>y</italic> &#x02264; <italic>l</italic><sub><italic>i</italic></sub>.</p><p>That is, for each object of the vector dataset fulfilling the query constraints, the query returns the spatial component of the cells overlapping that object and having values in the queried range.</p><p>It is also possible to apply spatial restrictions on both datasets, that is, to restrict the join to windows or regions of the vector and the raster dataset.</p><p>In an index, handling directly the exact geometries of indexed spatial objects would require complex and slow computations, thus making the index ineffective. Thus, when a query with spatial restrictions is run on a dataset indexed using MBRs, it is performed in two steps [<xref rid="pone.0226943.ref043" ref-type="bibr">43</xref>, p.203]. The first step, usually called <italic>filter step</italic>, retrieves the objects with MBRs fulfilling the constrains of the query. This step traverses the index applying the spatial constraints to the MBRs. The output can contain MBRs that satisfy the spatial constraints, whereas the exact geometry of the objects it contains does not. Then a second step, usually called <italic>refinement step</italic>, traverses the output of the filter step using the exact geometries of the objects to test if they are actually part of the solution. This second step is costly but it is generally applied over a much smaller number of objects. For the operation tackled in this section, we focus on the filter step.</p><p>In our algorithm, in order to reduce even more the burden of the refinement step, our filtering step separates all the selected MBRs into separate lists of <italic>definitive results</italic> and <italic>probable results</italic>. Both lists include tuples formed by an object <italic>O</italic><sub><italic>i</italic></sub> and the spatial component of the cells overlapped by the leaf MBR surrounding <italic>O</italic><sub><italic>i</italic></sub> (<italic>MBR</italic><sub><italic>i</italic></sub>) that have values within the queried range.</p><list list-type="bullet"><list-item><p>For any tuple of the definitive list, it holds that <italic>all</italic> the cells overlapped by <italic>MBR</italic><sub><italic>i</italic></sub> fulfill the range criterion, and thus, it is known for sure that <italic>O</italic><sub><italic>i</italic></sub> is part of the final result (and does not need to be processed during the refinement step).</p></list-item><list-item><p>For any tuple of the probable list, it holds that only <italic>some</italic> cells overlapped by <italic>MBR</italic><sub><italic>i</italic></sub> fulfill the range criterion. Therefore, the refinement step must be applied on <italic>O</italic><sub><italic>i</italic></sub> to check if it is part of the final result.</p></list-item></list><sec id="sec010"><title>Checking the overlap</title><p>The most critical operation of the join operation is to check whether a MBR of the vector dataset overlaps a region of the raster dataset having values within the queried range. This operation should be fast to obtain good running times. Therefore, our algorithm first tries a less accurate check (<italic>checkQuadrantJ</italic>) that sometimes is enough to make a decision. When it is not, the algorithm runs a second and more precise check (<italic>checkMBR</italic>), which is obviously more expensive.</p><p><italic>checkQuadrantJ</italic>(<italic>p</italic><sub><italic>r</italic></sub>, <italic>p</italic><sub><italic>k</italic></sub>, <italic>CellsRange</italic>) receives as input a pointer <italic>p</italic><sub><italic>r</italic></sub> to an R-tree node, a pointer <italic>p</italic><sub><italic>k</italic></sub> to a <italic>k</italic><sup>2</sup>-raster node, and the range of values of the query. It outputs a pair (<italic>typeOverlapQuad</italic>, <inline-formula id="pone.0226943.e007"><alternatives><graphic xlink:href="pone.0226943.e007.jpg" id="pone.0226943.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>), where <inline-formula id="pone.0226943.e008"><alternatives><graphic xlink:href="pone.0226943.e008.jpg" id="pone.0226943.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:math></alternatives></inline-formula> is a pointer to the deepest quadrant descendant of <italic>p</italic><sub><italic>k</italic></sub>, which completely contains <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic>. The value of <italic>typeOverlapQuad</italic> depends exclusively on the raster values distribution inside the selected quadrant, and is one of the following:</p><list list-type="bullet"><list-item><p><italic>TotalOverlap</italic> indicates that all the cells within <inline-formula id="pone.0226943.e009"><alternatives><graphic xlink:href="pone.0226943.e009.jpg" id="pone.0226943.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub><mml:mo>.</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> have values in the queried range. Thus, in this case, without any further check, the algorithm determines that all the objects within <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> are part of the solution and can be included in the definitive list.</p></list-item><list-item><p><italic>PossibleOverlap</italic> indicates that <inline-formula id="pone.0226943.e010"><alternatives><graphic xlink:href="pone.0226943.e010.jpg" id="pone.0226943.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub><mml:mo>.</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> contains some cells having values within the queried range, but also some cells with values outside that range. Therefore, it is not possible to make a decision at this point of the algorithm, and thus a more thorough analysis is required.</p></list-item><list-item><p><italic>NoOverlap</italic> indicates that <inline-formula id="pone.0226943.e011"><alternatives><graphic xlink:href="pone.0226943.e011.jpg" id="pone.0226943.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub><mml:mo>.</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> contains only cells of the raster that do not have values in the queried range. Thus, in this case, the algorithm can determine without any further check that all the objects within <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> are not part of the solution, and thus, the subtree rooted at that node can be discarded.</p></list-item></list><p><italic>checkMBR</italic>(<italic>p</italic><sub><italic>r</italic></sub>, <italic>p</italic><sub><italic>k</italic></sub>,<italic>CellsRange</italic>) receives as input a pointer <italic>p</italic><sub><italic>r</italic></sub> to a leaf R-tree node, a pointer <italic>p</italic><sub><italic>k</italic></sub> to a <italic>k</italic><sup>2</sup>-raster node, and the range of values of the query. It returns only a variable <italic>typeOverlapMBR</italic> whose possible values are:</p><list list-type="bullet"><list-item><p><italic>TotalOverlap</italic> indicates that all the quadrant cells overlapping <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> have values in the queried range. Thus, this implies that all the objects within <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> and the overlapping cells do not need to go through the refinement step, and therefore, they are included in the definitive list.</p></list-item><list-item><p><italic>PartialOverlap</italic> indicates that the geometry of <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> overlaps some quadrant cells having values in the queried range, but some others that do not. Thus, this implies that the objects within <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> and the overlapping cells must go through the refinement step, and therefore, they are included in the probable list.</p></list-item><list-item><p><italic>NoOverlap</italic> indicates that the exact geometry of <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> overlaps only cells of the raster quadrant that do not have values in the queried range. Therefore, all the objects within <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> are not part of the result.</p></list-item></list><p><italic>checkQuadrantJ</italic> performs an preliminary less accurate check that, in some cases, allows the algorithm to make a decision. The key idea is that <italic>checkQuadrantJ</italic> is very fast. It starts at the node of the <italic>k</italic><sup>2</sup>-raster provided as input, and then navigates the tree downwards selecting at each node the <italic>unique</italic> child that completely contains the MBR of the R-tree node, as long as the range of values delimited by the minimum and maximum values of the <italic>k</italic><sup>2</sup>-raster node intersect the query range. The navigation stops when none of the children of the reached <italic>k</italic><sup>2</sup>-raster node completely contains the MBR of the R-tree node, or when the minimum and maximum values of the <italic>k</italic><sup>2</sup>-raster node do not intersect the query range.</p><p><italic>checkMBR</italic> is the more accurate operation. Obviously, this operation is more expensive, as it needs to navigate downwards <italic>all</italic> the children of the processed <italic>k</italic><sup>2</sup>-raster node that overlap the MBR of the R-tree node, until reaching all the cells (leaves of the <italic>k</italic><sup>2</sup>-raster) overlapping the MBR.</p><p><italic>Example: Let us take our running example at</italic>
<xref ref-type="fig" rid="pone.0226943.g002">Fig 2</xref>
<italic>to illustrate these operations. Considering as input a pointer to the R-tree node whose MBR is m</italic><sub>12</sub>, <italic>a pointer to the root node of the k</italic><sup>2</sup>-<italic>raster, and the range of cell values</italic> [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>], <italic>checkQuadrantJ starts comparing the minimum and maximum values of the root</italic> ([<xref rid="pone.0226943.ref001" ref-type="bibr">1</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]) <italic>with the queried range</italic> ([<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]). <italic>Since these ranges intersect, the navigation continues by checking if one of the children of the root of the k</italic><sup>2</sup>-<italic>raster completely contains m</italic><sub>12</sub>. <italic>This holds for q</italic><sub>2</sub>, <italic>and thus the process continues, again checking if the minimum and maximum values at that node</italic> ([<xref rid="pone.0226943.ref001" ref-type="bibr">1</xref>, <xref rid="pone.0226943.ref003" ref-type="bibr">3</xref>]) <italic>intersect the queried range</italic> ([<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]). <italic>Since this is not the case, the operation ends outputting typeOverlapQuad = NoOverlap. This is a good example to see that it is possible to conclude that the content of m</italic><sub>12</sub>
<italic>can be discarded already at the upper levels of the k</italic><sup>2</sup>-<italic>raster, in a fast way and without any further inspection of the input data</italic>.</p><p><italic>Now, let us consider checkQuadrantJ having as input the R-tree node corresponding to the leaf MBR m</italic><sub>22</sub>, <italic>the root node of the k</italic><sup>2</sup>-<italic>raster, and the queried range</italic> [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]. <italic>After checking the minimum and maximum values at the root of the k</italic><sup>2</sup>-<italic>raster, the navigation goes to q</italic><sub>3</sub>, <italic>the child that completely contains m</italic><sub>22</sub>. <italic>The maximum and minimum values at that node</italic> ([<xref rid="pone.0226943.ref001" ref-type="bibr">1</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]) <italic>intersect the query range, but they are not fully within the queried range</italic> [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]. <italic>Since no smaller quadrant of q</italic><sub>3</sub>
<italic>completely contains m</italic><sub>22</sub>, <italic>the checkQuadrantJ procedure ends outputting typeOverlapQuad = PossibleOverlap. Therefore, the algorithm has to continue performing a deeper analysis using checkMBR procedure, taking as input a pointer to the R-tree node of m</italic><sub>22</sub>
<italic>and a pointer to the k</italic><sup>2</sup>-<italic>raster node of q</italic><sub>3</sub>. <italic>Now the output is typeOverlapMBR = TotalOverlap, therefore all the objects inside m</italic><sub>22</sub>
<italic>and the overlapping cells are added to the definitive list. This example shows that even when calling checkMBR, we take advantage from using the R-tree index, avoiding any further inspection of spatial objects inside some of the MBRs</italic>.</p></sec><sec id="sec011"><title>The algorithm</title><p>Algorithm 1 shows the pseudocode of the procedure that computes the filter step of the join of Definition 1. It receives as parameters a pointer to the root node of both the R-tree and the <italic>k</italic><sup>2</sup>-raster, and the query range of values of the cells of the raster. The two lists of definitive and probable results are declared in Line 1. Line 2 defines a stack used throughout the process, which keeps the nodes of both trees to be processed.</p><p>In Lines 3&#x02013;4, for each child of the root of the R-tree, the stack is initially filled with a pair containing a pointer to that child and a pointer to the root of the <italic>k</italic><sup>2</sup>-raster. The <italic>while</italic> in Line 5 is the main loop of the algorithm, which in each iteration processes the top of the stack. As explained, it first tries a <italic>checkQuadrantJ</italic> operation. In Line 8, a <italic>TotalOverlap</italic> result allows the algorithm to make a decision and Lines 9&#x02013;12 add the affected objects and cells to the definitive list.</p><p>In case <italic>typeOverQuad</italic> is <italic>PossibleOverlap</italic>, the algorithm is forced to continue performing a deeper analysis. In Line 14, if the processed node of the R-tree is internal, the algorithm adds its children to the stack, along with a pointer to the deepest quadrant containing the node (<inline-formula id="pone.0226943.e012"><alternatives><graphic xlink:href="pone.0226943.e012.jpg" id="pone.0226943.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:math></alternatives></inline-formula>), and a new iteration of the main while starts. If the R-tree processed node is a leaf, then a <italic>checkMBR</italic> call is issued. If the answer is <italic>TotalOverlap</italic>, the objects and the overlapping cells are added to the definitive list. A <italic>PartialOverlap</italic> implies the same addition but, this time, to the probable list. In both cases, the <italic>ExtractCells</italic> method uses the <italic>k</italic><sup>2</sup>-raster to retrieve the coordinates of all the valid cells of <inline-formula id="pone.0226943.e013"><alternatives><graphic xlink:href="pone.0226943.e013.jpg" id="pone.0226943.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:math></alternatives></inline-formula> overlapping the MBR.</p><p><bold>Algorithm 1</bold>: <bold>Join</bold> (<italic>p</italic><sub><italic>rRoot</italic></sub>, <italic>p</italic><sub><italic>kRoot</italic></sub>, [<italic>v</italic><sub><italic>b</italic></sub>, <italic>v</italic><sub><italic>e</italic></sub>])</p><p specific-use="line">1 Let <italic>Def</italic> and <italic>Prob</italic> be lists of tuples of the form <inline-formula id="pone.0226943.e014"><alternatives><graphic xlink:href="pone.0226943.e014.jpg" id="pone.0226943.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo>&#x02329;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x0232a;</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> /* The lists of <italic>definitive</italic> and <italic>probable</italic> results */</p><p specific-use="line">2 Let <italic>S</italic> be a stack with pairs (<italic>p</italic><sub><italic>r</italic></sub>, <italic>p</italic><sub><italic>k</italic></sub>) /* <italic>p</italic><sub><italic>r</italic></sub> is a pointer to an R-tree node and <italic>p</italic><sub><italic>k</italic></sub> a pointer to a <italic>k</italic><sup>2</sup>-raster node */</p><p specific-use="line">3 <bold>forall</bold>
<italic>p</italic><sub><italic>rChild</italic></sub> &#x02208; <italic>p</italic><sub><italic>rRoot</italic></sub>.<italic>ref</italic>
<bold>do</bold></p><p specific-use="line">4 &#x02003;push(<italic>S</italic>, (<italic>p</italic><sub><italic>rChild</italic></sub>, <italic>p</italic><sub><italic>kRoot</italic></sub>)) /* For each child of the root node of the R-tree, insert into the stack a pair with pointers to that node and to the root of the <italic>k</italic><sup>2</sup>-raster */</p><p specific-use="line">5 <bold>end</bold></p><p specific-use="line">6 <bold>while</bold>
<italic>S</italic> &#x02260; <italic>empty</italic>
<bold>do</bold></p><p specific-use="line">7 &#x02003;(<italic>p</italic><sub><italic>r</italic></sub>, <italic>p</italic><sub><italic>k</italic></sub>)&#x02190; <italic>pop</italic>(S)</p><p specific-use="line">8 &#x02003;(<inline-formula id="pone.0226943.e015"><alternatives><graphic xlink:href="pone.0226943.e015.jpg" id="pone.0226943.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,<italic>typeOverlapQuad</italic>)&#x02190; checkQuadrantJ(<italic>p</italic><sub><italic>r</italic></sub>, <italic>p</italic><sub><italic>k</italic></sub>, [<italic>v</italic><sub><italic>b</italic></sub>, <italic>v</italic><sub><italic>e</italic></sub>])</p><p specific-use="line">9 &#x02003;<bold>if</bold>
<italic>typeOverQuad</italic> = <italic>TotalOverlap</italic>
<bold>then</bold></p><p specific-use="line">10 &#x02003;&#x02003;<bold>if</bold>
<italic>isLeafNode</italic>(<italic>p</italic><sub><italic>r</italic></sub>) <bold>then</bold></p><p specific-use="line">11 &#x02003;&#x02003;&#x02003;addResult(<italic>p</italic><sub><italic>r</italic></sub>, ExtractCells(<italic>p</italic><sub><italic>r</italic></sub>, <inline-formula id="pone.0226943.e016"><alternatives><graphic xlink:href="pone.0226943.e016.jpg" id="pone.0226943.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>), <italic>Def</italic>) /* Adds spatial objects and overlapping cells (having values in the queried range) to <italic>Def</italic> */</p><p specific-use="line">12 &#x02003;&#x02003;<bold>else</bold></p><p specific-use="line">13 &#x02003;&#x02003;&#x02003;addDescendantsLeaves (<italic>p</italic><sub><italic>r</italic></sub>.<italic>ref</italic>, <inline-formula id="pone.0226943.e017"><alternatives><graphic xlink:href="pone.0226943.e017.jpg" id="pone.0226943.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>), <italic>Def</italic>)) /* Adds spatial objects and overlapping cells in descendant leaves to <italic>Def</italic> */</p><p specific-use="line">14 &#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">15 &#x02003;<bold>else if</bold>
<italic>typeOverlapQuad</italic> = <italic>PossibleOverlap</italic>
<bold>then</bold></p><p specific-use="line">16 &#x02003;&#x02003;<bold>if</bold>
<italic>isInternalNode</italic>(<italic>p</italic><sub><italic>r</italic></sub>) <bold>then</bold></p><p specific-use="line">17 &#x02003;&#x02003;&#x02003;<bold>forall</bold>
<italic>p</italic><sub><italic>rChild</italic></sub> &#x02208; <italic>p</italic><sub><italic>r</italic></sub>.<italic>ref</italic>
<bold>then</bold></p><p specific-use="line">18 &#x02003;&#x02003;&#x02003;&#x02003;<italic>push</italic>(S, (<italic>p</italic><sub><italic>rChild</italic></sub>, <inline-formula id="pone.0226943.e018"><alternatives><graphic xlink:href="pone.0226943.e018.jpg" id="pone.0226943.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>))</p><p specific-use="line">19 &#x02003;&#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">20 &#x02003;&#x02003;<bold>else</bold></p><p specific-use="line">21 &#x02003;&#x02003;&#x02003;<italic>typeOverlapMBR</italic>&#x02190; checkMBR(<italic>p</italic><sub><italic>r</italic></sub>, <inline-formula id="pone.0226943.e019"><alternatives><graphic xlink:href="pone.0226943.e019.jpg" id="pone.0226943.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, [<italic>v<sub>b</sub></italic>, <italic>v<sub>e</sub></italic>])</p><p specific-use="line">22 &#x02003;&#x02003;&#x02003;<bold>if</bold>
<italic>typeOverlapMBR</italic> = <italic>TotalOverlap</italic>
<bold>then</bold></p><p specific-use="line">23 &#x02003;&#x02003;&#x02003;&#x02003;addResult(<italic>p</italic><sub><italic>r</italic></sub>, ExtractCells(<italic>p</italic><sub><italic>r</italic></sub>, <inline-formula id="pone.0226943.e020"><alternatives><graphic xlink:href="pone.0226943.e020.jpg" id="pone.0226943.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>), <italic>Def</italic>)</p><p specific-use="line">24 &#x02003;&#x02003;&#x02003;<bold>else if</bold>
<italic>typeOverlapMBR</italic> = <italic>PartialOverlap</italic>
<bold>then</bold></p><p specific-use="line">25 &#x02003;&#x02003;&#x02003;&#x02003;addResult(<italic>p</italic><sub><italic>r</italic></sub>, ExtractCells(<italic>p</italic><sub><italic>r</italic></sub>, <inline-formula id="pone.0226943.e021"><alternatives><graphic xlink:href="pone.0226943.e021.jpg" id="pone.0226943.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>), <italic>Prob</italic>)</p><p specific-use="line">26 &#x02003;&#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">27 &#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">28 &#x02003;<bold>end</bold></p><p specific-use="line">29 <bold>end</bold></p><p specific-use="line">30 <bold>return</bold>
<italic>(Def,Prob)</italic></p><p>As explained, the basic idea is to try to solve the query in the highest possible level of the two trees with the faster <italic>CheckQuadrantJ</italic>, and only when this is not possible, and we reach a leaf node, <italic>checkMBR</italic> is issued.</p><p><italic>Example</italic>: <italic>Using our running example and the query range</italic> [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>], <italic>we are going to illustrate the operation of the algorithm. The stack is initially filled with three pairs, each containing a pointer to the root of the k</italic><sup>2</sup>-<italic>raster and a pointer to one of the children of the root of the R-tree, that is, to the nodes corresponding to M</italic><sub>1</sub>, <italic>M</italic><sub>2</sub>, <italic>and M</italic><sub>3</sub> (<italic>see Step 1 of</italic>
<xref rid="pone.0226943.t001" ref-type="table">Table 1</xref>).</p><table-wrap id="pone.0226943.t001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.t001</object-id><label>Table 1</label><caption><title>Content of the stack during the example.</title></caption><alternatives><graphic id="pone.0226943.t001g" xlink:href="pone.0226943.t001"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1">Step</th><th align="center" rowspan="1" colspan="1">Stack (S)</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">(<italic>M</italic><sub>1</sub>, <italic>q</italic><sub><italic>root</italic></sub>), (<italic>M</italic><sub>2</sub>, <italic>q</italic><sub><italic>root</italic></sub>), (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub><italic>root</italic></sub>)</td></tr><tr><td align="left" rowspan="1" colspan="1">2</td><td align="left" rowspan="1" colspan="1">(<italic>M</italic><sub>2</sub>, <italic>q</italic><sub><italic>root</italic></sub>), (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub><italic>root</italic></sub>)</td></tr><tr><td align="left" rowspan="1" colspan="1">3</td><td align="left" rowspan="1" colspan="1">(<italic>m</italic><sub>21</sub>, <italic>q</italic><sub>3</sub>), (<italic>m</italic><sub>22</sub>, <italic>q</italic><sub>3</sub>), (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub><italic>root</italic></sub>)</td></tr><tr><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">(<italic>M</italic><sub>3</sub>, <italic>q</italic><sub><italic>root</italic></sub>)</td></tr><tr><td align="left" rowspan="1" colspan="1">5</td><td align="left" rowspan="1" colspan="1">(<italic>m</italic><sub>31</sub>, <italic>q</italic><sub>4</sub>), (<italic>m</italic><sub>32</sub>, <italic>q</italic><sub>4</sub>)</td></tr></tbody></table></alternatives></table-wrap><p><italic>First, checkQuadrantJ is called (Line 7) with the top of the stack</italic> (<italic>M</italic><sub>1</sub>, <italic>q</italic><sub><italic>root</italic></sub>), <italic>which outputs</italic> (<italic>NoOverlap</italic>, <italic>q</italic><sub>2</sub>), <italic>given that the minimum-maximum values corresponding to q</italic><sub>2</sub> ([<xref rid="pone.0226943.ref001" ref-type="bibr">1</xref>, <xref rid="pone.0226943.ref003" ref-type="bibr">3</xref>]) <italic>do not intersect</italic> [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>]. <italic>Therefore, in this case, we can see one of the best cases for our algorithm, since it prunes a whole subtree rooted at one of the children of the root of the R-tree</italic>.</p><p><italic>Then, the next top of the stack</italic>, (<italic>M</italic><sub>2</sub>, <italic>q</italic><sub><italic>root</italic></sub>), <italic>is processed. The checkQuadrantJ call returns (PossibleOverlap, q</italic><sub>3</sub>), <italic>and then, since M</italic><sub>2</sub>
<italic>is not a leaf, Line 16 adds to the stack an entry, for each of its children</italic> (<italic>m</italic><sub>21</sub>, <italic>m</italic><sub>22</sub>), <italic>with a pointer to that node and another to q</italic><sub>3</sub> (<italic>see Step 3 of</italic>
<xref rid="pone.0226943.t001" ref-type="table">Table 1</xref>).</p><p><italic>Now, the next top of the stack</italic>, (<italic>m</italic><sub>21</sub>, <italic>q</italic><sub>3</sub>), <italic>is provided as input to checkQuadrantJ, which returns</italic> (<italic>NoOverlap</italic>, <italic>q</italic><sub>32</sub>), <italic>and then, it is discarded. With</italic> (<italic>m</italic><sub>22</sub>, <italic>q</italic><sub>3</sub>), <italic>checkQuadrantJ returns</italic> (<italic>PossibleOverlap</italic>, <italic>q</italic><sub>3</sub>); <italic>observe that no child of q</italic><sub>3</sub>
<italic>completely contains m</italic><sub>22</sub>. <italic>Therefore, since m</italic><sub>22</sub>
<italic>corresponds to a leaf, now the algorithm has to issue a</italic> checkMBR <italic>call, which returns a TotalOverlap value, and thus all the objects within m</italic><sub>22</sub>
<italic>and the overlapping cells are added to the definitive list</italic>.</p><p><italic>The next top of the stack is</italic> (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub><italic>root</italic></sub>), <italic>as shown in Step 4 of</italic>
<xref rid="pone.0226943.t001" ref-type="table">Table 1</xref>. checkQuadrantJ <italic>returns</italic> (<italic>PossibleOverlap</italic>, <italic>q</italic><sub>4</sub>), <italic>and then, since M</italic><sub>3</sub>
<italic>is not a leaf, Lines 14&#x02013;16 push its children into the stack producing the result shown in Step 5</italic>.</p><p><italic>checkQuadrantJ, with</italic> (<italic>m</italic><sub>31</sub>, <italic>q</italic><sub>4</sub>) <italic>as input, outputs</italic> (<italic>PossibleOverlap</italic>, <italic>q</italic><sub>4</sub>). <italic>So, a call to checkMBR is issued, which returns a PartialOvelap, and therefore, the objects inside m</italic><sub>31</sub>
<italic>and the overlapping cells having values in</italic> [<xref rid="pone.0226943.ref004" ref-type="bibr">4</xref>, <xref rid="pone.0226943.ref005" ref-type="bibr">5</xref>] <italic>are added to the probable list. The call to checkQuadrantJ with the last stack entry</italic> (<italic>m</italic><sub>32</sub>, <italic>q</italic><sub>4</sub>) <italic>returns</italic> (<italic>TotalOverlap</italic>, <italic>q</italic><sub>44</sub>), <italic>and thus the objects within m</italic><sub>32</sub>
<italic>are added to the definitive list</italic>.</p></sec></sec><sec id="sec012"><title>Top-<italic>K</italic> algorithm</title><p>This query returns the <italic>K</italic> objects of a vector dataset that overlap cells of a raster dataset, such that the <italic>K</italic> objects are those overlapping the highest (or lowest) cell values among all objects. Formally, we can define the top-<italic>K</italic> query for the highest values as (the definition for the lowest values is analogous):</p><p><bold>Definition 2</bold>. <italic>Let V be a set of vector objects, and R be the set of cells of a raster. For any O</italic><sub><italic>u</italic></sub> &#x02208; <italic>V and C</italic><sub><italic>w</italic></sub> &#x02208; <italic>R, let</italic>
<inline-formula id="pone.0226943.e022"><alternatives><graphic xlink:href="pone.0226943.e022.jpg" id="pone.0226943.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:msubsup><mml:mi>O</mml:mi><mml:mi>u</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0226943.e023"><alternatives><graphic xlink:href="pone.0226943.e023.jpg" id="pone.0226943.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:msubsup><mml:mi>C</mml:mi><mml:mi>w</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>
<italic>be the spatial components of those elements and</italic>
<inline-formula id="pone.0226943.e024"><alternatives><graphic xlink:href="pone.0226943.e024.jpg" id="pone.0226943.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:msubsup><mml:mi>C</mml:mi><mml:mi>w</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>
<italic>be the value stored at that cell. The top-K query top</italic><sub><italic>K</italic></sub>(<italic>V</italic>, <italic>R</italic>) <italic>returns a set of K tuples</italic>
<inline-formula id="pone.0226943.e025"><alternatives><graphic xlink:href="pone.0226943.e025.jpg" id="pone.0226943.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mi>K</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <italic>such that</italic>
<inline-formula id="pone.0226943.e026"><alternatives><graphic xlink:href="pone.0226943.e026.jpg" id="pone.0226943.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mrow><mml:msubsup><mml:mi>O</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02229;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02260;</mml:mo><mml:mi>&#x02205;</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, 1 &#x02264; <italic>i</italic> &#x02264; <italic>K, and</italic>
<inline-formula id="pone.0226943.e027"><alternatives><graphic xlink:href="pone.0226943.e027.jpg" id="pone.0226943.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02265;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
<italic>for all pairs</italic> (<italic>O<sub>j</sub></italic>, <inline-formula id="pone.0226943.e028"><alternatives><graphic xlink:href="pone.0226943.e028.jpg" id="pone.0226943.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>) <italic>such that they are not part of in any tuple of top</italic><sub><italic>K</italic></sub>(<italic>V</italic>, <italic>R</italic>) <italic>and such that</italic>
<inline-formula id="pone.0226943.e029"><alternatives><graphic xlink:href="pone.0226943.e029.jpg" id="pone.0226943.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mrow><mml:msubsup><mml:mi>O</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02229;</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02260;</mml:mo><mml:mi>&#x02205;</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
<italic>and, O</italic><sub><italic>j</italic></sub> &#x02208; <italic>V and C</italic><sub><italic>j</italic></sub> &#x02208; <italic>R</italic>.</p><p>An example of this query could be: let <italic>Z</italic> be a region of the space, <italic>R</italic> a raster dataset representing daily maximum temperatures in <italic>Z</italic>, and <italic>V</italic> a vector dataset with polygons representing farms, distributed along <italic>Z</italic>. Then, a top-<italic>K</italic> query could be &#x0201c;<italic>Obtain the 10 farms in V where the highest temperatures have been registered today</italic>&#x0201d;.</p><sec id="sec013"><title>Checking the overlap</title><p>As in the previous query, the top-<italic>K</italic> algorithm uses the same basic idea of <italic>checkQuadrantJ</italic> and <italic>checkMBR</italic>, but with some modifications. For instance, the two-step separation (filtering, refining) is no longer possible in this case, as we will see; and we need new versions for the check operations.</p><p>The new <italic>checkQuadrantT</italic> receives a pointer <italic>p</italic><sub><italic>r</italic></sub> to an R-tree node and a pointer <italic>p</italic><sub><italic>k</italic></sub> to a node of the <italic>k</italic><sup>2</sup>-raster and returns a pair (<inline-formula id="pone.0226943.e030"><alternatives><graphic xlink:href="pone.0226943.e030.jpg" id="pone.0226943.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <italic>max<sub>deep</sub></italic>). The component <inline-formula id="pone.0226943.e031"><alternatives><graphic xlink:href="pone.0226943.e031.jpg" id="pone.0226943.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:math></alternatives></inline-formula> is a pointer to the deepest descendant of <italic>p</italic><sub><italic>k</italic></sub> that completely contains <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic>, and <italic>max</italic><sub><italic>deep</italic></sub> is the max value stored at <inline-formula id="pone.0226943.e032"><alternatives><graphic xlink:href="pone.0226943.e032.jpg" id="pone.0226943.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:math></alternatives></inline-formula>. Observe that <italic>max</italic><sub><italic>deep</italic></sub> is a tentative maximum value for the real maximum value in the raster area overlapped by <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic>. The more accurate check is now <italic>checkGeometry</italic>(<italic>p</italic><sub><italic>r</italic></sub>, <italic>p</italic><sub><italic>k</italic></sub>), where <italic>p</italic><sub><italic>r</italic></sub> is a leaf node. It returns a list of tuples (<italic>O<sub>i</sub></italic>, <inline-formula id="pone.0226943.e033"><alternatives><graphic xlink:href="pone.0226943.e033.jpg" id="pone.0226943.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>), with one tuple for each object in <italic>p</italic><sub><italic>r</italic></sub>.<italic>ref</italic>, and where <inline-formula id="pone.0226943.e034"><alternatives><graphic xlink:href="pone.0226943.e034.jpg" id="pone.0226943.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> is the value stored at the cells of the raster, among those overlapped by the object, that contain the maximum value.</p><p>Again, <italic>checkQuadrantT</italic> is very fast, since it only checks the max/min values of the internal nodes of the <italic>k</italic><sup>2</sup>-raster. The operation <italic>checkGeometry</italic> is more complex, because it obtains the raster portion that intersects with <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic>, and then, for each object in <italic>p</italic><sub><italic>r</italic></sub>.<italic>ref</italic>, a computational geometry algorithm is used to obtain the real maximum value overlapped by that object, and the cells having that value. Observe that the computational geometry algorithm is essential here, and can not be postponed to a later refinement step. We are not able to discard candidates based on the tentative max value identified by <italic>checkQuadranT</italic>, because it is possible that none of the objects inside <italic>p</italic><sub><italic>r</italic></sub>.<italic>MBR</italic> overlaps with any of the cells with that value.</p></sec><sec id="sec014"><title>The algorithm</title><p>Algorithm 2 shows the pseudocode of the operation top-<italic>K</italic>, for the highest values; the version for the lowest values is obtained by simply changing the max values by min values and vice-versa.</p><p>It receives, as input, pointers to the root of the R-tree and <italic>k</italic><sup>2</sup>-raster, along with the value of <italic>K</italic>. The algorithm processes both trees in parallel again. When traversing internal nodes, only when a uniform raster quadrant is processed, a decision can be taken, since it is sure that all objects within that quadrant overlap cells having the maximum/minimum value stored at the corresponding node of the <italic>k</italic><sup>2</sup>-raster.</p><p>If this is not enough to obtain <italic>K</italic> objects, the algorithm finally reaches the leaf MBRs, and processes them in an order defined by the maximum value inside the raster region which they overlap. However, it is possible that only few, or even none, of the objects within each MBR overlap the cells with that maximum value. Therefore, all those objects cannot still be added to the final result. They must be kept in a priority queue, and wait to be processed in the proper order, since the queue could still contain any pending object with a higher real maximum value, or any pending leaf MBR with a higher tentative value.</p><p>In the algorithm, the priority queue stores entries following the format (<italic>vect</italic>, <italic>p</italic><sub><italic>k</italic></sub>, <italic>max</italic>, <italic>tent</italic>). <italic>tent</italic> is a flag to indicate whether the component <italic>max</italic> is tentative or a real value. Depending on the value of this flag, the values of the rest of components are: (i) <italic>tent = true</italic>, then <italic>vect</italic> is a pointer to an R-tree node and <italic>p</italic><sub><italic>k</italic></sub> is a pointer to a <italic>k</italic><sup>2</sup>-raster node; and (ii) <italic>tent = false</italic>, then <italic>vect</italic> is an object id and <italic>p</italic><sub><italic>k</italic></sub> is a null value.</p><p>For each child of the root of the R-tree, Lines 3&#x02013;5 add to the priority queue a pointer to that child, a pointer to the deepest node of the <italic>k</italic><sup>2</sup>-raster that completely contains the MBR of that child, and the maximum value at that <italic>k</italic><sup>2</sup>-raster node, and thus, the <italic>tent</italic> flag is set to <italic>true</italic>.</p><p>The iteration of the <italic>while</italic> loop in Line 6 starts by checking the <italic>tent</italic> component of the head of the queue. If it is <italic>false</italic> (Lines 9&#x02013;10), then the algorithm extracts the head of the queue and its values are added to the result. Observe that a non tentative value means that the <italic>vect</italic> component is the id of an object, whose exact geometry had been already checked before by the <italic>checkGeometry</italic> procedure.</p><p>If the <italic>tent</italic> value is <italic>true</italic>, then the algorithm checks if the pointer to the <italic>k</italic><sup>2</sup>-raster node points to a uniform area (the maximum and minimum values at the node are equal) in Line 13. In such a case, without checking the exact geometry of the objects at the leaves of the subtree rooted at <italic>p</italic><sub><italic>rq</italic></sub>, it is sure that those objects overlap cells with the retrieved <italic>max</italic><sub><italic>q</italic></sub> value, and thus they are added to the result (up to <italic>K</italic> entries) with the procedure <italic>addDescendantsLeaves</italic>, which traverses the R-tree downwards to retrieve them.</p><p>If the quadrant is not uniform, the algorithm checks if the pointer to the R-tree is a leaf or not (Line 15). If it is a leaf, since the max value obtained from the queue was tentative, the algorithm performs a call to <italic>checkGeometry</italic>. That call returns a list of tuples (<italic>O</italic><sub><italic>i</italic></sub>, <inline-formula id="pone.0226943.e035"><alternatives><graphic xlink:href="pone.0226943.e035.jpg" id="pone.0226943.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>), with one tuple for each polygon in the R-tree leaf. For each of those tuples, if the real maximum is equal to the tentative maximum value (Line 18), then that object is added to the response. If it is lower (Line 23), then it is added back to the priority queue, but now with the format (<italic>O</italic><sub><italic>i</italic></sub>, <italic>null</italic>, <inline-formula id="pone.0226943.e036"><alternatives><graphic xlink:href="pone.0226943.e036.jpg" id="pone.0226943.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <italic>false</italic>). If the pointer to the R-tree is not a leaf (Line 25), the algorithm adds to the priority queue each of the children, along with the deepest quadrant that completely contains it, along with its tentative maximum value.</p><p><bold>Algorithm 2: Top-<italic>K</italic></bold> (<italic>p</italic><sub><italic>rRoot</italic></sub>, <italic>p</italic><sub><italic>kRoot</italic></sub>, <italic>K</italic>)</p><p specific-use="line">1 Let <italic>T and L</italic> be lists of elements (<italic>O</italic><sub><italic>u</italic></sub>, <inline-formula id="pone.0226943.e037"><alternatives><graphic xlink:href="pone.0226943.e037.jpg" id="pone.0226943.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>) /* T holds the output of the algorithm and L is a auxiliary list. */</p><p specific-use="line">2 Let <italic>Q</italic> be a priority queue with entries (<italic>vect</italic>, <italic>p</italic><sub><italic>k</italic></sub>, <italic>max</italic>, <italic>tent</italic>)</p><p specific-use="line">3 <bold>forall</bold>
<italic>p</italic><sub><italic>rRef</italic></sub> &#x02208; <italic>p</italic><sub><italic>rRoot</italic></sub>.<italic>ref</italic>
<bold>do</bold></p><p specific-use="line">4 &#x02003;(<italic>max<sub>deep</sub></italic>, <inline-formula id="pone.0226943.e038"><alternatives><graphic xlink:href="pone.0226943.e038.jpg" id="pone.0226943.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>) &#x02190; checkQuadrantT(<italic>p</italic><sub><italic>rRef</italic></sub>,<italic>p</italic><sub><italic>kRoot</italic></sub>) insert(<italic>Q</italic>, (<italic>p<sub>rRef</sub></italic>, <inline-formula id="pone.0226943.e039"><alternatives><graphic xlink:href="pone.0226943.e039.jpg" id="pone.0226943.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <italic>max<sub>deep</sub></italic>, <italic>true</italic>))/* Inserts in the priority queue each child of the root node of the R-tree */</p><p specific-use="line">5 <bold>end</bold></p><p specific-use="line">6 <bold>while</bold>
<italic>Q</italic> &#x02260; <italic>empty</italic> and <italic>sizeOf(T)</italic>&#x0003c;<italic>K</italic>
<bold>do</bold></p><p specific-use="line">7 &#x02003;<italic>tent</italic> &#x02190; <italic>tent</italic>(<italic>head</italic>(<italic>Q</italic>)) /* Obtains the <italic>tent</italic> flag of the head of the queue */</p><p specific-use="line">8 &#x02003;<bold>if</bold> tent = false <bold>then</bold></p><p specific-use="line">9 &#x02003;&#x02003;(<italic>O</italic><sub><italic>q</italic></sub>, <italic>null</italic>, <italic>max</italic><sub><italic>q</italic></sub>, <italic>tent</italic>)&#x02190; <italic>head</italic>(Q) /* Extracts the head of the queue */</p><p specific-use="line">10 &#x02003;&#x02003;add(T, (<italic>O</italic><sub><italic>q</italic></sub>, <italic>max</italic><sub><italic>q</italic></sub>)) /* The max value at the priority queue is real, add to the result */</p><p specific-use="line">11 &#x02003;<bold>else</bold></p><p specific-use="line">12 &#x02003;&#x02003;(<italic>p</italic><sub><italic>rq</italic></sub>, <italic>p</italic><sub><italic>kq</italic></sub>, <italic>max</italic><sub><italic>q</italic></sub>, <italic>tent</italic>)&#x02190; <italic>head</italic>(Q)</p><p specific-use="line">13 &#x02003;&#x02003;<bold>if</bold>
<italic>p</italic><sub><italic>kq</italic></sub>.<italic>min</italic> = <italic>p</italic><sub><italic>kq</italic></sub>.<italic>max</italic>
<bold>then</bold></p><p specific-use="line">14 &#x02003;&#x02003;&#x02003;<italic>addDescendantsLeaves</italic>(<italic>T</italic>, <italic>p</italic><sub><italic>rq</italic></sub>, <italic>p</italic><sub><italic>kq</italic></sub>, <italic>max</italic><sub><italic>q</italic></sub>)/* A uniform quadrant, all descendants can be added to the result */</p><p specific-use="line">15 &#x02003;&#x02003;<bold>else if</bold>
<italic>isLeafNode</italic>(<italic>p</italic><sub><italic>rq</italic></sub>) <bold>then</bold></p><p specific-use="line">16 &#x02003;&#x02003;&#x02003;<italic>L</italic>&#x02190; checkGeometry(<italic>p</italic><sub><italic>rq</italic></sub>, <italic>p</italic><sub><italic>kq</italic></sub>) /* Obtains a list of tuples */</p><p specific-use="line">17 &#x02003;&#x02003;&#x02003;<bold>forall</bold>
<inline-formula id="pone.0226943.e040"><alternatives><graphic xlink:href="pone.0226943.e040.jpg" id="pone.0226943.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mo>&#x02208;</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
<bold>do</bold></p><p specific-use="line">18 &#x02003;&#x02003;&#x02003;&#x02003;<bold>if</bold>
<inline-formula id="pone.0226943.e041"><alternatives><graphic xlink:href="pone.0226943.e041.jpg" id="pone.0226943.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
<bold>then</bold></p><p specific-use="line">19 &#x02003;&#x02003;&#x02003;&#x02003;&#x02003;add(T, (<italic>O</italic><sub><italic>i</italic></sub>, <italic>max</italic><sub><italic>q</italic></sub>)) /* The real value is equal to the tentative, then add to the output */</p><p specific-use="line">20 &#x02003;&#x02003;&#x02003;&#x02003;&#x02003;<bold>if</bold>
<italic>sizeOf(T) = K</italic>
<bold>then</bold> break;</p><p specific-use="line">21 &#x02003;&#x02003;&#x02003;&#x02003;<bold>else</bold></p><p specific-use="line">22 &#x02003;&#x02003;&#x02003;&#x02003;&#x02003;insert(<italic>Q</italic>, (<italic>O<sub>i</sub></italic>, <italic>null</italic>, <inline-formula id="pone.0226943.e042"><alternatives><graphic xlink:href="pone.0226943.e042.jpg" id="pone.0226943.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <italic>false</italic>)) /* The real max is smaller than the tentative one; the object is inserted in the queue */</p><p specific-use="line">23 &#x02003;&#x02003;&#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">24 &#x02003;&#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">25 &#x02003;&#x02003;<bold>else</bold></p><p specific-use="line">26 &#x02003;&#x02003;&#x02003;<bold>forall</bold>
<italic>p</italic><sub><italic>rRef</italic></sub> &#x02208; <italic>p</italic><sub><italic>rq</italic></sub>.<italic>ref</italic>
<bold>do</bold></p><p specific-use="line">27 &#x02003;&#x02003;&#x02003;&#x02003;(<italic>max</italic><sub><italic>deep</italic></sub>, <inline-formula id="pone.0226943.e043"><alternatives><graphic xlink:href="pone.0226943.e043.jpg" id="pone.0226943.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>) &#x02190; checkQuadrantT(<italic>p</italic><sub><italic>rRef</italic></sub>, <italic>p</italic><sub><italic>kq</italic></sub>)/* It descends one level of the R-tree, and adapts the nodes of the <italic>k</italic><sup>2</sup>-raster accordingly */ insert(Q, (<italic>p</italic><sub><italic>rRef</italic></sub>, <inline-formula id="pone.0226943.e044"><alternatives><graphic xlink:href="pone.0226943.e044.jpg" id="pone.0226943.e044g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M44"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <italic>max</italic><sub><italic>deep</italic></sub>, <italic>true</italic>))</p><p specific-use="line">28 &#x02003;&#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">29 &#x02003;&#x02003;<bold>end</bold></p><p specific-use="line">30 &#x02003;<bold>end</bold></p><p specific-use="line">31 <bold>end</bold></p><p specific-use="line">32 <bold>return</bold>
<italic>T</italic></p><p><italic>Example</italic>: <italic>Let us illustrate the algorithm computing a top-1 query over the example of</italic>
<xref ref-type="fig" rid="pone.0226943.g002">Fig 2</xref>. <italic>Lines 3&#x02013;5 add each child of the root of the R-tree to the priority queue. The first row of</italic>
<xref rid="pone.0226943.t002" ref-type="table">Table 2</xref>
<italic>shows the queue content after this first step</italic>.</p><table-wrap id="pone.0226943.t002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.t002</object-id><label>Table 2</label><caption><title>Content of the priority queue during the computation of a <italic>top-1</italic> query over the example.</title></caption><alternatives><graphic id="pone.0226943.t002g" xlink:href="pone.0226943.t002"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1">Step</th><th align="center" rowspan="1" colspan="1">Priority queue (Q)</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">(<italic>M</italic><sub>2</sub>, <italic>q</italic><sub>3</sub>, 5, <italic>true</italic>), (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub>4</sub>, 5, <italic>true</italic>), (<italic>M</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, 3, <italic>true</italic>)</td></tr><tr><td align="left" rowspan="1" colspan="1">2</td><td align="left" rowspan="1" colspan="1">(<italic>m</italic><sub>22</sub>, <italic>q</italic><sub>3</sub>, 5, <italic>true</italic>), (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub>4</sub>, 5, <italic>true</italic>), (<italic>m</italic><sub>21</sub>, <italic>q</italic><sub>32</sub>, 3, <italic>true</italic>), (<italic>M</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, 3, <italic>true</italic>)</td></tr><tr><td align="left" rowspan="1" colspan="1">3</td><td align="left" rowspan="1" colspan="1">(<italic>M</italic><sub>3</sub>, <italic>q</italic><sub>4</sub>, 5, <italic>true</italic>), (<italic>d</italic>, <italic>null</italic>, 4, <italic>false</italic>), (<italic>m</italic><sub>21</sub>, <italic>q</italic><sub>32</sub>, 3, <italic>true</italic>), (<italic>M</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, 3, <italic>true</italic>)</td></tr><tr><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">(<italic>m</italic><sub>31</sub>, <italic>q</italic><sub>4</sub>, 5, <italic>true</italic>), (<italic>m</italic><sub>32</sub>, <italic>q</italic><sub>44</sub>, 5, <italic>true</italic>), (<italic>d</italic>, <italic>null</italic>, 4, <italic>false</italic>), (<italic>m</italic><sub>21</sub>, <italic>q</italic><sub>32</sub>, 3, <italic>true</italic>), (<italic>M</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, 3, <italic>true</italic>)</td></tr><tr><td align="left" rowspan="1" colspan="1">5</td><td align="left" rowspan="1" colspan="1">(<italic>m</italic><sub>32</sub>, <italic>q</italic><sub>44</sub>, 5, <italic>true</italic>), (<italic>d</italic>, <italic>null</italic>, 4, <italic>false</italic>), (<italic>e</italic>, <italic>null</italic>, 3, <italic>false</italic>), (<italic>m</italic><sub>21</sub>, <italic>q</italic><sub>32</sub>, 3, <italic>true</italic>), (<italic>M</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, 3, <italic>true</italic>)</td></tr></tbody></table></alternatives></table-wrap><p><italic>Line 7 obtains the tent value of the head, and since it is true, Line 12 extracts the head</italic> (<italic>M</italic><sub>2</sub>, <italic>q</italic><sub>3</sub>, 5, <italic>true</italic>); <italic>since q</italic><sub>3</sub>
<italic>is not uniform (the maximum and minimum values of q</italic><sub>3</sub>
<italic>are different), and M</italic><sub>2</sub>
<italic>is not a leaf, the flow reaches Line 25 and then, the children of M</italic><sub>2</sub>
<italic>are added to the queue (see Step 2). Observe that, for each child, a call to checkQuadrantT provides the deepest quadrant that completely contains that child and the maximum value at that quadrant</italic>.</p><p><italic>In the next iteration of the while loop, given that the head</italic> (<italic>m</italic><sub>22</sub>, <italic>q</italic><sub>3</sub>, 5, <italic>true</italic>) <italic>has a tentative maximum, q</italic><sub>3</sub>
<italic>is not uniform, and m</italic><sub>22</sub>
<italic>is a leaf, then the flow reaches Line 16 and checkGeometry</italic>(<italic>m</italic><sub>22</sub>, <italic>q</italic><sub>3</sub>) <italic>is issued. The response is</italic> (<italic>d</italic>, 4), <italic>and thus, the for loop of Line 17 only checks that entry; and since the real maximum is smaller than the tentative one (Line 18), the tuple</italic> (<italic>d</italic>, <italic>null</italic>, 4, <italic>false</italic>) <italic>is added to the queue in Line 23 (see Step 3). Observe that, with a tentative maximum value of 5, which is greater than 4, M</italic><sub>3</sub>
<italic>is still waiting in the queue, since it could contain objects overlapping cells with value 5, that would be added to the final result before d</italic>.</p><p><italic>In fact, the next iteration processes</italic> (<italic>M</italic><sub>3</sub>, <italic>q</italic><sub>4</sub>, 5, <italic>true</italic>). <italic>Since tent is true, q</italic><sub>4</sub>
<italic>is not uniform, and M</italic><sub>3</sub>
<italic>is not a leaf, the flow reaches Line 26, and then the children of M</italic><sub>3</sub>
<italic>are added to the queue (Step 4)</italic>.</p><p><italic>The next dequeued head</italic> (<italic>m</italic><sub>31</sub>, <italic>q</italic><sub>4</sub>, 5, <italic>true</italic>) <italic>produces a call to checkGeometry that returns a real maximum value (3) smaller than the tentative one, and thus</italic> (<italic>e</italic>, <italic>null</italic>, 3, <italic>false</italic>) <italic>is added to the queue (see Step 5)</italic>.</p><p><italic>Finally, the next iteration processes</italic> (<italic>m</italic><sub>32</sub>, <italic>q</italic><sub>44</sub>, 5, <italic>true</italic>). <italic>After dequeuing it, since tent is true, Line 14 checks the maximum and minimum values at q</italic><sub>44</sub>; <italic>since they are equal (it is a uniform quadrant), a call to addDescendantsLeaves adds the object in m</italic><sub>32</sub>
<italic>to the output (in this case the polygon f). This ends the computation of top-1</italic>.</p></sec></sec></sec><sec id="sec015"><title>A note on complexity</title><sec id="sec016"><title>Time</title><p>Observe that our two algorithms can be modeled as a spatial join between an R-tree and a raster where the spatial predicate is the intersection of areas or zones. When using spatial data structures as, for example, the R-tree and quadtrees, the worst-case analytical complexity for window queries, which include among others spatial joins, does not reflect what really occurs in practice, because the behaviour depends on the size of the window and on the intersection area or zones at each level of the spatial structure [<xref rid="pone.0226943.ref044" ref-type="bibr">44</xref>]. Recall that the <italic>k</italic><sup>2</sup>-raster is conceptually a quadtree.</p><p>Therefore, to better predict the actual performance, the usual approach is to develop cost models. For example, Theodoridis et al. [<xref rid="pone.0226943.ref045" ref-type="bibr">45</xref>] presented a cost model to approach the cost of a window query using an R-tree. On the other hand, Theodoridis et al. [<xref rid="pone.0226943.ref046" ref-type="bibr">46</xref>] and Corral et al. [<xref rid="pone.0226943.ref047" ref-type="bibr">47</xref>] proposed cost models that estimate the time required to calculate a spatial join between two R-trees considering a spatial predicate and distance, respectively.</p><p>The development of a cost model for our algorithms is beyond the scope of this paper, becoming a result by itself. However, we present a preliminary analysis.</p><p>Let <italic>&#x02113;</italic> be the number of MBRs in the last level of the R-tree and let <italic>n</italic> be the number of rows/columns of the raster. A simple baseline approach to solve the spatial join would proceed first by obtaining the MBRs in the leaves of the R-tree, and then, for each one, inspect all cells of the raster that overlap that MBR. The number of cells that overlap an MBR is bounded by the size of the raster, that is, <italic>O</italic>(<italic>n</italic><sup>2</sup>). Therefore the time complexity of that baseline approach is &#x00398;(<italic>&#x02113;n</italic><sup>2</sup>).</p><p>Now, we analyze the spatial join in our framework. The advantage of our algorithms is that they do not need to always reach the last level of the R-tree to obtain the output. There are several cases where the search from the root of the R-tree stops before the last level:</p><list list-type="bullet"><list-item><p>In the case of Algorithm 1:
<list list-type="order"><list-item><p>When all the values of the region contain the exact same value, that is, when the minimum and maximum values of the <italic>k</italic><sup>2</sup>-raster node are equal, and that value is not within the queried range.</p></list-item><list-item><p>When the maximum value of the processed <italic>k</italic><sup>2</sup>-raster node is smaller than the left extreme of the queried range, or when the minimum is greater than the right extreme of the queried range.</p></list-item></list></p></list-item><list-item><p>In the case of Algorithm 2, in addition to the previous cases, the algorithm stops when the size of the resulting set reaches the desired <italic>K</italic>.</p></list-item></list><p>The worst case for Algorithm 1 corresponds to that where for all the MBRs of the <italic>R</italic>-tree, we need to traverse all the nodes of the <italic>k</italic><sup>2</sup>-raster. Considering the <italic>&#x02113;</italic> MBRs and the number of nodes of a complete <italic>k</italic><sup>2</sup>-raster <inline-formula id="pone.0226943.e045"><alternatives><graphic xlink:href="pone.0226943.e045.jpg" id="pone.0226943.e045g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M45"><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>h</mml:mi></mml:msubsup><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>&#x02248;</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <italic>h</italic> = <italic>O</italic>(<italic>log</italic><sub><italic>k</italic></sub><italic>n</italic>) is the height of the <italic>k</italic><sup>2</sup>-raster, then the cost for the worst case is <italic>O</italic>(<italic>&#x02113;n</italic><sup>2</sup>).</p><p>In the case of Algorithm 2, the predominant costs are those corresponding to the management of the priority queue <italic>Q</italic> and the cost of function <italic>checkGeometry</italic>. Let us simplify the analysis considering just top-1 query (<italic>K</italic> = 1). On one hand, the worst case would require that all MBRs need to be inserted in <italic>Q</italic>, as the maximum value is guiding the search to areas close to (but not within) all the other MBRs different for the top-1. This causes that the total cost of inserting and obtaining the head of the queue at each step is <italic>O</italic>(<italic>&#x02113; </italic>log<sub>2</sub>
<italic>&#x02113;</italic>). On the other hand, <italic>checkGeometry</italic> requires a verification, in the worst case, of <italic>O</italic>(<italic>n</italic><sup>2</sup>) cells. Thus, the total cost for Algorithm 2 is <italic>O</italic>(<italic>&#x02113;</italic> log<sub>2</sub>
<italic>&#x02113;</italic>) + <italic>O</italic>(<italic>&#x02113;n</italic><sup>2</sup>) = <italic>O</italic>(<italic>&#x02113;n</italic><sup>2</sup>). It is noticeable that, for the worst case, the overall cost of top-<italic>K</italic> does not depend on <italic>K</italic> &#x02264; <italic>&#x02113;</italic>, and part of the <italic>O</italic>(<italic>&#x02113;</italic>) inserted elements in <italic>Q</italic> will be members of the solution and will be also inserted into list <italic>T</italic>.</p><p>Thus, the overall cost for the worst-case scenario of our algorithms is the same as that of the baseline. However, it is a very pessimistic analysis that is not considering the amount of searches that are not reaching the last level of the R-tree. Let us consider the MBRs in the last level of the R-tree such that in some step of the tree traversal, the search ended before reaching them, and denote <italic>R</italic> the percentage of those MBRs. Therefore, the question is the size of <italic>R</italic>; that study would require a cost model, however, as both our experimental results and previous work using lightweight indexation (which include min, max values at nodes) [<xref rid="pone.0226943.ref037" ref-type="bibr">37</xref>&#x02013;<xref rid="pone.0226943.ref039" ref-type="bibr">39</xref>] show, the real performance is improved.</p></sec><sec id="sec017"><title>Storage</title><p>The space consumption for the case of the R-tree was presented in the original work [<xref rid="pone.0226943.ref018" ref-type="bibr">18</xref>]. In the case of the <italic>k</italic><sup>2</sup>-raster, it has not been presented previously, again, because a worst case complexity does not fairly reflect the behaviour of the data structure.</p><p>However, we can compare the worst case of a baseline approach and that of the <italic>k</italic><sup>2</sup>-raster. Being <inline-formula id="pone.0226943.e046"><alternatives><graphic xlink:href="pone.0226943.e046.jpg" id="pone.0226943.e046g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M46"><mml:mi mathvariant="script">M</mml:mi></mml:math></alternatives></inline-formula> the highest value of the raster, a simple baseline that stores each cell using <inline-formula id="pone.0226943.e047"><alternatives><graphic xlink:href="pone.0226943.e047.jpg" id="pone.0226943.e047g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M47"><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> bits requires in total <inline-formula id="pone.0226943.e048"><alternatives><graphic xlink:href="pone.0226943.e048.jpg" id="pone.0226943.e048g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M48"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mo>&#x00398;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> bits.</p><p>The most unfavorable scenario for the <italic>k</italic><sup>2</sup>-raster occurs when all cell values are different. In this case, it has to store the topology of the tree (bitmap <italic>T</italic>) and the two sequences of minimum and maximum values for each level of the tree, except for the last level, where only the sequence of maximum values is stored. Assuming <italic>h</italic> the height of the <italic>k</italic><sup>2</sup>-raster, the number of nodes at each level <italic>i</italic>, in a complete tree is <italic>k</italic><sup>2<italic>i</italic></sup>, being 0 &#x02264; <italic>i</italic> &#x02264; <italic>h</italic>. The number of internal nodes of a complete <italic>k</italic><sup>2</sup>-raster is <inline-formula id="pone.0226943.e049"><alternatives><graphic xlink:href="pone.0226943.e049.jpg" id="pone.0226943.e049g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M49"><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>&#x02248;</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and the number of leaf nodes <italic>k</italic><sup>2<italic>h</italic></sup>.</p><p>Therefore the required storage is <inline-formula id="pone.0226943.e050"><alternatives><graphic xlink:href="pone.0226943.e050.jpg" id="pone.0226943.e050g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M50"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <italic>c</italic>(.) is the number of bits required by DACs encoding. Since the internal nodes have two lists and the last level only one, the size of these lists joined is <italic>s</italic> &#x02248; 2<italic>k</italic><sup>2<italic>h</italic></sup>. According to [<xref rid="pone.0226943.ref036" ref-type="bibr">36</xref>], the number of bits of a compressed sequence of length <italic>s</italic> with DACs is <inline-formula id="pone.0226943.e051"><alternatives><graphic xlink:href="pone.0226943.e051.jpg" id="pone.0226943.e051g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M51"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:msqrt><mml:mfrac><mml:msub><mml:mi>N</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mi>s</mml:mi></mml:mfrac></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0226943.e052"><alternatives><graphic xlink:href="pone.0226943.e052.jpg" id="pone.0226943.e052g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M52"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>s</mml:mi></mml:msubsup><mml:mrow><mml:mo>&#x0230a;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&#x0230b;</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x02264;</mml:mo><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> bits, thus the worst case space of the <italic>k</italic><sup>2</sup>-raster is <inline-formula id="pone.0226943.e053"><alternatives><graphic xlink:href="pone.0226943.e053.jpg" id="pone.0226943.e053g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M53"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p><p>Again the worst case is the same as that of the baseline. However, the baseline does not benefit from Tobler&#x02019;s law, thus the total cost will be exactly <inline-formula id="pone.0226943.e054"><alternatives><graphic xlink:href="pone.0226943.e054.jpg" id="pone.0226943.e054g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M54"><mml:mrow><mml:mrow><mml:mo>&#x02308;</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mi mathvariant="script">M</mml:mi><mml:mo>&#x02309;</mml:mo></mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> bits always. Nevertheless, in practice, the <italic>k</italic><sup>2</sup>-raster can reduce significantly the storage due to two effects:</p><list list-type="order"><list-item><p>Parts of the raster having the same value are simply represented by only one number. This is a feasible assumption due to Tobler&#x02019;s law.</p></list-item><list-item><p>The numbers are represented using difference encoding with respect to the maximum value of the parent node, which decreases the magnitude of the numbers when increasing the depth in the tree. In other words, there is a new maximum value <inline-formula id="pone.0226943.e055"><alternatives><graphic xlink:href="pone.0226943.e055.jpg" id="pone.0226943.e055g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M55"><mml:mrow><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="3.33333pt"/><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> for each level of the tree and, it is sure that <inline-formula id="pone.0226943.e056"><alternatives><graphic xlink:href="pone.0226943.e056.jpg" id="pone.0226943.e056g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M56"><mml:mrow><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:mi mathvariant="script">M</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0226943.e057"><alternatives><graphic xlink:href="pone.0226943.e057.jpg" id="pone.0226943.e057g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M57"><mml:mrow><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mi mathvariant="script">M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mspace width="3.33333pt"/><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p><p>This reduction of the magnitude of the numbers is exploited by DACs encoding, thus obtaining further compression.</p></list-item></list><p>Again, to determine the percentage of raster cells that are compacted in just one number (uniform areas) and the effective reduction of magnitudes for the maximum-minimum sequences, better analysis can be obtained if a model of the data is considered.</p></sec></sec><sec id="sec018"><title>Experimental evaluation</title><sec id="sec019"><title>Experimental framework</title><p>In this section, we present a set of experiments to measure the space consumption and processing time of the two algorithms.</p><p>The machine used in the experiments was equipped with an Intel<sup>&#x000ae;</sup> Core<sup>&#x02122;</sup> i7-3820 CPU @ 3.60 GHz (4 cores) processor and 64 GB of RAM. The operating system was Ubuntu 12.04.5 LTS with kernel 3.2.0-115 (64 bits). All the programs were coded in C++ and compiled using gcc version 4.6.4 with <monospace>-O3</monospace> options.</p><p>Time is measured using the sum of <sc>user</sc> and <sc>sys</sc> values provided by the Linux <sc>time</sc> command, in seconds, except in the experiments of cold start that show the <sc>real</sc> value. The memory consumption is measured taking the <sc>vmpeak</sc> value of the pseudo-file system <sc>proc</sc>, in megabytes.</p><p>We obtained the R-tree implementation from <ext-link ext-link-type="uri" xlink:href="https://libspatialindex.github.io">https://libspatialindex.github.io</ext-link> and we configured it with a page size of 4 KB and a fill factor of 70%. We used the authors&#x02019; implementation of the <italic>k</italic><sup>2</sup>-raster, available at <ext-link ext-link-type="uri" xlink:href="http://lbd.udc.es/research/k2-raster/">http://lbd.udc.es/research/k2-raster/</ext-link>. We chose the heuristic variant [<xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>] with a hybrid configuration using <italic>n</italic><sub>1</sub> = 4, <italic>k</italic><sub>1</sub> = 4, and <italic>k</italic><sub>2</sub> = 2. The bitmaps needed by the <italic>k</italic><sup>2</sup>-raster code were arranged with an implementation of the <italic>rank</italic> operation that requires a 5% of extra space on top of the bitmap [<xref rid="pone.0226943.ref048" ref-type="bibr">48</xref>]. In addition, the code uses also a DACs implementation configured to obtain the maximum compression restricting the maximum number of levels to 3.</p></sec><sec id="sec020"><title>Baselines</title><p>There is no previous implementation for the spatial join operation in the literature. The closest related works are those by Corral et al. [<xref rid="pone.0226943.ref007" ref-type="bibr">7</xref>] and Brisaboa et al. [<xref rid="pone.0226943.ref009" ref-type="bibr">9</xref>]. In the case of the top-<italic>K</italic> operation, there is not even any close related work.</p><p>The work of Corral et al. only considers binary rasters, thus we run a separate experiment for this software, as our algorithm is designed for rasters with different values, which implies more complex data structures.</p><p>The work of Brisaboa et al. returns only the vector objects, but not the raster cells. However, we modified the authors&#x02019; algorithm in order to obtain the same output as ours. We made our implementation using the same R-tree used for the rest. The data structure for storing the raster data, called <italic>k</italic><sup>2</sup>-acc, was the authors&#x02019; implementation.</p><p>Furthermore, we programmed three additional baselines. Two of them load the complete uncompressed dataset into main memory, where the data are kept as a simple array following a simple filling curve row by row. One is denoted <monospace>Plain-Ints</monospace> and uses a 32-bit integer representation for each cell value. The other is termed <monospace>Plain-Bits</monospace> and uses &#x02308;<italic>log</italic>(#<italic>v</italic>)&#x02309; bits for each cell value, being #<italic>v</italic> the number of different values in the original matrix. Finally, the third baseline uses the NetCDF libraries from Unidata<sup>&#x000ae;</sup>, available at <ext-link ext-link-type="uri" xlink:href="http://www.unidata.ucar.edu/downloads/netcdf/">http://www.unidata.ucar.edu/downloads/netcdf/</ext-link>, to compress and decompress raster data, with the recommended <italic>deflate</italic> level 2.</p><p>For the baselines, we use two naive strategies:</p><list list-type="order"><list-item><p>The strategy labeled <monospace>mbrs</monospace> looks for all leaf MBRs in the R-tree and then overlaps them with the raster dataset, where, for each intersection between an MBR and the overlapping portion of the raster:</p><list list-type="bullet"><list-item><p>In the case of the join, it searches the cells having values in the queried range.</p></list-item><list-item><p>In the case of the top-<italic>K</italic> query, it obtains the largest cell value, and it retains those MBRs with the highest values.</p></list-item></list></list-item><list-item><p>The strategy labeled <monospace>cells</monospace> starts by the other side, that is:</p><list list-type="bullet"><list-item><p>In the case of the join, it obtains the cells of the raster that meet the range specified in the query, then those positions are checked using the R-tree to see if they lie within an MBR.</p></list-item><list-item><p>The cells with the top-<italic>K</italic> values (not necessarily different) in the raster dataset are obtained. Then the R-tree is used to look for overlapping MBRs. If not enough MBRs are found, the next top-<italic>K</italic> values in the raster are obtained, and so on.</p></list-item></list></list-item></list><p>In the case of the join, for <monospace>Plain-Ints</monospace>, <monospace>Plain-Bits</monospace>, and <monospace>NetCDF</monospace>, we only included the <monospace>mbrs</monospace> method, as the <monospace>cells</monospace> approach was too slow. However, we include the <monospace>cells</monospace> version using a <italic>k</italic><sup>2</sup>-raster representation (<monospace>k<sup>2</sup>-raster-cells</monospace>), in order to see the difference with our algorithm.</p><p>For the top-<italic>K</italic> query, we replaced <monospace>Plain-Bits</monospace> by <monospace>k<sup>2</sup>-treap</monospace>, which is a baseline based on <italic>k</italic><sup>2</sup>-treap that uses the implementation published by the Database Lab research group, available at <ext-link ext-link-type="uri" xlink:href="http://lbd.udc.es/research/aggregatedRQ/">http://lbd.udc.es/research/aggregatedRQ/</ext-link>. The reason is that this structure, although it is very inefficient for other types of queries, including the join operation, was specifically designed for the top-<italic>K</italic> query. There is just one implementation for <monospace>k<sup>2</sup>-treap</monospace>, since strategy <monospace>cells</monospace> seems the best option in that scenario (as it has an index that allows us to rapidly obtain the top-<italic>K</italic> cells). The code of all these baselines is available at <ext-link ext-link-type="uri" xlink:href="https://gitlab.lbd.org.es/fsilva/basic_raster">https://gitlab.lbd.org.es/fsilva/basic_raster</ext-link>.</p><p>Another possible comparison is the traditional approach of translating the vector dataset to raster, and then run a classical raster-raster algorithm. However, that procedure is costly, for example, we used Grass (<ext-link ext-link-type="uri" xlink:href="https://grass.osgeo.org/">https://grass.osgeo.org/</ext-link>) latest version (7.4) to translate our two vector datasets (see next section). This took 6 and 1.8 seconds, which is much more than the time needed by our algorithm to run the query, and therefore we decided not to include this baseline in our experiments.</p></sec><sec id="sec021"><title>Datasets</title><p>The datasets used in our experiments, both the vector and the raster datasets, correspond to real data that were scaled to fit in the same space. Notice that this is the most demanding scenario for a spatial join, as it is not possible to exclude any branch of the R-tree. We describe them more in depth in the following section.</p><sec id="sec022"><title>Raster datasets</title><p>The raster datasets were obtained from Spanish Geographic Institute (SGI), which includes several DTM (Digital Terrain Model) data files with the spatial elevation data of the terrain of Spain. The complete DTM of Spain is divided in several tiles, and each tile is stored in a separate file. Each file contains a grid of regularly spaced points, with 5 metres of spatial resolution, storing their spatial elevation as real numbers of at most 3 decimal digits.</p><p>In order to evaluate the performance of our algorithms, we obtained two different sets of rasters, which serve us to analyze the scalability of our algorithms in two different scenarios:</p><list list-type="bullet"><list-item><p>Scenario I: designed for analysis based on raster size. <xref rid="pone.0226943.t003" ref-type="table">Table 3</xref> shows the details of our set of rasters of increasing size. The set is formed by four collections, each one containing different matrices of the same size. Our initial collection, <monospace>DTM-1&#x000d7;1</monospace>, was built selecting 25 samples of exactly one tile of the DTM; the collection <monospace>DTM-2&#x000d7;2</monospace> was built using 2 &#x000d7; 2 adjacent tiles, and so on. The data shown in the table (e.g. the number of different values) correspond to the mean values obtained for all the matrices in each collection. We will report the average values for space and time results, in the experiments, for each collection, thus, avoiding the dependence on the selection of a unique matrix. In this scenario, we only considered the integer part of the value stored at each cell of the matrix.</p></list-item><list-item><p>Scenario II: designed for analysis based on the distribution of raster values. <xref rid="pone.0226943.t004" ref-type="table">Table 4</xref> shows the details of the set of rasters that form a scenario of equal sized datasets, but with increasing number of distinct values. We chose one of the <monospace>DTM-4&#x000d7;4</monospace> datasets, and generated a collection of matrices varying the number of different values. For this, we truncated the original values by taking 0, 1, 2, and 3 decimal digits.</p></list-item></list><table-wrap id="pone.0226943.t003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.t003</object-id><label>Table 3</label><caption><title>Raster dataset for Scenario I.</title><p>Values in Megabytes.</p></caption><alternatives><graphic id="pone.0226943.t003g" xlink:href="pone.0226943.t003"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1">Name</th><th align="right" rowspan="1" colspan="1">#rows</th><th align="right" rowspan="1" colspan="1">#cols</th><th align="right" rowspan="1" colspan="1"># dif. values</th><th align="right" rowspan="1" colspan="1"><monospace>Plain-Ints</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>Plain-Bits</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>k<sup>2</sup>-raster</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>NetCDF</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>k<sup>2</sup>-treap</monospace></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-1&#x000d7;1</monospace></td><td align="right" rowspan="1" colspan="1">4,100</td><td align="right" rowspan="1" colspan="1">5,849</td><td align="right" rowspan="1" colspan="1">868</td><td align="right" rowspan="1" colspan="1">91</td><td align="right" rowspan="1" colspan="1">30</td><td align="right" rowspan="1" colspan="1">10</td><td align="right" rowspan="1" colspan="1">10</td><td align="right" rowspan="1" colspan="1">15</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-2&#x000d7;2</monospace></td><td align="right" rowspan="1" colspan="1">8,242</td><td align="right" rowspan="1" colspan="1">11,737</td><td align="right" rowspan="1" colspan="1">1,201</td><td align="right" rowspan="1" colspan="1">369</td><td align="right" rowspan="1" colspan="1">126</td><td align="right" rowspan="1" colspan="1">38</td><td align="right" rowspan="1" colspan="1">38</td><td align="right" rowspan="1" colspan="1">58</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-3&#x000d7;3</monospace></td><td align="right" rowspan="1" colspan="1">12,403</td><td align="right" rowspan="1" colspan="1">17,643</td><td align="right" rowspan="1" colspan="1">1,503</td><td align="right" rowspan="1" colspan="1">835</td><td align="right" rowspan="1" colspan="1">296</td><td align="right" rowspan="1" colspan="1">81</td><td align="right" rowspan="1" colspan="1">84</td><td align="right" rowspan="1" colspan="1">132</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-4&#x000d7;4</monospace></td><td align="right" rowspan="1" colspan="1">16,564</td><td align="right" rowspan="1" colspan="1">23,564</td><td align="right" rowspan="1" colspan="1">1,761</td><td align="right" rowspan="1" colspan="1">1,479</td><td align="right" rowspan="1" colspan="1">535</td><td align="right" rowspan="1" colspan="1">143</td><td align="right" rowspan="1" colspan="1">151</td><td align="right" rowspan="1" colspan="1">236</td></tr></tbody></table></alternatives></table-wrap><table-wrap id="pone.0226943.t004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.t004</object-id><label>Table 4</label><caption><title>Raster dataset for Scenario II.</title><p>Values in Megabytes.</p></caption><alternatives><graphic id="pone.0226943.t004g" xlink:href="pone.0226943.t004"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1">Name</th><th align="right" rowspan="1" colspan="1">#rows</th><th align="right" rowspan="1" colspan="1">#cols</th><th align="right" rowspan="1" colspan="1"># dif. values</th><th align="right" rowspan="1" colspan="1"><monospace>Plain-Ints</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>Plain-Bits</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>k<sup>2</sup>-raster</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>NetCDF</monospace></th><th align="right" rowspan="1" colspan="1"><monospace>k<sup>2</sup>-treap</monospace></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-4&#x000d7;4<sub>0</sub></monospace></td><td align="right" rowspan="1" colspan="1">16,564</td><td align="right" rowspan="1" colspan="1">23,564</td><td align="right" rowspan="1" colspan="1">2,153</td><td align="right" rowspan="1" colspan="1">1479</td><td align="right" rowspan="1" colspan="1">555</td><td align="right" rowspan="1" colspan="1">139</td><td align="right" rowspan="1" colspan="1">147</td><td align="right" rowspan="1" colspan="1">230</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-4&#x000d7;4<sub>1</sub></monospace></td><td align="right" rowspan="1" colspan="1">16,564</td><td align="right" rowspan="1" colspan="1">23,564</td><td align="right" rowspan="1" colspan="1">21,491</td><td align="right" rowspan="1" colspan="1">1479</td><td align="right" rowspan="1" colspan="1">693</td><td align="right" rowspan="1" colspan="1">362</td><td align="right" rowspan="1" colspan="1">322</td><td align="right" rowspan="1" colspan="1">361</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-4&#x000d7;4<sub>2</sub></monospace></td><td align="right" rowspan="1" colspan="1">16,564</td><td align="right" rowspan="1" colspan="1">23,564</td><td align="right" rowspan="1" colspan="1">208,493</td><td align="right" rowspan="1" colspan="1">1479</td><td align="right" rowspan="1" colspan="1">832</td><td align="right" rowspan="1" colspan="1">540</td><td align="right" rowspan="1" colspan="1">454</td><td align="right" rowspan="1" colspan="1">509</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>DTM-4&#x000d7;4<sub>3</sub></monospace></td><td align="right" rowspan="1" colspan="1">16,564</td><td align="right" rowspan="1" colspan="1">23,564</td><td align="right" rowspan="1" colspan="1">1,829,334</td><td align="right" rowspan="1" colspan="1">1479</td><td align="right" rowspan="1" colspan="1">970</td><td align="right" rowspan="1" colspan="1">708</td><td align="right" rowspan="1" colspan="1">611</td><td align="right" rowspan="1" colspan="1">659</td></tr></tbody></table></alternatives></table-wrap><p>All measures are the mean resulting from running 10 queries with random query ranges over each dataset for each collection. That means that, for example, in the <monospace>DTM-1&#x000d7;1</monospace> collection, 10 &#x000d7; 25 = 250 queries were run. All queries are available at: <ext-link ext-link-type="uri" xlink:href="http://lbd.udc.es/research/k2-raster/">http://lbd.udc.es/research/k2-raster/</ext-link>.</p><p>Tables <xref rid="pone.0226943.t003" ref-type="table">3</xref> and <xref rid="pone.0226943.t004" ref-type="table">4</xref> show that by using <monospace>k<sup>2</sup>-raster</monospace>, our framework obtains important savings in disk space with respect to the uncompressed representations. In the datasets of Scenario I, <monospace>k<sup>2</sup>-raster</monospace> occupies around 10% of the space occupied by <monospace>Plain-Ints</monospace> and between 27% and 33% of that occupied by <monospace>Plain-Bits</monospace>. For Scenario II, <monospace>k<sup>2</sup>-raster</monospace> occupies between 9% and 48% of the space occupied by <monospace>Plain-Ints</monospace> and between 25% and 73% of that occupied by <monospace>Plain-Bits</monospace>.</p><p>With respect to the compressed representations, <monospace>k<sup>2</sup>-raster</monospace> obtains similar results to those of <monospace>NetCDF</monospace>, except in the datasets with many different values of Scenario II, where <monospace>NetCDF</monospace> occupies around 85% of the space required by <monospace>k<sup>2</sup>-raster</monospace>. Finally, <monospace>k<sup>2</sup>-raster</monospace> occupies around 65% of the space used by <monospace>k<sup>2</sup>-treap</monospace>, except in the datasets with many distinct values, where they are approximately on a par.</p></sec><sec id="sec023"><title>Vector datasets</title><p>We obtained two datasets from the ChoroChronos.org web site (<ext-link ext-link-type="uri" xlink:href="http://www.chorochronos.org/">http://www.chorochronos.org/</ext-link>). In our experiments, the label <monospace>vects</monospace> refers to the dataset <italic>Tiger Streams</italic> and the label <monospace>vecca</monospace> refers to the dataset <italic>California Roads</italic> of that site. These two datasets have a very different number of MBRs and spatial distribution, as shown in <xref ref-type="fig" rid="pone.0226943.g003">Fig 3</xref>. More concretley, <monospace>vects</monospace> contains 194,971 MBRs and <monospace>vecca</monospace> contains 2,249,727 MBRs.</p><fig id="pone.0226943.g003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g003</object-id><label>Fig 3</label><caption><title>Spatial distribution of the MBRs of the vector datasets <monospace>vects</monospace> (left) and <monospace>vecca</monospace> (right).</title></caption><graphic xlink:href="pone.0226943.g003"/></fig></sec></sec><sec id="sec024"><title>Spatial join</title><p>Before presenting the results of our experiment, we must make a point. The three baselines, at the filtering step, use the rectangular shape of the MBRs to rapidly obtain the cells of the raster overlapping each MBR, and thus they are also able to produce two lists of definitive and probable results. Since these lists must be, necessarily, the same as those produced by our algorithm, all our measurements in this experiment have excluded, for practical reasons, the effects of the final refinement step.</p><sec id="sec025"><title>Memory usage</title><p>In this experiment, we do not include the values of Brisaboa et al. [<xref rid="pone.0226943.ref009" ref-type="bibr">9</xref>] since the authors&#x02019; implementation of the <italic>k</italic><sup>2</sup>-acc is very inefficient in managing the memory consumption, yielding really bad results.</p><p>
<xref ref-type="fig" rid="pone.0226943.g004">Fig 4</xref> shows the main memory consumption for Scenario I. Our framework is denoted as <monospace>k<sup>2</sup>-raster</monospace>. We can observe that, compared to the baselines with uncompressed representations, our approach gets always the lowest memory consumption and the best scalability when joining our raster collections with both vector datasets.</p><fig id="pone.0226943.g004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g004</object-id><label>Fig 4</label><caption><title>Memory consumption (in Megabytes) for rasters in Scenario I.</title><p>(a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g004"/></fig><p>However, comparatively speaking, the improvement in memory consumption is lower than the one observed when we compared disk space consumptions. This could be partially explained by the fact that the reported memory consumption includes the size of the output. As such size, which is the same for all approaches, is usually large, it represents a good part of the memory space consumed by all of them. This means that, when expressing percentage differences between the approaches, the distances are reduced, distorting the comparison.</p><p>Nevertheless, our method uses only 31&#x02013;73% of the memory space used by <monospace>Plain-Ints-mbrs</monospace>, and 60&#x02013;89% of that used by <monospace>Plain-Bits-mbrs</monospace>. This is clearly an important improvement, and shows, in addition, that the memory consumption of <monospace>k<sup>2</sup>-raster</monospace> is not seriously harmed by the fact of having to manage data in a compressed format.</p><p>The situation changes in the comparison with <monospace>NetCDF</monospace>. When checking for portions of the raster, <monospace>NetCDF</monospace> loads the needed blocks of the file one by one. Each block is decompressed, processed, and then removed from main memory. Therefore, this baseline consumes less memory in the largest datasets, although differences are below 25%.</p><p>Finally, <monospace>k<sup>2</sup>-raster-cells</monospace> has the worst behaviour, since <monospace>k<sup>2</sup>-raster</monospace> consumes between 23% and 48% of the space required by the baseline.</p><p>
<xref ref-type="fig" rid="pone.0226943.g005">Fig 5</xref> shows the results for Scenario II. Our algorithm consumes between 31% and 89% of the space used by the uncompressed baselines. On the contrary, <monospace>NetCDF-mbrs</monospace> consumes between 43% and 87% of the space required by <monospace>k<sup>2</sup>-raster</monospace>.</p><fig id="pone.0226943.g005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g005</object-id><label>Fig 5</label><caption><title>Memory consumption (in Megabytes) for rasters in Scenario II.</title><p>(a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g005"/></fig><p>Again, the worst values are those of the strategy <monospace>cells</monospace> using the <italic>k</italic><sup>2</sup>-raster, since our method uses between 24% and 38% of the space consumed by <monospace>k<sup>2</sup>-raster-cells</monospace>.</p></sec><sec id="sec026"><title>Time performance</title><p>In order to obtain compression, the <italic>k</italic><sup>2</sup>-raster needs a complex arrangement of the data it stores. Therefore, our uncompressed baselines are tough competitors since they keep the raster data in main memory uncompressed and arranged as a simple space-filling curve row by row.</p><p>This problem is common to all compact data structures. However, many of them obtain better usage times than managing directly uncompressed data. The main reasons are: (i) the dataset representation is smaller, yielding a better usage of the memory hierarchy; and (ii) most of them include, in the same compressed space, indexes that speed up queries.</p><p>In our case, <italic>k</italic><sup>2</sup>-raster uses the quadtree arrangement of the data, which cleverly obtains compression and, at the same time, obtains a spatial index. In addition, it couples the quadtree with lightweight indexation, to index the values at cells. Therefore, part of the improvements in processing time of our framework comes from the capacity of the indexes of the <italic>k</italic><sup>2</sup>-raster to prune the search space.</p><p>Figs <xref ref-type="fig" rid="pone.0226943.g006">6</xref> and <xref ref-type="fig" rid="pone.0226943.g007">7</xref> show outstanding improvements, even using a logarithmic scale on the y-axis. The indexes of the <italic>k</italic><sup>2</sup>-raster do their job and thus our method is between 1.21 and 3.55 times faster than <monospace>Plain-Ints-mbrs</monospace> and between 1.72 and 8 times faster than <monospace>Plain-Bits-mbrs</monospace>.</p><fig id="pone.0226943.g006" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g006</object-id><label>Fig 6</label><caption><title>Processing time (in seconds and log scale) with rasters of Scenario I.</title><p>(a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g006"/></fig><fig id="pone.0226943.g007" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g007</object-id><label>Fig 7</label><caption><title>Processing time (in seconds and log scale) with rasters of Scenario II.</title><p>(a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g007"/></fig><p>
<monospace>NetCDF</monospace>, which uses a traditional compression method, competes with our framework in space consumption, both in disk and main memory, obtaining better results in some cases. However, when measuring processing time, results are clearly worse. As explained, each time a portion of the raster is demanded, this requires to decompress one or more blocks storing that information. This costly process should be carried out for each MBR in the leaves of the R-tree. The blocks must also be loaded from disk, but remember that disk access times are not taken into account in this experiment. As we can see in the plots, our approach outperforms this baseline in around three orders of magnitude. The results show that a reasonable sacrifice of memory space clearly improves response times.</p><p>The <monospace>cells</monospace> baseline using <italic>k</italic><sup>2</sup>-raster has the worst behaviour, even one order of magnitude worse than <monospace>NetCDF</monospace>.</p><p>Finally, the approach of Brisaboa et al., denoted in the experiments as <monospace><italic>k</italic><sup>2</sup>-acc</monospace>, was only able to run over the two smallest datasets of Scenario I, as it works really badly already when the raster has a moderate number of different values [<xref rid="pone.0226943.ref009" ref-type="bibr">9</xref>, <xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>].</p></sec><sec id="sec027"><title>Main memory consumption versus processing time trade-off</title><p>As a summary, <xref ref-type="fig" rid="pone.0226943.g008">Fig 8</xref> includes two plots showing the trade-off between main memory consumption and processing time achieved with the largest dataset of Scenario I, using logarithmic scale in the x-axis. Again the <italic>k</italic><sup>2</sup>-acc is omitted since its memory consumption is very high. Clearly, we can see that our method is the best choice.</p><fig id="pone.0226943.g008" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g008</object-id><label>Fig 8</label><caption><title>Memory consumption vs processing time with the largest raster of Scenario I.</title><p>Memory consumption (in Megabytes) vs processing time (in seconds and log scale) with the largest raster of Scenario I. (a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g008"/></fig></sec><sec id="sec028"><title>Cold start</title><p>Previous experiments were run in &#x0201c;warm&#x0201d; start, that is, the queries were run sequentially, and thus, the operating system disk buffer keeps, with high probability, important parts of the input datasets in main memory. This eliminates the effect of disk access on times.</p><p>In order to show the impact of disk access, we designed an experiment in &#x0201c;cold&#x0201d; start. This implies that:</p><list list-type="bullet"><list-item><p>We measured <sc>real</sc> time to include disk access times.</p></list-item><list-item><p>All data structures resided on disk and the operating system buffer was cleared before the execution of each query.</p></list-item></list><p>We run 4 queries over each collection (recall that each collection contains several datasets).</p><p>
<xref ref-type="fig" rid="pone.0226943.g009">Fig 9</xref> shows the results, which do not change the general picture with respect to the performance of each method shown in <xref ref-type="fig" rid="pone.0226943.g006">Fig 6</xref>.</p><fig id="pone.0226943.g009" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g009</object-id><label>Fig 9</label><caption><title>Processing time (in seconds and log scale) with rasters of Scenario I and cold start.</title><p>(a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g009"/></fig></sec><sec id="sec029"><title>Comparison with classical approaches</title><p>One of the closest works is that of Corral et al. [<xref rid="pone.0226943.ref007" ref-type="bibr">7</xref>], but it only considers binary rasters. Even thought the comparison can be considered unfair for our framework, which can also represent integer rasters, we ran some experiments to study how our approach performs compared to that baseline.</p><p>To obtain binary rasters, we took the datasets of our Scenario I and set to zero the cells with values below the median, and to one the others. <xref rid="pone.0226943.t005" ref-type="table">Table 5</xref> shows the size of the resulting datasets. The work of Corral et al. uses a classical setup, including a linear quadtree stored in a <italic>B</italic><sup>+</sup>-tree to represent the binary raster. As a modern compact data structure, the <italic>k</italic><sup>2</sup>-raster obtains important savings in space.</p><table-wrap id="pone.0226943.t005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.t005</object-id><label>Table 5</label><caption><title>Size of the datasets in Kilobytes.</title></caption><alternatives><graphic id="pone.0226943.t005g" xlink:href="pone.0226943.t005"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="right" rowspan="1" colspan="1">Linear Quadtree</th><th align="right" rowspan="1" colspan="1"><italic>k</italic><sup>2</sup>-raster</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">Binary <monospace>DTM-1&#x000d7;1</monospace></td><td align="char" char="." rowspan="1" colspan="1">3595.1</td><td align="char" char="." rowspan="1" colspan="1">39.3</td></tr><tr><td align="left" rowspan="1" colspan="1">Binary <monospace>DTM-2&#x000d7;2</monospace></td><td align="char" char="." rowspan="1" colspan="1">12170.5</td><td align="char" char="." rowspan="1" colspan="1">121.3</td></tr><tr><td align="left" rowspan="1" colspan="1">Binary <monospace>DTM-3&#x000d7;3</monospace></td><td align="char" char="." rowspan="1" colspan="1">24076.1</td><td align="char" char="." rowspan="1" colspan="1">215.0</td></tr><tr><td align="left" rowspan="1" colspan="1">Binary <monospace>DTM-4&#x000d7;4</monospace></td><td align="char" char="." rowspan="1" colspan="1">27340.3</td><td align="char" char="." rowspan="1" colspan="1">244.7</td></tr></tbody></table></alternatives></table-wrap><p>As seen in <xref ref-type="fig" rid="pone.0226943.g010">Fig 10</xref>, our method is faster even though that the <italic>k</italic><sup>2</sup>-raster has a complex data structure designed to compress integers. Observe that each access to a node requires two subtractions to obtain the values at that node, and in the leaves, it also requires accessing to a compressed representation for integer sequences (DACs), which is also costly. For binary rasters, instead of a <italic>k</italic><sup>2</sup>-raster, we could use a simpler and faster <italic>k</italic><sup>2</sup>-tree, which does not need neither subtractions nor DACs representation.</p><fig id="pone.0226943.g010" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g010</object-id><label>Fig 10</label><caption><title>Processing time (in seconds) of the comparison with a classical data structure approach in Scenario I.</title><p>(a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g010"/></fig><p>However, the lightweight index at the nodes of the <italic>k</italic><sup>2</sup>-raster plus its small size are still able to improve times.</p></sec></sec><sec id="sec030"><title>Top-<italic>K</italic></title><p>All the algorithms have been implemented, for practical reasons, in a simplified way. We considered that the vector objects are the MBRs of the leafs of the R-tree. With this, we avoid running the computational geometry algorithm, whose implementation is the same in the code of both the baselines and <monospace>k<sup>2</sup>-raster</monospace>. Therefore, the <italic>checkGeometry</italic> function uses a simple map between the MBRs and the corresponding overlapping cells.</p><sec id="sec031"><title>Memory usage</title><p><xref ref-type="fig" rid="pone.0226943.g011">Fig 11</xref> shows the memory consumption for top-1, top-10, and top-100 for the datasets of Scenario I. The uncompressed baselines that completely store the raster in main memory are the worse alternatives, using between 3 and 9 times more memory than our framework. Although <monospace>k<sup>2</sup>-treap</monospace> performs worse than the uncompressed baselines dealing with small files, it scales better, but still, it is between 5 and 15 times worse than <monospace>k<sup>2</sup>-raster</monospace>.</p><fig id="pone.0226943.g011" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g011</object-id><label>Fig 11</label><caption><title>Average memory consumption for retrieving the top-<italic>K</italic> over collections of Scenario I.</title><p>Average memory consumption (in Megabytes) for retrieving the top 1, 10 and 100 MBRs over collections of Scenario I. (a) top-1 and <monospace>vects</monospace> dataset, (b) top-1 and <monospace>vecca</monospace> dataset, (c) top-10 and <monospace>vects</monospace> dataset, (d) top-10 and <monospace>vecca</monospace> dataset, (e) top-100 and <monospace>vects</monospace> dataset and (f) top-100 and <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g011"/></fig><p>The traditional processing of NetCDF files by blocks makes this alternative the best one dealing with large files. With small files, <monospace>k<sup>2</sup>-raster</monospace> consumes around 2 times less, whereas in large files the behavior is just the opposite. Finally, the <monospace>cells</monospace> strategy with <italic>k</italic><sup>2</sup>-raster has exactly the same behaviour as our method.</p><p>
<xref ref-type="fig" rid="pone.0226943.g012">Fig 12</xref> shows the memory consumption for the datasets of Scenario II. We only include the results for top-10. In this experiment, NetCDF is the clear winner, consuming around 7 times less than <monospace>k<sup>2</sup>-raster</monospace>.</p><fig id="pone.0226943.g012" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g012</object-id><label>Fig 12</label><caption><title>Average memory consumption for retrieving the top-<italic>K</italic> over collections of Scenario II.</title><p>Average memory consumption (in Megabytes) for retrieving the top 10 MBRs over collections of Scenario II. (a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g012"/></fig></sec><sec id="sec032"><title>Time performance</title><p><xref ref-type="fig" rid="pone.0226943.g013">Fig 13</xref> shows the average time results for our experiments, performing, respectively, top-1, top-10 and top-100 operations. For clarity, times are shown in logarithmic scale.</p><fig id="pone.0226943.g013" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g013</object-id><label>Fig 13</label><caption><title>Average time results for retrieving the top-<italic>K</italic> over collections of Scenario I.</title><p>Average time results (in seconds) for retrieving the top 1, 10 and 100 MBRs over collections of Scenario I. We compare the results for all the algorithms using logarithmic scales for all the figures. (a) top-1 and <monospace>vects</monospace> dataset, (b) top-1 and <monospace>vecca</monospace> dataset, (c) top-10 and <monospace>vects</monospace> dataset, (d) top-10 and <monospace>vecca</monospace> dataset, (e) top-100 and <monospace>vects</monospace> dataset and (f) top-100 and <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g013"/></fig><p>The main advantage of our algorithm is that it uses two indexes simultaneously and synchronously. During a filtering process, discarding nodes of one index allows us to also discard some nodes of the other, and the other way around. This fact saves time with respect to the naive strategies of the baselines, which take as starting point one of the datasets, and process some of their elements (MBRs, cells) in a certain order. Each element examined implies a search in the other dataset (with or without the help of an index), sometimes unsuccessfully. This means a great loss of time. This conclusion is confirmed by the experiments: our algorithm obtains the best top-<italic>K</italic> retrieval times in all scenarios, up to four orders of magnitude better than <monospace>NetCDF-cells</monospace> and <monospace>Plain-cells</monospace>, up to 5 times faster than <monospace>Plain-mbrs</monospace>, and up to 33 times than <monospace>k<sup>2</sup>-treap</monospace> and <monospace>k<sup>2</sup>-raster-cells</monospace>. Some other facts support these results:</p><list list-type="bullet"><list-item><p>First of all, <monospace>mbrs</monospace> strategy works better than <monospace>cells</monospace>, as it can be seen with <monospace>Plain-mbrs</monospace> and <monospace>Plain-cells</monospace>. Finding the MBRs that overlap with each cell is fast thanks to the R-tree; but it may happen that most of the cells with the highest values do not overlap with any leaf MBR, so that many searches in the R-tree finally become a waste of time. Instead, <monospace>Plain-mbrs</monospace> starts processing leaf MBRs (and there are fewer MBRs than cells), and for each of those MBRs it must check just a few raster cells (so not using an index does not penalize too much). In fact, it is close to the <monospace>k<sup>2</sup>-raster</monospace> performance, behaving worse mainly because it never filters leaf MBRs, and thus it must check raster cells for each one of them.</p></list-item><list-item><p>Second, compression penalizes the baselines <monospace>NetCDF-mbrs</monospace> and <monospace>NetCDF-cells</monospace>, which always perform worse than their alternative plain versions, that is, <monospace>Plain-mbrs</monospace> and <monospace>Plain-cells</monospace>. However, <monospace>k<sup>2</sup>-raster</monospace> offers close compression rates that do not penalize search times.</p></list-item><list-item><p>Finally, as expected, although <monospace>Plain-cells</monospace>, <monospace>k<sup>2</sup>-raster-cells</monospace>, and <monospace>k<sup>2</sup>-treap</monospace> follow the same strategy, the compressed data structures behave better, since they use an additional index that allows accessing the raster cells in an orderly and cost-free manner. However, those indexes are not enough to reach the performance of <monospace>k<sup>2</sup>-raster</monospace> and its synchronized filtering process.</p></list-item></list><p>
<xref ref-type="fig" rid="pone.0226943.g014">Fig 14</xref> shows the times for the datasets of Scenario II, for top-10. The value of <monospace>NetCDF-cells</monospace> for the <monospace>vecca</monospace> raster with largest number of different values is not displayed because it lasted too long.</p><fig id="pone.0226943.g014" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g014</object-id><label>Fig 14</label><caption><title>Time performance for retrieving the top-<italic>K</italic> MBRs over collections of Scenario II.</title><p>Time performance (in seconds) for retrieving the top 10 MBRs over collections of Scenario II. Both axes uses a logarithmic scale. (a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g014"/></fig><p>
<xref ref-type="fig" rid="pone.0226943.g015">Fig 15</xref> shows the box plots for executing the top-10 queries over each raster matrix of the <monospace>DTM-1&#x000d7;1</monospace> of Scenario I. Baselines using <monospace>cells</monospace> strategy obtain hugely irregular query times, as their performance highly depends on the existence of leaf MBRs overlapping the cells first returned by the algorithm (those having the largest values). <monospace>k<sup>2</sup>-treap</monospace> and <monospace>k<sup>2</sup>-raster-cells</monospace> have approximately the same results, since both, as explained, use a <monospace>cells</monospace> strategy with the help of an index which allows them to access the cells in an orderly manner. They show a much worse behaviour on average than <monospace>k<sup>2</sup>-raster</monospace>, although they perform better in certain occasions, specially when dealing with the <monospace>vects</monospace> dataset. When most top-<italic>K</italic> cells match leaf MBRs, <monospace>k<sup>2</sup>-treap</monospace> and <monospace>k<sup>2</sup>-raster-cells</monospace> are always faster than <monospace>k<sup>2</sup>-raster</monospace> solving queries. However, our synchronous algorithm promotes this best-case scenario, discarding &#x0201c;bad&#x0201d; cells beforehand, and making <monospace>k<sup>2</sup>-raster</monospace> better on average. This suggests that it could be promising to adapt our algorithm to <monospace>k<sup>2</sup>-treap</monospace> too. Unfortunately, <monospace>k<sup>2</sup>-treap</monospace> is not a feasible option for the framework, since it would only be useful in this query, being inefficient for the top-<italic>K</italic> version with the minimum values, or the join query, among others.</p><fig id="pone.0226943.g015" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g015</object-id><label>Fig 15</label><caption><title>Box plots showing time results for retrieving the top-10 MBRs.</title><p>Box plots showing time results (in seconds) for retrieving the top-10 MBRs for the 25 matrices of collection <monospace>DTM-1&#x000d7;1</monospace>. The y axis is in logarithmic scale. (a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g015"/></fig></sec><sec id="sec033"><title>Main memory consumption versus processing time trade-off</title><p>Finally, <xref ref-type="fig" rid="pone.0226943.g016">Fig 16</xref> includes two plots showing the trade-off between main memory consumption and processing time achieved with the largest dataset of Scenario I and top-10, using logarithmic scale in the <italic>x</italic> axis. As seen, our method method is by far the best choice.</p><fig id="pone.0226943.g016" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g016</object-id><label>Fig 16</label><caption><title>Memory consumption vs processing time with the largest raster of Scenario I and top-10.</title><p>Memory consumption (in Megabytes) vs processing time (in seconds) with the largest raster of Scenario I and top-10. (a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g016"/></fig></sec><sec id="sec034"><title>Cold start</title><p><xref ref-type="fig" rid="pone.0226943.g017">Fig 17</xref> shows the results of the experiment in &#x0201c;cold&#x0201d; start for top-10. In this experiment, the differences between our method and <italic>k</italic><sup>2</sup>-treap are shortened.</p><fig id="pone.0226943.g017" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0226943.g017</object-id><label>Fig 17</label><caption><title>Time performance for retrieving the top-10 MBRs over collections of Scenario I in cold start.</title><p>The y axis uses a logarithmic scale. (a) <monospace>vects</monospace> dataset and (b) <monospace>vecca</monospace> dataset.</p></caption><graphic xlink:href="pone.0226943.g017"/></fig></sec></sec></sec><sec id="sec035"><title>Results discussion</title><p>In our experiments with the join operation, our new framework consumes between 31&#x02013;89% of memory used by our <monospace>Plain</monospace> baselines, for which, in addition, the time performance is improved up to 8 times.</p><p>In the case of <monospace>NetCDF</monospace>, our framework is around three orders of magnitude faster, while it only implies a slight sacrifice in space.</p><p>In the case of top-<italic>K</italic>, our framework is up to five orders of magnitude faster than the <monospace>Plain-cells</monospace> and <monospace>NetCDF-cells</monospace>, and up to 33 times faster than the <monospace>k<sup>2</sup>-treap</monospace> and <monospace>k<sup>2</sup>-raster-cells</monospace>.</p><p>The memory consumption shows important improvements; our framework requires between 3 and 9 times less memory than the <monospace>Plain</monospace> baselines, in the case of the top-<italic>K</italic> operation, and up to 3 times in the join. In the case of the <monospace>k<sup>2</sup>-treap</monospace>, used in the top-<italic>K</italic> operation, our method uses between 5 and 15 times less space, which shows that using a compact data structure does not directly imply a gain in memory consumption, and thus a careful design of query algorithms is required.</p><p>The reason of these improvements is due to the fact that our algorithms take advantage of a smaller input, and thus the memory hierarchy between main memory and the processor is more efficient; and that they make intelligent use of the indexes of the <italic>k</italic><sup>2</sup>-raster, which includes, in the same compressed space, a spatial index and an index over the values of the raster.</p></sec><sec sec-type="conclusions" id="sec036"><title>Conclusions</title><p>The possibility of managing raster and vector datasets in geographical information systems is a convenient feature, since it is well-known that each model is more adequate depending on the nature of the spatial data [<xref rid="pone.0226943.ref001" ref-type="bibr">1</xref>]. However, commercial and open-source systems, and even the OGC standard [<xref rid="pone.0226943.ref023" ref-type="bibr">23</xref>, <xref rid="pone.0226943.ref024" ref-type="bibr">24</xref>], separate both views and do not provide languages, data structures, and algorithms to perform queries that use information from both models.</p><p>The exception to this rule could be the zonal statistics operation of Map Algebra [<xref rid="pone.0226943.ref049" ref-type="bibr">49</xref>] that is included in several systems. However, those systems internally translate the vector dataset into a raster dataset before running the operation. In this work, we have presented a framework that includes two known data structures and two new algorithms for running a join between vector and raster datasets, and for retrieving <italic>K</italic> objects of a vector dataset that overlap cells of a raster dataset, such that the <italic>K</italic> objects are those overlapping the highest (or lowest) cell values among all objects, without a previous transformation of any of them. The good properties shown by this new approach are due to the use of compact data structures, which allows efficient processing in little space.</p><p>The idea of compact data structures, like the <italic>k</italic><sup>2</sup>-raster, is to keep the information always compressed, even when processing it. The <italic>k</italic><sup>2</sup>-raster have been proven to be a good approach when performing operations involving the raster alone [<xref rid="pone.0226943.ref013" ref-type="bibr">13</xref>, <xref rid="pone.0226943.ref014" ref-type="bibr">14</xref>]. However, in this work, we show that the use of <italic>k</italic><sup>2</sup>-rasters for storing raster data brings new opportunities, in this case, efficient operations between a raster and a vector dataset without translating none of them.</p><p>The use of the <italic>k</italic><sup>2</sup>-raster represented a challenge. It was designed to be used in main memory without a previous decompression of the whole dataset, but this requires a complex arrangement of the data (something analogous to most compact data structures). This means that the decompression processes applied on small parts upon demand, and the management of the indexes it contains, can degrade the main memory consumption, and affect the processing times. If we did not design the algorithms carefully, both problems could arise. As shown in our experiments, we have successfully solved it.</p><p>The election of the R-tree for indexing the vector dataset is a pragmatic choice, since it is the <italic>de facto</italic> standard for this type of data. However, as future work we will consider the use of modern compact data structures as a substitution for the R-tree. We also plan to add new operations between raster and vector datasets to our framework.</p></sec></body><back><ack><p>The authors wish to thank Antonio Corral for providing the code of their spatial join.</p></ack><ref-list><title>References</title><ref id="pone.0226943.ref001"><label>1</label><mixed-citation publication-type="other">Couclelis H. People Manipulate Objects (but Cultivate Fields): Beyond the Raster-Vector Debate in GIS. In: International Conference GIS: from space to territory&#x02014;theories and methods of spatio-temporal reasoning. London: Springer-Verlag; 1992. p. 65&#x02013;77.</mixed-citation></ref><ref id="pone.0226943.ref002"><label>2</label><mixed-citation publication-type="journal">
<name><surname>Li</surname><given-names>Y</given-names></name>, <name><surname>Bretschneider</surname><given-names>TR</given-names></name>. <article-title>Semantic-Sensitive Satellite Image Retrieval</article-title>. <source>IEEE Transactions on Geoscience and Remote Sensing</source>. <year>2007</year>;<volume>45</volume>(<issue>4</issue>):<fpage>853</fpage>&#x02013;<lpage>860</lpage>. <pub-id pub-id-type="doi">10.1109/TGRS.2007.892008</pub-id></mixed-citation></ref><ref id="pone.0226943.ref003"><label>3</label><mixed-citation publication-type="journal">
<name><surname>Quartulli</surname><given-names>M</given-names></name>, <name><surname>Olaizola</surname><given-names>GI</given-names></name>. <article-title>A review of EO image information mining</article-title>. <source>ISPRS Journal of Photogrammetry and Remote Sensing</source>. <year>2013</year>;<volume>75</volume>:<fpage>11</fpage>&#x02013;<lpage>28</lpage>. <pub-id pub-id-type="doi">10.1016/j.isprsjprs.2012.09.010</pub-id></mixed-citation></ref><ref id="pone.0226943.ref004"><label>4</label><mixed-citation publication-type="other">Grumbach S, Rigaux P, Segoufin L. Manipulating interpolated data is easier than you thought. In: 26th International Conference on Very Large Data Bases. San Francisco, CA: Morgan Kaufmann Publishers Inc.; 2000. p. 156&#x02013;165.</mixed-citation></ref><ref id="pone.0226943.ref005"><label>5</label><mixed-citation publication-type="other">Environmental Systems Research Institute Inc. Zonal Statistics Help&#x02014;ArcGis for Desktop; 2016. Available from: <ext-link ext-link-type="uri" xlink:href="http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=Zonal_Statistics">http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=Zonal_Statistics</ext-link>.</mixed-citation></ref><ref id="pone.0226943.ref006"><label>6</label><mixed-citation publication-type="other">GRASS development team. GRASS GIS manual:v.rast.stats; 2016. Available from: <ext-link ext-link-type="uri" xlink:href="https://grass.osgeo.org/grass72/manuals/v.rast.stats.html">https://grass.osgeo.org/grass72/manuals/v.rast.stats.html</ext-link>.</mixed-citation></ref><ref id="pone.0226943.ref007"><label>7</label><mixed-citation publication-type="other">Corral A, Vassilakopoulos M, Manolopoulos Y. Algorithms for joining R-trees and linear region quadtrees. In: 6th International Symposium on Advances in Spatial Databases. London: Springer-Verlag; 1999. p. 251&#x02013;269.</mixed-citation></ref><ref id="pone.0226943.ref008"><label>8</label><mixed-citation publication-type="other">Corral A, Torres M, Vassilakopoulos M, Manolopoulos Y. Predictive Join Processing between Regions and Moving Objects. In: 12th East European conference on Advances in Databases and Information Systems. Berlin, Heidelberg, Germany: Springer-Verlag; 2008. p. 46&#x02013;61.</mixed-citation></ref><ref id="pone.0226943.ref009"><label>9</label><mixed-citation publication-type="journal">
<name><surname>Brisaboa</surname><given-names>NR</given-names></name>, <name><surname>de Bernardo</surname><given-names>G</given-names></name>, <name><surname>Guti&#x000e9;rrez</surname><given-names>G</given-names></name>, <name><surname>Luaces</surname><given-names>MR</given-names></name>, <name><surname>Param&#x000e1;</surname><given-names>JR</given-names></name>. <article-title>Efficiently Querying Vector and Raster Data</article-title>. <source>The Computer Journal</source>. <year>2017</year>;<volume>60</volume>(<issue>9</issue>):<fpage>1395</fpage>&#x02013;<lpage>1413</lpage>. <pub-id pub-id-type="doi">10.1093/comjnl/bxx011</pub-id></mixed-citation></ref><ref id="pone.0226943.ref010"><label>10</label><mixed-citation publication-type="other">Eldawy A, Niu L, Haynes D, Su Z. Large Scale Analytics of Vector+Raster Big Spatial Data. In: Proceedings of the 25th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems. SIGSPATIAL&#x02019;17; 2017. p. 62:1&#x02013;62:4.</mixed-citation></ref><ref id="pone.0226943.ref011"><label>11</label><mixed-citation publication-type="book">
<name><surname>Plattner</surname><given-names>H</given-names></name>, <name><surname>Zeier</surname><given-names>A</given-names></name>. <source>In-Memory Data Management: Technology and Applications</source>. <publisher-loc>Heidelberg, Germany</publisher-loc>: <publisher-name>Springer-Verlag Berlin</publisher-name>; <year>2012</year>.</mixed-citation></ref><ref id="pone.0226943.ref012"><label>12</label><mixed-citation publication-type="other">de Bernardo G, &#x000c1;lvarez-Garc&#x000ed;a S, Brisaboa NR, Navarro G, Pedreira O. Compact Querieable Representations of Raster Data. In: 20th International Symposium on String Processing and Information Retrieval. New York, NY: Springer-Verlag; 2013. p. 96&#x02013;108.</mixed-citation></ref><ref id="pone.0226943.ref013"><label>13</label><mixed-citation publication-type="other">Ladra S, Param&#x000e1; JR, Silva-Coira F. Compact and queryable representation of raster datasets. In: 28th International Conference on Scientific and Statistical Database Management. New York, NY, USA: ACM; 2016. p. 15:1&#x02013;15:12.</mixed-citation></ref><ref id="pone.0226943.ref014"><label>14</label><mixed-citation publication-type="journal">
<name><surname>Ladra</surname><given-names>S</given-names></name>, <name><surname>Param&#x000e1;</surname><given-names>JR</given-names></name>, <name><surname>Silva-Coira</surname><given-names>F</given-names></name>. <article-title>Scalable and Queryable Compressed Storage Structure for Raster Data</article-title>. <source>Information Systems</source>. <year>2017</year>;<volume>72</volume>:<fpage>179</fpage>&#x02013;<lpage>204</lpage>. <pub-id pub-id-type="doi">10.1016/j.is.2017.10.007</pub-id></mixed-citation></ref><ref id="pone.0226943.ref015"><label>15</label><mixed-citation publication-type="other">Pinto A, Seco D, Guti&#x000e9;rrez G. Improved Queryable Representations of Rasters. In: Data Compression Conference. IEEE. IEEE; 2017. p. 320&#x02013;329.</mixed-citation></ref><ref id="pone.0226943.ref016"><label>16</label><mixed-citation publication-type="book">
<name><surname>Navarro</surname><given-names>G</given-names></name>. <source>Compact Data Structures&#x02014;A practical approach</source>. <publisher-loc>New York, NY</publisher-loc>: <publisher-name>Cambridge University Press</publisher-name>; <year>2016</year>.</mixed-citation></ref><ref id="pone.0226943.ref017"><label>17</label><mixed-citation publication-type="book">
<name><surname>Plattner</surname><given-names>H</given-names></name>. <source>A Course in In-Memory Data Management: The Inner Mechanics of In-Memory Databases</source>. <publisher-loc>Heidelberg, Germany</publisher-loc>: <publisher-name>Springer-Verlag Berlin</publisher-name>; <year>2013</year>.</mixed-citation></ref><ref id="pone.0226943.ref018"><label>18</label><mixed-citation publication-type="other">Guttman A. R-trees: A Dynamic Index Structure for Spatial Searching. In: 1984 ACM SIGMOD international conference on Management of data. New York, NY: ACM; 1984. p. 47&#x02013;57.</mixed-citation></ref><ref id="pone.0226943.ref019"><label>19</label><mixed-citation publication-type="book">
<name><surname>Manolopoulos</surname><given-names>Y</given-names></name>, <name><surname>Nanopoulos</surname><given-names>A</given-names></name>, <name><surname>Papadopoulos</surname><given-names>AN</given-names></name>, <name><surname>Theodoridis</surname><given-names>Y</given-names></name>. <source>R-trees: Theory and Applications (Advanced Information and Knowledge Processing)</source>. <publisher-loc>Secaucus, NJ</publisher-loc>: <publisher-name>Springer-Verlag New York</publisher-name>; <year>2005</year>.</mixed-citation></ref><ref id="pone.0226943.ref020"><label>20</label><mixed-citation publication-type="book">
<name><surname>Worboys</surname><given-names>MF</given-names></name>, <name><surname>Duckham</surname><given-names>M</given-names></name>. <source>GIS: a computing perspective</source>. <publisher-loc>Boca Raton, FL</publisher-loc>: <publisher-name>CRC press</publisher-name>; <year>2004</year>.</mixed-citation></ref><ref id="pone.0226943.ref021"><label>21</label><mixed-citation publication-type="other">ISO. Geographic information&#x02014;Spatial schema. Geneva, Switzerland; 2003. ISO 19107:2003.</mixed-citation></ref><ref id="pone.0226943.ref022"><label>22</label><mixed-citation publication-type="other">ISO. Geographic information&#x02014;Schema for coverage geometry and functions. Geneva, Switzerland; 2005. ISO 19123:2005.</mixed-citation></ref><ref id="pone.0226943.ref023"><label>23</label><mixed-citation publication-type="other">OGC. OpenGIS Web Feature Service 2.0 Interface Standard. Wayland, MA; 2010. OGC 09-025r2.</mixed-citation></ref><ref id="pone.0226943.ref024"><label>24</label><mixed-citation publication-type="other">OGC. OpenGIS Web Coverage Service 2.0 Interface Standard&#x02014;Core: Corrigendum. Wayland, MA; 2012. OGC 09-110r4.</mixed-citation></ref><ref id="pone.0226943.ref025"><label>25</label><mixed-citation publication-type="other">Tomlin CD, Berry JK. Mathematical structure for cartographic modeling in environmental analysis. In: the American Congress on Surveying and Mapping 39th Annual Meeting. ACSM; 1979. p. 269&#x02013;283.</mixed-citation></ref><ref id="pone.0226943.ref026"><label>26</label><mixed-citation publication-type="book">
<name><surname>Tomlin</surname><given-names>DC</given-names></name>. <source>Geographic Information Systems and Cartographic Modeling</source>. <publisher-loc>Englewood Cliffs, NJ</publisher-loc>: <publisher-name>Prentice-Hall</publisher-name>; <year>1990</year>.</mixed-citation></ref><ref id="pone.0226943.ref027"><label>27</label><mixed-citation publication-type="other">Svensson P, Zhexue H. Geo&#x02013;SAL: A Query Language for Spatial Data Analysis. In: SSD 1991. vol. 525 of LNCS. Berlin, Heidelberg: Springer; 1991. p. 119&#x02013;142.</mixed-citation></ref><ref id="pone.0226943.ref028"><label>28</label><mixed-citation publication-type="other">Baumann P, Dehmel A, Furtado P, Ritsch R, Widmann N. The Multidimensional Database System RasDaMan. In: 1998 ACM SIGMOD international conference on Management of data. New York, NY: ACM; 1998. p. 575&#x02013;577.</mixed-citation></ref><ref id="pone.0226943.ref029"><label>29</label><mixed-citation publication-type="other">Vaisman A, Zim&#x000e1;nyi E. A multidimensional model representing continuous fields in spatial data warehouses. In: 17th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems. New York: ACM; 2009. p. 168&#x02013;177.</mixed-citation></ref><ref id="pone.0226943.ref030"><label>30</label><mixed-citation publication-type="other">Brown PG. Overview of SciDB: large scale array storage, processing and analysis. In: 2010 ACM SIGMOD International Conference on Management of data. New York, NY: ACM press; 2010. p. 963&#x02013;968.</mixed-citation></ref><ref id="pone.0226943.ref031"><label>31</label><mixed-citation publication-type="journal">
<name><surname>Brisaboa</surname><given-names>NR</given-names></name>, <name><surname>Ladra</surname><given-names>S</given-names></name>, <name><surname>Navarro</surname><given-names>G</given-names></name>. <article-title>Compact Representation of Web Graphs with Extended Functionality</article-title>. <source>Information Systems</source>. <year>2014</year>;<volume>39</volume>(<issue>1</issue>):<fpage>152</fpage>&#x02013;<lpage>174</lpage>. <pub-id pub-id-type="doi">10.1016/j.is.2013.08.003</pub-id></mixed-citation></ref><ref id="pone.0226943.ref032"><label>32</label><mixed-citation publication-type="other">Klinger A. Patterns and search statistics. In: Symposium Held at The Center for Tomorrow The Ohio State University. New York, NY, USA: Academic Press; 1971. p. 303&#x02013;337.</mixed-citation></ref><ref id="pone.0226943.ref033"><label>33</label><mixed-citation publication-type="journal">
<name><surname>Klinger</surname><given-names>A</given-names></name>, <name><surname>Dyer</surname><given-names>CR</given-names></name>. <article-title>Experiments on Picture Representation Using Regular Decomposition</article-title>. <source>Computer Graphics Image Processing</source>. <year>1976</year>;<volume>5</volume>(<issue>1</issue>):<fpage>68</fpage>&#x02013;<lpage>105</lpage>. <pub-id pub-id-type="doi">10.1016/S0146-664X(76)80006-8</pub-id></mixed-citation></ref><ref id="pone.0226943.ref034"><label>34</label><mixed-citation publication-type="book">
<name><surname>Samet</surname><given-names>H</given-names></name>. <source>Foundations of Multimensional and Metric Data Structures</source>. <publisher-loc>San Francisco, CA</publisher-loc>: <publisher-name>Morgan Kaufmann</publisher-name>; <year>2006</year>.</mixed-citation></ref><ref id="pone.0226943.ref035"><label>35</label><mixed-citation publication-type="other">Jacobson G. Space-efficient static trees and graphs. In: 30th Annual Symposium on Foundations of Computer Science. Washington, DC, USA: IEEE Computer Society; 1989. p. 549&#x02013;554.</mixed-citation></ref><ref id="pone.0226943.ref036"><label>36</label><mixed-citation publication-type="journal">
<name><surname>Brisaboa</surname><given-names>NR</given-names></name>, <name><surname>Ladra</surname><given-names>S</given-names></name>, <name><surname>Navarro</surname><given-names>G</given-names></name>. <article-title>DACs: Bringing direct access to variable-length codes</article-title>. <source>Information Processing and Management</source>. <year>2013</year>;<volume>49</volume>:<fpage>392</fpage>&#x02013;<lpage>404</lpage>. <pub-id pub-id-type="doi">10.1016/j.ipm.2012.08.003</pub-id></mixed-citation></ref><ref id="pone.0226943.ref037"><label>37</label><mixed-citation publication-type="other">Seidemann M, Seeger B. ChronicleDB: A High-Performance Event Store. In: 20th International Conference on Extending Database Technology; 2017. p. 144&#x02013;155.</mixed-citation></ref><ref id="pone.0226943.ref038"><label>38</label><mixed-citation publication-type="other">Moerkotte G. Small Materialized Aggregates: A Light Weight Index Structure for Data Warehousing. In: 24rd International Conference on Very Large Data Bases. San Francisco, CA: Morgan Kaufmann Publishers Inc.; 1998. p. 476&#x02013;487.</mixed-citation></ref><ref id="pone.0226943.ref039"><label>39</label><mixed-citation publication-type="other">Athanassoulis M, Ailamaki A. BF-tree: Approximate Tree Indexing. In: 40th International Conference on Very Large Databases. vol. 7. VLDB Endowment; 2014. p. 1881&#x02013;1892.</mixed-citation></ref><ref id="pone.0226943.ref040"><label>40</label><mixed-citation publication-type="journal">
<name><surname>Brisaboa</surname><given-names>NR</given-names></name>, <name><surname>de Bernardo</surname><given-names>G</given-names></name>, <name><surname>Konow</surname><given-names>R</given-names></name>, <name><surname>Navarro</surname><given-names>G</given-names></name>, <name><surname>Seco</surname><given-names>D</given-names></name>. <article-title>Aggregated 2D range queries on clustered points</article-title>. <source>Information Systems</source>. <year>2016</year>;<volume>60</volume>:<fpage>34</fpage>&#x02013;<lpage>49</lpage>. <pub-id pub-id-type="doi">10.1016/j.is.2016.03.004</pub-id></mixed-citation></ref><ref id="pone.0226943.ref041"><label>41</label><mixed-citation publication-type="other">Lee C, Yang M, Aydt R. NetCDF-4 Performance Report. Technical report, HDF Group; 2008.</mixed-citation></ref><ref id="pone.0226943.ref042"><label>42</label><mixed-citation publication-type="other">Deutsch LP. RFC 1951: DEFLATE Compressed Data Format Specification version 1.3; 1996.</mixed-citation></ref><ref id="pone.0226943.ref043"><label>43</label><mixed-citation publication-type="other">Rigaux P, Scholl M, Voisard A. Spatial databases: with application to GIS. Morgan Kauffman; 2002.</mixed-citation></ref><ref id="pone.0226943.ref044"><label>44</label><mixed-citation publication-type="journal">
<name><surname>Brinkhoff</surname><given-names>T</given-names></name>, <name><surname>Kriegel</surname><given-names>HP</given-names></name>, <name><surname>Seeger</surname><given-names>B</given-names></name>. <article-title>Efficient Processing of Spatial Joins Using R-trees</article-title>. <source>SIGMOD Record</source>. <year>1993</year>;<volume>22</volume>(<issue>2</issue>):<fpage>237</fpage>&#x02013;<lpage>246</lpage>. <pub-id pub-id-type="doi">10.1145/170036.170075</pub-id></mixed-citation></ref><ref id="pone.0226943.ref045"><label>45</label><mixed-citation publication-type="journal">
<name><surname>Theodoridis</surname><given-names>Y</given-names></name>, <name><surname>Stefanakis</surname><given-names>E</given-names></name>, <name><surname>Sellis</surname><given-names>TK</given-names></name>. <article-title>Efficient Cost Models for Spatial Queries Using R-Trees</article-title>. <source>IEEE Trans Knowl Data Eng</source>. <year>2000</year>;<volume>12</volume>(<issue>1</issue>):<fpage>19</fpage>&#x02013;<lpage>32</lpage>. <pub-id pub-id-type="doi">10.1109/69.842247</pub-id></mixed-citation></ref><ref id="pone.0226943.ref046"><label>46</label><mixed-citation publication-type="other">Theodoridis Y, Stefanakis E, Sellis TK. Cost Models for Join Queries in Spatial Databases. In: Proceedings of the Fourteenth International Conference on Data Engineering. ICDE&#x02019;98. Washington, DC, USA: IEEE Computer Society; 1998. p. 476&#x02013;483.</mixed-citation></ref><ref id="pone.0226943.ref047"><label>47</label><mixed-citation publication-type="journal">
<name><surname>Corral</surname><given-names>A</given-names></name>, <name><surname>Manolopoulos</surname><given-names>Y</given-names></name>, <name><surname>Theodoridis</surname><given-names>Y</given-names></name>, <name><surname>Vassilakopoulos</surname><given-names>M</given-names></name>. <article-title>Cost Models for Distance Joins Queries Using R-trees</article-title>. <source>Data and Knowledge Engineering</source>. <year>2006</year>;<volume>57</volume>(<issue>1</issue>):<fpage>1</fpage>&#x02013;<lpage>36</lpage>. <pub-id pub-id-type="doi">10.1016/j.datak.2005.03.004</pub-id></mixed-citation></ref><ref id="pone.0226943.ref048"><label>48</label><mixed-citation publication-type="other">Gonz&#x000e1;lez R, Grabowski S, M&#x000e4;kinen V, Navarro G. Practical Implementation of Rank and Select Queries. In: 4th Workshop on Efficient and Experimental Algorithms. vol. 0109. Berlin, Heidelberg: Springer-Verlag; 2005. p. 27&#x02013;38.</mixed-citation></ref><ref id="pone.0226943.ref049"><label>49</label><mixed-citation publication-type="journal">
<name><surname>Tomlin</surname><given-names>CD</given-names></name>. <article-title>Map algebra: one perspective</article-title>. <source>Landscape and Urban Planning</source>. <year>1994</year>;<volume>30</volume>(<issue>1-2</issue>):<fpage>3</fpage>&#x02013;<lpage>12</lpage>. <pub-id pub-id-type="doi">10.1016/0169-2046(94)90063-9</pub-id></mixed-citation></ref></ref-list></back></article>